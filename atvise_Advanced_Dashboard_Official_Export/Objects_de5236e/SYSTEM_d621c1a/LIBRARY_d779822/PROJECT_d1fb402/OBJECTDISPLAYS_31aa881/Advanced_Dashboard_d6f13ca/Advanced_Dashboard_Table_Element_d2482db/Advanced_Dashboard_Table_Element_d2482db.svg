<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<svg height="538.75999999999999" version="1.2" width="850" xmlns="http://www.w3.org/2000/svg" xmlns:atv="http://webmi.atvise.com/2007/svgext" xmlns:xlink="http://www.w3.org/1999/xlink">
 <defs/>
 <metadata>
  <atv:parameter behavior="optional" defaultvalue="" desc="Dashboard ID" group="GeneralConfig" name="DashboardID" valuetype="string"/>
  <atv:parameter behavior="optional" config="Table-Type_1;Table-Type_2" defaultvalue="Table-Type_1" desc="Table Type" group="GeneralConfig" name="TableType" valuetype="enum"/>
  <atv:parameter behavior="optional" config="Values;Alarms;Aggregates" defaultvalue="Values" desc="Data Type" group="GeneralConfig" name="DataType" valuetype="enum"/>
  <atv:parameter behavior="optional" config="EnumList;Text" defaultvalue="Text" desc="Series Source" group="GeneralConfig" name="SeriesSource" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="2" desc="InitialRange" group="GeneralConfig" name="InitialRange" valuetype="number"/>
  <atv:parameter behavior="optional" config="s;min;h;day;month" defaultvalue="min" desc="Initial Range Unit" group="GeneralConfig" name="InitialRangeUnit" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="Id Enabled" group="ColumnConfig" name="IdEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="FilterEnabled" group="ColumnConfig" name="FilterEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="Data Reduction Enabled" group="DataOptimization" name="DataReductionEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="1000" desc="Data Reduction Max Size" group="DataOptimization" name="DataReductionMaxSize" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="DataLimitEnabled" group="LimitAnalysis" name="DataLimitEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Data Max Limit" group="LimitAnalysis" name="DataMaxLimit" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="#aa0000" desc="Color Limit Point Max" group="LimitAnalysis" name="ColorLimitPointMax" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="#aa0000" desc="Color Limit Line Max" group="LimitAnalysis" name="ColorLimitLineMax" valuetype="color"/>
  <atv:parameter behavior="optional" config="Dash;DashDot;Dot;LongDash;LongDashDot;LongDashDotDot;ShortDash;ShortDashDot;ShortDashDotDot;ShortDot;Solid" defaultvalue="Solid" desc="Type Limit Line Max" group="LimitAnalysis" name="TypeLimitLineMax" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Data Min Limit" group="LimitAnalysis" name="DataMinLimit" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="#aa0000" desc="Color Limit Point Min" group="LimitAnalysis" name="ColorLimitPointMin" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="#aa0000" desc="Color Limit Line Min" group="LimitAnalysis" name="ColorLimitLineMin" valuetype="color"/>
  <atv:parameter behavior="optional" config="Dash;DashDot;Dot;LongDash;LongDashDot;LongDashDotDot;ShortDash;ShortDashDot;ShortDashDotDot;ShortDot;Solid" defaultvalue="Solid" desc="Type Limit Line Min" group="LimitAnalysis" name="TypeLimitLineMin" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="Data Processing Enabled" group="DataProcessing" name="DataProcessingEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" config="Simple-None;SinglePoint-LastValue;SinglePoint-FirstValue;SinglePoint-Max;SinglePoint-Min;Interval-Addition;Interval-Average;Interval-CountChanges;Interval-CountTimeOff;Interval-CountTimeOn;Interval-Difference;Interval-Histogram;Interval-Integration;FullRange-Addition;FullRange-Average;FullRange-Difference;FullRange-OEEAvailability;FullRange-OEEProductivity" defaultvalue="Simple-None" desc="Data Processing Type" group="DataProcessing" name="DataProcessingType" valuetype="enum"/>
  <atv:parameter behavior="optional" config="Fill-NoValue;Fill-ClosestValueBelow;Fill-ClosestValueAbove;Fill-Average" defaultvalue="Fill-NoValue" desc="Filling Method" group="DataProcessing" name="FillingMethod" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="NV" desc="Replacement Text" group="DataProcessing" name="ReplacementText" valuetype="string"/>
  <atv:parameter behavior="optional" config="AllData-DateTime;Interval-CustomText;Interval-CustomInterval;Interval-Dynamic;Interval-Histogram;Single-Simple" defaultvalue="" desc="Category Type" group="Category Selection" name="CategoryType" valuetype="enum"/>
  <atv:parameter behavior="optional" config="Input-LeadingInput;Input-AllInputs" defaultvalue="Input-LeadingInput" desc="Category Source" group="Category Selection" name="CategorySource" valuetype="enum"/>
  <atv:parameter behavior="optional" desc="Category Leading Input" group="Category Selection" name="CategoryLeadingInput" valuetype="address"/>
  <atv:parameter behavior="optional" defaultvalue="true" desc="Category Round Up" group="Category Selection" name="CategoryRound" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Custom Category" group="Category Selection" name="CategoryCustomText" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="1" desc="Custom Interval Length" group="Category Selection" name="CategoryCustomIntervalLength" valuetype="number"/>
  <atv:parameter behavior="optional" config="s;min;h;day;month" defaultvalue="h" desc="Custom Interval Unit" group="Category Selection" name="CategoryCustomIntervalUnit" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="0" desc="Category Time Offset" group="Category Selection" name="CategoryTimeOffset" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Global Enum List" group="EnumList" name="EnumList" valuetype="global"/>
  <atv:parameter behavior="optional" desc="Input1" group="Series 1" name="Series1Node" valuetype="address"/>
  <atv:parameter behavior="optional" config="Value;Time;Interval;Address" defaultvalue="Value" desc="Column Type 1" group="Series 1" name="Series1ColumnType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Label1" group="Series 1" name="Series1Label" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color1" group="Series 1" name="Series1Color" valuetype="color"/>
  <atv:parameter behavior="optional" desc="Input2" group="Series 2" name="Series2Node" valuetype="address"/>
  <atv:parameter behavior="optional" config="Value;Time;Interval;Address" defaultvalue="Value" desc="Column Type 2" group="Series 2" name="Series2ColumnType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Label2" group="Series 2" name="Series2Label" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color2" group="Series 2" name="Series2Color" valuetype="color"/>
  <atv:parameter behavior="optional" desc="Input3" group="Series 3" name="Series3Node" valuetype="address"/>
  <atv:parameter behavior="optional" config="Value;Time;Interval;Address" defaultvalue="Value" desc="Column Type 3" group="Series 3" name="Series3ColumnType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Label3" group="Series 3" name="Series3Label" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color3" group="Series 3" name="Series3Color" valuetype="color"/>
  <atv:parameter behavior="optional" desc="Input4" group="Series 4" name="Series4Node" valuetype="address"/>
  <atv:parameter behavior="optional" config="Value;Time;Interval;Address" defaultvalue="Value" desc="Column Type 4" group="Series 4" name="Series4ColumnType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Label4" group="Series 4" name="Series4Label" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color4" group="Series 4" name="Series4Color" valuetype="color"/>
  <atv:parameter behavior="optional" desc="Input5" group="Series 5" name="Series5Node" valuetype="address"/>
  <atv:parameter behavior="optional" config="Value;Time;Interval;Address" defaultvalue="Value" desc="Column Type 5" group="Series 5" name="Series5ColumnType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Label5" group="Series 5" name="Series5Label" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color5" group="Series 5" name="Series5Color" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Title" group="Appereance" name="Title" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Subtitle" group="Appereance" name="Subtitle" valuetype="string"/>
  <atv:parameter behavior="optional" config="Color-Pallete;Color-Custom" defaultvalue="Color-Pallete" desc="Color Series Type" group="Appereance" name="ColorSeriesType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Series Palette Color" group="Appereance" name="ColorSeriesPalette" substitute="$Color$" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="Background Transparent Enabled" group="Appereance" name="ColorBackgroundTranspartentEnable" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Background Color" group="Appereance" name="ColorB" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Grid Color" group="Appereance" name="ColorG" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color Title" group="Appereance" name="ColorTitle" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color Subtitle" group="Appereance" name="ColorSubTitle" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="SYSTEM.GLOBALS.atvFontColor" desc="Color dataLabels" group="Appereance" name="ColordataLabels" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="14" desc="TitleFontSize" group="Appereance" name="FontSizeTitle" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="12" desc="Data Labels FontSize" group="Appereance" name="FontSizedataLabels" valuetype="number"/>
  <atv:parameter behavior="optional" config="Time-Dynamic;Time-Custom" defaultvalue="Time-Dynamic" desc="Data Label Time Type" group="Appereance" name="DatalabelTimeType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="mm:ss" desc="Data Label CustomTime Format" group="Appereance" name="DatalabelCustomTimeFormat" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="2" desc="Datalabel Number Decimals" group="Appereance" name="DatalabelNumberDecimals" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Datalabel Unit" group="Appereance" name="DatalabelUnit" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Number of Bins" group="Histogram Only" name="HistogramNumberBins" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Production Speed (U/h)" group="OEE Only" name="OEEProductionSpeed" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="Complete Range Analisis" group="OEE Only" name="OEECompleteRangeAnalisis" valuetype="bool"/>
  <atv:gridconfig enabled="true" gridstyle="lines" height="20" width="20"/>
  <atv:snapconfig enabled="true" height="10" width="10"/>
 </metadata>
 <rect atv:refpx="424.5" atv:refpy="270" fill="none" height="540" id="id_0" stroke="#000000" stroke-width="2" width="849" x="0" y="0"/>
 <svg atv:refpx="425" atv:refpy="307.433" height="580" id="Table_Container" transform="matrix(1.3281,0,0,0.8929,0,0)" width="640" x="0" xlink:href="SYSTEM.LIBRARY.ATVISE.OBJECTDISPLAYS.Advanced.slickgrid.table_panel" y="0">
  <atv:argument name="tableID" value="Dynamic_Table"/>
  <atv:argument name="globalFillColor" prefix="ColorB" value="SYSTEM.GLOBALS."/>
  <atv:argument name="globalFontColor" prefix="ColordataLabels" value="SYSTEM.GLOBALS."/>
  <atv:argument name="filterBar" prefix="FilterEnabled"/>
  <atv:argument name="row_height" value="30"/>
  <atv:overwrite height="517.882" id="id_1" transform="matrix(0.753,0,0,1.1199,0,0)" width="849.984"/>
 </svg>
 <svg atv:refpx="425" atv:refpy="579.382" height="25" id="id_7" transform="matrix(1.3281,0,0,0.7505,0,0)" width="640" x="0" xlink:href="SYSTEM.LIBRARY.ATVISE.OBJECTDISPLAYS.Advanced.slickgrid.table_footer" y="692.828">
  <atv:argument name="tableID" value="Dynamic_Table"/>
 </svg>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/highcharts.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/highcharts-more.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/modules/exporting.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/modules/funnel.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/modules/solid-gauge.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/modules/histogram-bellcurve.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript"><![CDATA[//------Initialize Variables-----------//

//------Parameters   
var Initializing=true;
var chartContainter;

//Chart Config Construction 
const elementRawConfig = { 

	// General Configuration
	GeneralConfig: {
		DashboardID: webMI.query["DashboardID"],
		ChartType: webMI.query["TableType"] /*"Line"*/,
		DataType: webMI.query["DataType"],
		SeriesSource: webMI.query["SeriesSource"],
		InitialRange: webMI.query["InitialRange"],
		InitialRangeUnit: webMI.query["InitialRangeUnit"]
	},	
	
	// General Configuration
	ColumnConfig: {
		IdEnabled: webMI.query["IdEnabled"],
		FilterEnabled: webMI.query["FilterEnabled"],
	},	
	
	// Data Optimization
	DataOptimization: {
		DataReductionEnabled: webMI.query["DataReductionEnabled"],
		DataReductionMaxSize: webMI.query["DataReductionMaxSize"]
	},
	
	// Limit Analysis	
	LimitAnalysis: {
		DataLimitEnabled: webMI.query["DataLimitEnabled"],
		DataMaxLimit: webMI.query["DataMaxLimit"],
		ColorLimitPointMax: webMI.query["ColorLimitPointMax"],
		ColorLimitLineMax: webMI.query["ColorLimitLineMax"],
		TypeLimitLineMax: webMI.query["TypeLimitLineMax"],
		DataMinLimit: webMI.query["DataMinLimit"],		
		ColorLimitPointMin: webMI.query["ColorLimitPointMin"],		
		ColorLimitLineMin: webMI.query["ColorLimitLineMin"],
		TypeLimitLineMin: webMI.query["TypeLimitLineMin"],

	},
	
	// Data Processing
	DataProcessing: {
		DataProcessingEnabled: webMI.query["DataProcessingEnabled"]=== "true",
		ProcessingType: webMI.query["DataProcessingType"] !== undefined ? webMI.query["DataProcessingType"] : "Simple-None",
		FillingMethod:webMI.query["FillingMethod"],
		ReplacementText:webMI.query["ReplacementText"].replace(/\s+/g, ''),
	},
	
	// Category
	Category: {
		CategoryType: webMI.query["CategoryType"],
		CategoryRound: webMI.query["CategoryRound"],
		CategorySource: webMI.query["CategorySource"],
		CategoryLeadingInput: webMI.query["CategoryLeadingInput"],
		CategoryCustomText: webMI.query["CategoryCustomText"] !== undefined ? webMI.query["CategoryCustomText"] : "",
		CategoryCustomIntervalLength: webMI.query["CategoryCustomIntervalLength"],
		CategoryCustomIntervalUnit: webMI.query["CategoryCustomIntervalUnit"],
		CategoryTimeOffset: webMI.query["CategoryTimeOffset"],
		
	},
	// EnumList
	EnumList: {
		EnumList: webMI.query["EnumList"]
	},
	
	// Series
	Series: [
		{
		  SeriesNode: webMI.query["Series1Node"],
		  SeriesColumnType: webMI.query["Series1ColumnType"],		  
		  SeriesLabel: webMI.query["Series1Label"],
		  SeriesColor: webMI.query["Series1Color"]
		},
		{
		  SeriesNode: webMI.query["Series2Node"],
		  SeriesColumnType: webMI.query["Series2ColumnType"],	
		  SeriesLabel: webMI.query["Series2Label"],
		  SeriesColor: webMI.query["Series2Color"]
		},
		{
		  SeriesNode: webMI.query["Series3Node"],
		  SeriesColumnType: webMI.query["Series3ColumnType"],	
		  SeriesLabel: webMI.query["Series3Label"],
		  SeriesColor: webMI.query["Series3Color"]
		},
		{
		  SeriesNode: webMI.query["Series4Node"],
		  SeriesColumnType: webMI.query["Series4ColumnType"],	
		  SeriesLabel: webMI.query["Series4Label"],
		  SeriesColor: webMI.query["Series4Color"]
		},
		{
		  SeriesNode: webMI.query["Series5Node"],
		  SeriesColumnType: webMI.query["Series5ColumnType"],	
		  SeriesLabel: webMI.query["Series5Label"],
		  SeriesColor: webMI.query["Series5Color"]
		}
	],
	
	// Appearance
	Appearance: {
		Title: webMI.query["Title"],
		TitleAlign: webMI.query["TitleAlign"],
		Subtitle: webMI.query["Subtitle"],
		ColorSeriesType:webMI.query["ColorSeriesType"],
		ColorSeriesPalette: webMI.query["ColorSeriesPalette"],
		ColorBackgroundTranspartentEnable:webMI.query["ColorBackgroundTranspartentEnable"],
		ColorBackground: webMI.query["ColorB"],
		ColorGrid: webMI.query["ColorG"],
		ColorTitle: webMI.query["ColorTitle"],
		ColorSubTitle: webMI.query["ColorSubTitle"],
		FontSizeTitle: webMI.query["FontSizeTitle"],
		DatalabelTimeType: webMI.query["DatalabelTimeType"],
		DatalabelCustomTimeFormat: webMI.query["DatalabelCustomTimeFormat"],
		DatalabelNumberDecimals: webMI.query["DatalabelNumberDecimals"],
	},
	
	// Histogram
	Histogram: {
		NumberBins: webMI.query["HistogramNumberBins"]
	},
	
	
	// OEE
	OEE: {
		OEEProductionSpeed: webMI.query["OEEProductionSpeed"],
		OEECompleteRangeAnalisis: webMI.query["OEECompleteRangeAnalisis"]
	}
	
};


//Initialize Process
webMI.addOnload(function() {
	
	//Get Chart container
	chartContainter=document.getElementById("Chart_Container");
	
	//Create Chart Manager
    const singleChartManagerI=new singleChartManager(elementRawConfig);
    
    //Initialize Chart
    singleChartManagerI.initialize();


});


//Single Chart Manager
class singleChartManager {
	// Attributes
	elementRawConfig;
	elementConfig;
	elementID;
	elementData;
	elementNodes;
	operationMode;
	singleDataRequest;
	chartReference;
	specialParameters;	
	chartLabels;
	configConflicts;
	
	// Constructor
	constructor(elementRawConfig) {
		this.chartReference;
		this.elementData;
		this.tableData;
		this.limitData;
		this.elementDataRT;
		this.elementID;
		this.chartNodes=[];
		this.chartLabels=[];
		this.configConflicts={};
		this.chartID=this.createChartID();
		this.chartTimeRange;
		this.elementRawConfig=elementRawConfig;   
		this.specialParameters;
		
		this.tableID="Dynamic_Table";		
		this.columnTypes=[];
		this.tableColumns;
		this.tableColumnIndex;
		this.idColumnEnabled=this.elementRawConfig.ColumnConfig.IdEnabled=="true";
		this.tableController;
		this.tableConfig;
		this.tableReady;
		
		this.operationMode="RealTime"; //Real time by default
		this.elementConfig=this.elementConfigCreator(elementRawConfig);
		this.elementNodes=this.elementConfig.chartNodes;   
		this.dashboardReady=false;
		this.elementDataReady=false;
		this.firstTime=true;
		this.firstTimeRT=true;
		this.chartColors;	
		this.limitAnalysisEnabled = (this.elementRawConfig.LimitAnalysis.DataLimitEnabled=="true" && (this.elementRawConfig.LimitAnalysis.DataMaxLimit.length >0 || this.elementRawConfig.LimitAnalysis.DataMinLimit.length >0)) ;
		this.limitKey="_Limit"
	}
	
	//Initialize everything
	async initialize() {
		
		console.log("-----------Create nodes------------");
		this.createChartNodes();
		console.log(this.chartNodes);
		
		console.log("-----------Element Config------------");
		console.log(this.elementConfig);	
		console.log(this.chartLabels);
		
		//Add listeners           
		this.addListeners(); 
		
		//-----------------------------------------------//
		//----------For Single Chart Requests-----------//	
		
		if (this.elementRawConfig.GeneralConfig.DashboardID == "") {
						
			//Create Single Data Request
			this.singleDataRequest = await this.singleDataRequestCreator();
			console.log("-----------Single Data Request------------");
			console.log(this.singleDataRequest);
			
			//Call for data
			this.elementData = await this.singleelementDataCreator();
			console.log("-----------Single Element Data------------");
			console.log(this.elementData);
			
			
			// Initialize Table
			await this.initializeTable();  // Ensure this happens first
			console.log("-----------Table Initialized------------");
	
			// Update Table
			await this.updateTable();  // Ensure this happens after initializeTable
			console.log("-----------Table Updated------------");
			
			
			
		}
			   
		//-----------------------------------------------//
		//----------In Dashboard Chart Requests---------//       
		else {
			console.log("-----Registering from chart: " + this.chartID + "----------");
	
			// Wait for Dashboard ready
			await this.waitForDashboardReady();
	
			// First Register Elements
			this.registerElements();
	
			// Wait for Data Ready
			await this.waitForElementDataReady();
			console.log("-----------Single Element Data------------");
			console.log(this.elementData);
			console.log(JSON.stringify(this.elementData));
	
			// Initialize Table
			await this.initializeTable();  // Ensure this happens first
			console.log("-----------Table Initialized------------");
			
			//Wait for Table Ready
			await this.waitForTableReady();
			
			// Update Table
			await this.updateTable();  // Ensure this happens after initializeTable
			console.log("-----------Table Updated------------");
		}
			 
		
	}
	
	//-----------------------------------------------//
	//----------------Data Methods-----------------//	
	//---------------------------------------------//
	
	// Adds Listeners
	addListeners() {
	
		//Dashboard Ready Listener
		webMI.trigger.connect("Dashboard_Ready_"+this.DashboardID, (e) => {
			this.dashboardReady=e;
			
			setTimeout((e) => {
				this.dashboardReady=false;
			},200);
		});	
		
		//Table Ready Listener
		webMI.trigger.connect("Table_Ready", (e) => {
			console.log("Setting tableReady")
			this.tableReady=e.value;
		});	
		
		//Recieve Element Info		
		webMI.trigger.connect("Element_Data_"+this.chartID, (e) => {
			
			this.elementData=e.value;
			console.log("-------------this.elementData------------");	
			console.log(this.elementData);	
			
			//Historic Data
			if(this.elementData.RTInfo.OperationMode=="Hist"){
			
				//First time receives Element Data
				if(this.firstTime){
					this.elementDataReady=true;
					this.firstTime=false;
					
					//Toggle
					setTimeout((e) => {
						this.elementDataReady=false;
					},200);
				}
				
				//After Initialization
				else{
					
					console.log("-------------Updating Table------------")
					//UpdateChart
					this.updateTable();
				
				}
			}
			
			//Real Time Data
			else if(this.elementData.RTInfo.OperationMode=="RealTime"){
				/*
				this.elementDataRT=this.elementData;
				console.log("this.elementDataRT");
				console.log(JSON.stringify(this.elementDataRT)); 
				console.log("-------------Updating RT Chart------------");				
				//UpdateChart RT
				this.updateRTChart();
				*/
			}
			
		});
		
		//Subcribe to Variable Changes	
		/*
		webMI.data.subscribe(this.elementNodes,(e) => {
			console.log("-------------New Value------------");
			console.log(e.address);
			
			// Updates chart with RT data
			this.updateChartRT(e.value); 
		});	*/
		
	}	
	
	// Registers Element in Menu
	registerElements() {
	
		//Register Element
		webMI.trigger.fire("Element_Config_Receiver_"+this.DashboardID, this.elementConfig); 
			
	}	
	
	//Create chartNodes
	createChartNodes() {  	
		// Data Source Text
		if (this.elementRawConfig.GeneralConfig.SeriesSource === "Text") {		
			//Take source from parameters
			this.elementRawConfig.Series.forEach((seriesItem) => {
				if (seriesItem.SeriesNode && !(this.chartNodes.includes(seriesItem.SeriesNode)&&this.columnTypes.includes(seriesItem.SeriesColumnType))) { // Check if SeriesNode is not undefined and not already included
					this.chartNodes.push(seriesItem.SeriesNode);
					this.chartLabels.push(seriesItem.SeriesLabel);
					this.columnTypes.push(seriesItem.SeriesColumnType);
				}
				else if (this.chartNodes.includes(seriesItem.SeriesNode)){
					this.configConflicts["repeatedNode"]=true;
				}
			});
		}
		
		// Data Source Enum
		else if (this.elementRawConfig.GeneralConfig.SeriesSource === "EnumList") {
			for (const key in this.elementRawConfig.EnumList.EnumList) {
				if (this.elementRawConfig.EnumList.EnumList.hasOwnProperty(key)) {
					const enumItem = this.elementRawConfig.EnumList.EnumList[key];
					if (enumItem.Node && !(this.chartNodes.includes(enumItem.Node)&&this.columnTypes.includes(enumItem.ColumnType))) { // Check if Node is not undefined and not already included
						this.chartNodes.push(enumItem.Node);
						this.chartLabels.push(enumItem.Label);
						this.columnTypes.push(enumItem.ColumnType);
					}
					else if (this.chartNodes.includes(enumItem.Node)){
						this.configConflicts["repeatedNode"]=true;
					}
				}
			}
		}
	}
	
	// Creates Element Config
	elementConfigCreator() {  
		
		//Create ChartNodes
		console.log("-----------Create nodes------------");
		this.createChartNodes();
		console.log(this.chartNodes);
		
		console.log("-----------Create special Parameters------------")
		this.createSpecialParameters();
		console.log(this.specialParameters);
	
		// ElementConfig Structure
		var elementConfig = {
			chartNodes: this.chartNodes,
			chartsConfig: {
				elementType: "Table",
				chartID: this.chartID,
				chartType: this.elementRawConfig.GeneralConfig.ChartType,
				dataType: this.elementRawConfig.GeneralConfig.DataType,
				dataProcessingType: this.elementRawConfig.DataProcessing.DataProcessingEnabled == true ? this.elementRawConfig.DataProcessing.ProcessingType:"Simple-None",
				dataReductionEnable: this.elementRawConfig.DataOptimization.DataReductionEnabled === "true",
				dataReductionMaxSize: Number(this.elementRawConfig.DataOptimization.DataReductionMaxSize),
				dataoutOfLimitEnable: this.elementRawConfig.LimitAnalysis.DataLimitEnabled === "true",
				dataMaxLimit: this.elementRawConfig.LimitAnalysis.DataMaxLimit,
				dataMinLimit: this.elementRawConfig.LimitAnalysis.DataMinLimit,
				categoryType: this.elementRawConfig.Category.CategoryType,
				categoryRound: this.elementRawConfig.Category.CategoryRound,
				categorCustomValue: this.elementRawConfig.Category.CategoryCustomText,				
				categoryCustomIntervalLength: this.elementRawConfig.Category.CategoryCustomIntervalLength,
				categoryCustomIntervalUnit: this.elementRawConfig.Category.CategoryCustomIntervalUnit,
				categoryTimeOffset:this.elementRawConfig.Category.CategoryTimeOffset,
				specialParameters:this.specialParameters
			}
		};
		
		
		
		//Update 
			// Return elementConfig
			return elementConfig;
	}	
	
	// Creates ChartID based position and size
	createChartID() {
		const thisElement = document.getElementById('Table_Container');
		let index = thisElement.id.indexOf('_Table_Container');
		return thisElement.id.substring(0, index);	
	}
		
	// Create Special Parameters
	createSpecialParameters() {
	
		var specialParametersI={};
		
		//Add Table Special Parameters
		specialParametersI["TableConfig"]={
			CategorySource:this.elementRawConfig.Category.CategoryLeadingInput==undefined ? "Input-AllInputs":this.elementRawConfig.Category.CategorySource,
			CategoryLeadingInput:this.elementRawConfig.Category.CategoryLeadingInput==undefined ? "":this.elementRawConfig.Category.CategoryLeadingInput,
			DataColumnTypes:this.columnTypes,
			FillingMethod:this.elementRawConfig.DataProcessing.FillingMethod,
			ReplacementText:this.elementRawConfig.DataProcessing.ReplacementText
		}
		
		
		if (this.elementRawConfig.DataProcessing.ProcessingType.includes("OEE")){
			//Add Production Speed
			if (this.elementRawConfig.OEE.OEEProductionSpeed!=null){
				specialParametersI["OEEProductionSpeed"]=this.elementRawConfig.OEE.OEEProductionSpeed;
			}
			
			//Add Full Range Analisis
			if (this.elementRawConfig.OEE.OEECompleteRangeAnalisis!=null){
				specialParametersI["OEECompleteRangeAnalisis"]=this.elementRawConfig.OEE.OEECompleteRangeAnalisis;
			}
		}		
		
		this.specialParameters=specialParametersI;
		
	}
	
	// Wait for Dashboard ready
	waitForDashboardReady() {
		return new Promise((resolve) => {
			const checkReady = () => {
				if (this.dashboardReady) {
					resolve();
				} else {
					setTimeout(checkReady, 100);
				}
			};
			checkReady();
		});
	}
	
	// Wait for Element Data ready
	waitForElementDataReady() {
		return new Promise((resolve) => {
			const checkReady = () => {
				if (this.elementDataReady) {
					console.log("-------Element Data Ready--------")
					resolve();
				} else {
					setTimeout(checkReady, 100);
				}
			};
			checkReady();
		});
	}
	
	// Wait for Element Data ready
	waitForTableReady() {
		return new Promise((resolve) => {
			const checkReady = () => {				
				console.log("Waiting for table ready")
				if (this.tableReady) {
					console.log("-------Finally Table ready--------")
					resolve();
				} else {
					setTimeout(checkReady, 100);
				}
			};
			checkReady();
		});
	}
	
	
  
  
  
	//-----------------------------------------------//
	//----------------Table Methods-----------------//	
	//---------------------------------------------//
	
	
	//-----------------------------------------------//
	//--------Historical Table Functions------------//		
	
	
	
	// Initialize Table
	initializeTable() {
		console.log("-----------Initialize Table------------");		
		
		//Hide Label and Border
		webMI.gfx.setVisible("Label", false);
		webMI.gfx.setVisible("Border", false);	
		
		const labelFormatterR=this.dataLabelFormatter.bind(this);
		
		//Create Columns
		this.createTableColumns();
		console.log("-----------Table Column------------");
		console.log(this.tableColumns);
		
		//Create Table Config
		this.createTableConfig();
		console.log("-----------Table Config------------");
		console.log(this.tableConfig);
		console.log(JSON.stringify(this.tableConfig));
		
		//Start Table
		this.startTable();		
	}
	
	//Update Table
	async updateTable() {	
	
		//Create Columns
		this.createTableColumns();
		console.log("-----------Table Column------------");
		console.log(this.tableColumns);
	
		//Create Table Data
		this.createTableData();
		console.log("-----------Table Data------------");
		console.log(this.tableData);		
		
		//Update Table
		webMI.trigger.fire("update_table", {tableController:this.tableController, tableData:this.tableData}); //Update chart		

	}	
	
	//Add limits	
	addLimitSeries() {
			
	}
	
	//Create Columns
	createTableColumns() {
		// Extract the names from chartSeries[0].name (assuming it's a comma-separated string)
		const Names = this.elementData.chartData.chartSeries.name.split(', ');
	
		// Pre-allocate the array size to improve performance
		const columnCount = Names.length + (this.idColumnEnabled ? 1 : 0);
		const Columns = new Array(columnCount);
	
		let columnIndex = 0;
	
		// Conditionally add the 'id' column first if idColumnEnabled is true
		if (this.idColumnEnabled) {
			Columns[columnIndex++] = {
				id: 'id',
				name: 'ID',
				field: 'id',
				sortable: true,
				filter: true
			};
		}
	
		// Use a single loop to assign column objects
		for (let i = 0; i < Names.length; i++) {
			
			this.tableColumnIndex=i;
			
			Columns[columnIndex++] = {
				id: this.defineChartLabel(Names[i]),
				name: this.defineChartLabel(Names[i]),
				field: this.defineChartLabel(Names[i]),
				sortable: true,
				filter: true
			};
		}
	
		// Return the constructed Columns array

		this.tableColumns=Columns;
	}
	
	//Create Table Data
	createTableData() {
		// Extract column IDs
		let columnTableIds = this.tableColumns.map(col => col.id);
	
		const tableData = [];
		const chartSeries = this.elementData.chartData.chartSeries.data;
		
		if (this.idColumnEnabled){
			columnTableIds.shift();
		}
		// Iterate over each row in chartSeries
		for (let j = 0; j < chartSeries.length; j++) {
			let rowData = {};
			
			// If idColumnEnabled is true, add "id" as the first column with the value of j
			if (this.idColumnEnabled) {
				rowData["id"] = j; // Add row index as id
			}
			
			let dataFormated;
			
			// For each column, format the data accordingly
			for (let i = 0; i < columnTableIds.length; i++) {
				const columnId = columnTableIds[i]; // Skip the id when accessing data
				const columnType = this.columnTypes[i]; // Type could be 'Time', 'Value', etc.

				dataFormated= (columnId=="id" ? j :(chartSeries[j][i]==this.elementRawConfig.DataProcessing.ReplacementText ? this.elementRawConfig.DataProcessing.ReplacementText : this.dataLabelFormatter(chartSeries[j][i],columnType)));

				// Apply the dataLabelFormatter depending on column type
				rowData[columnId] = columnId=="id" ? j :this.dataLabelFormatter(chartSeries[j][i],columnType);
			}
	
			// Push formatted row to tableData
			tableData.push(rowData);
		}
	
		this.tableData=tableData;
	}
	
	//Table Data Request Function
	dataRequestFunction(){				
		//Table Reference
		var self = this;
		
		
		webMI.trigger.connect("update_table", function (tableData) {	

			//Insert Data
			tableData.value.tableController.clearData(); //Clean Data
			self.addData({result:tableData.value.tableData}); //Add new Data			
			
		});
		
		webMI.trigger.fire("Table_Ready", true); //Update Table		
	}
	
	//Create Table Config
	createTableConfig(){
		let config = [];
		
		//Configure Columns
		config["columns"] = this.tableColumns;
		
		//Configure Columns
		config["mode"] = "once";
		
		config["dataRequestFunction"]=this.dataRequestFunction;
		
		this.tableConfig=config;
	}
	
	//Start the tabl
	startTable(){	
		// Registration of the configuration //
		webMI.table.register(this.tableID, "config",  this.tableConfig);
		webMI.table.setReady(this.tableID, "config");
		
		//Controler Reference
		this.tableController= webMI.table.request(this.tableID, "controller");
	}
	
	//-----------------------------------------------//
	//--------RT Chart Functions------------//

	updateRTChart() {

		const dataProcessingType = this.elementConfig.chartsConfig.dataProcessingType;
		const elementDataRT = this.elementDataRT;

		//Add limits to the series
		if (this.limitAnalysisEnabled){ 
			console.log("-------Adding limits-----");	
			this.addLimitSeriesRT();		
		}
		
		//Simple Processing (All Data)
		if (dataProcessingType.includes("Simple")) {
				this.updateSimpleData();
		} 
		//FullRange/SinglePoint Processing (One Point)
		else if (dataProcessingType.includes("FullRange") || dataProcessingType.includes("SinglePoint")) {
		
			console.log("-----Updating Full Range--------")
			if (this.firstTimeRT)	{
				setTimeout((e) => {	
					this.updateFullRangeOrSinglePointData();
				},500);
			}
			else{				
				this.updateFullRangeOrSinglePointData();				
			}
		} 
		//Interval Processing (Intervals)
		else if (dataProcessingType.includes("Interval")) {
			if (this.firstTimeRT)	{
				setTimeout((e) => {	
					this.updateIntervalData();
				},200);
			}
			else{				
				this.updateIntervalData();				
			}
			
		} 
		else {
			console.error("Unsupported dataProcessingType: ", dataProcessingType);
		}
	
	}	
	
	addLimitSeriesRT() {
		if (!this.elementDataRT || !this.elementDataRT.chartData || !this.elementDataRT.chartData.LimitDashboardData) {
			console.error("Element data is not available or does not contain limit data.");
			return;
		}
		
		const chartSeries = this.elementDataRT.chartData.chartSeries;
		this.limitData = this.elementDataRT.chartData.LimitDashboardData;
	
		// Check the category type
		if (this.elementConfig.chartsConfig.categoryType === "AllData-DateTime") {
			this.limitData.forEach(limitData => {
				// Create a new series for the limit data
				const limitSeries = {
					name: this.defineChartLabel(limitData.name),
					custom: this.limitKey,
					data: limitData.data.map(limitPoint => ({
						x: limitPoint[0],
						y: limitPoint[1],
						color: limitPoint[1] > this.elementRawConfig.LimitAnalysis.DataMaxLimit
							? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
							: limitPoint[1] < this.elementRawConfig.LimitAnalysis.DataMinLimit
								? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
								: undefined // Default color if within limits
					})),
					marker: {
						enabled: true,
						symbol: 'circle'
					},
					lineWidth: 0 // No connecting line
				};
	
				// Add the limit series to the chart series
				chartSeries.push(limitSeries);
			});
		} 
		
		else if (this.elementConfig.chartsConfig.categoryType.includes("Interval")) {
			console.log("For Interval")
			// Process interval data
			chartSeries.forEach((series, indexS) => {
				// Find the corresponding limitData by name
				const limitData = this.limitData.find(limit => limit.name === (series.name + this.limitKey));
				const colorIndex = this.elementNodes.findIndex(node => node === (series.name));
				
				if(this.elementRawConfig.GeneralConfig.ChartType== "Column"){	
					if (limitData) {
						console.log("Entered Limit Data");
						series.data = series.data.map((dataPoint, index) => {
							if (limitData.data[index] === 1) {
								return {
									y: dataPoint,
									color: dataPoint > this.elementRawConfig.LimitAnalysis.DataMaxLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
										: dataPoint < this.elementRawConfig.LimitAnalysis.DataMinLimit
											? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
											: this.chartColors[colorIndex] // Default color if within limits
								};
							} else {
								return {
									y: dataPoint,
									color:this.chartColors[colorIndex] // Default color if within limits
								};
							}
						});
					}					
				}	
				
				else if(this.elementRawConfig.GeneralConfig.ChartType== "Histogram"){
					console.log("Entering to Histogram")
					series.name= this.defineChartLabel(series.name);
					series.type="histogram";
					series.data = series.data.map((dataPoint, index) => {						
						return {
							y: dataPoint,
							color: dataPoint > this.elementRawConfig.LimitAnalysis.DataMaxLimit
								? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
								: dataPoint < this.elementRawConfig.LimitAnalysis.DataMinLimit
									? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
									: this.chartColors[colorIndex] // Default color if within limits
						};
					});
				}			
			});
		}
		else if (this.elementConfig.chartsConfig.categoryType.includes("Single")) {
						
			// Find the corresponding limitData by name		
			const colorIndex = this.elementNodes.findIndex(node => node === (chartSeries[0].name));			
			var chartSeriesI={};

			if (this.elementRawConfig.GeneralConfig.ChartType== "Gauge"||this.elementRawConfig.GeneralConfig.ChartType== "Solidgauge"){						
				chartSeriesI["data"] = chartSeries[0].data.map((dataPoint, index) => ({
					y:dataPoint,
					color: dataPoint > this.elementRawConfig.LimitAnalysis.DataMaxLimit
									? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
									: dataPoint < this.elementRawConfig.LimitAnalysis.DataMinLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
										: this.chartColors[colorIndex], // Default color if within limits,
				}));
				
				if (this.elementRawConfig.GeneralConfig.ChartType== "Gauge"){
					const limitDialColor=chartSeriesI.data[0].color==this.chartColors[colorIndex] ? "#808080":chartSeriesI.data[0].color;
					chartSeriesI["dial"]= {
						backgroundColor: limitDialColor, // Custom color for the needle
						borderColor: limitDialColor // Border color for the needle
					}	
					chartSeries[0]["dial"]=chartSeriesI.dial;			
				}
			}
			else if	(this.elementRawConfig.GeneralConfig.ChartType== "Pie"||this.elementRawConfig.GeneralConfig.ChartType== "Pyramid")
			{
				chartSeriesI["data"] = chartSeries[0].data.map((dataPoint, index) => ({
						y:dataPoint.y,
						color: dataPoint.y > this.elementRawConfig.LimitAnalysis.DataMaxLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
										: dataPoint.y < this.elementRawConfig.LimitAnalysis.DataMinLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
										: this.chartColors[this.elementNodes.findIndex(node => node === (dataPoint.name))], // Default color if within limits,
						name: this.defineChartLabel(dataPoint.name)
				}));
			}
			
			chartSeries[0].data=chartSeriesI.data;			
		}	
	
		// Update this.elementDataRT.chartData.chartSeries
		this.elementDataRT.chartData.chartSeries = chartSeries;
	}
	
	// Process data for "Simple" type
	updateSimpleData() {
		// Check if the category type is "AllData-DateTime"
		if (this.elementConfig.chartsConfig.categoryType === "AllData-DateTime") {
			// Processing simple data
			console.log("---------Updating Simple Data-----------");
	
			// Get the series from the chart reference
			const chartSeries = this.chartReference.series;
	
			// Iterate through the updatingData to find the matching series by name
			this.elementDataRT.chartData.chartSeries.forEach(updatingSeries => {
				
				// Find the corresponding series in the chart
				const chartSeriesItem = chartSeries.find(series => series.name === this.defineChartLabel(updatingSeries.name));
				const chartrange = this.chartTimeRange;
	
				if (chartSeriesItem) {
					if (this.limitAnalysisEnabled) {
						updatingSeries.data = [updatingSeries.data];
					}
	
					// Check if there are new data points to add
					if (updatingSeries.data.length > 0) {
						// Add new data points to the series
						updatingSeries.data.forEach(dataPoints => {
							// Ensure dataPoints is an array of points
							if (Array.isArray(dataPoints) && dataPoints.length > 0) {
								dataPoints.forEach(dataPoint => {
									chartSeriesItem.addPoint(dataPoint, false); // Set redraw to false
								});
							}
						});
	
						// Calculate minTime after adding new points
						const dataLength = chartSeriesItem.data.length;
						if (dataLength > 1 && chartSeriesItem.data[dataLength - 1] != null) {
							const lastPointTime = chartSeriesItem.data[dataLength - 1].x;
							const minTime = lastPointTime - chartrange;
	
							// Remove points outside the range from all series
							chartSeries.forEach(series => {
								while (series.data.length > 0 && series.data[0].x < minTime) {
									series.data[0].remove(false); // Set redraw to false
								}
							});
						}
					}
				}
			});
			
			// Redraw the chart after updates
			this.chartReference.redraw();
		}
	}
	
	// Process data for "FullRange Or SinglePoint" type
	updateFullRangeOrSinglePointData() {
		// Processing full range or single point data
		console.log("---------Updating Full Range or Single Point Data-----------");
		// Get the series from the chart reference
		const chartSeries = this.chartReference.series;
		
		//Pie and Pyramid Case
		if (this.isPiePyramid) {  //For Pie chart Data		
			
			// Update each data point in the pie chart based on the name
			const updatingData = this.elementDataRT.chartData.chartSeries[0].data;	
			const elementDataI=this.elementDataRT.chartData;
			
			//Special Categories for Singlepoint Processing
			if(this.elementRawConfig.DataProcessing.DataProcessingEnabled&&(this.elementRawConfig.DataProcessing.ProcessingType.includes("SinglePoint"))){
				
				let updatedCategories=this.chartReference.xAxis[0].categories.map((category, index) => {

					const foundIndex = elementDataI.chartSeries[0].data.findIndex(dataPoint => this.defineChartLabel(dataPoint.name) === category.name);;
					const foundcategory =elementDataI.chartCategories[foundIndex];
		
					//Updated category
					if(foundcategory!=undefined){
						return ({
							name:this.defineChartLabel(category.name),
							x:foundcategory
						})				
					}
					//Keep the same category
					else{
						return category;
					}
					
				});
				
				this.chartReference.xAxis[0].setCategories(updatedCategories, false);
			}
			
			//Updating points
			updatingData.forEach(updatingPoint => {
				const dataPoint = chartSeries[0].data.find(point => point.name === this.defineChartLabel(updatingPoint.name));
				if (dataPoint) {							
					if (this.limitAnalysisEnabled){
						dataPoint.update(updatingPoint, false); // Update the data point, no redraw yet
					}
					else{										
						dataPoint.update(updatingPoint.y, false); // Update the data point, no redraw yet
					}								
				}
			});
		}
		
		//Any other case
		else{		
			// Iterate through the updatingData to find the matching series by name
			this.elementDataRT.chartData.chartSeries.forEach(updatingSeries => {
				// Find the corresponding series in the chart
				const chartSeriesItem = chartSeries.find(series => series.name === this.defineChartLabel(updatingSeries.name));
				if (chartSeriesItem) {
					// Check if there is a new data point to add
					if (updatingSeries.data.length > 0) {
						// Update the series with the new data point
						const newValue = updatingSeries.data[0];
						const lastPoint = chartSeriesItem.data[chartSeriesItem.data.length - 1];
		
						// Update the last point with the new value or add the point if the series is empty
						if (lastPoint) {
							lastPoint.update(newValue, true); // Update last point, no redraw
							if(this.elementRawConfig.GeneralConfig.ChartType== "Gauge" &&this.limitAnalysisEnabled){
								chartSeriesItem.update({
										dial:updatingSeries.dial
								});
							} 
						} 
					}
				}
			});
			
		}
	
		// Redraw the chart after updates
		this.chartReference.redraw();
	}
	
	// Process data for "Interval" type
    updateIntervalData() {
		console.log("---------Processing Interval Data-----------");
	
		const elementDataI = this.elementDataRT.chartData;
		const intervalInfo = elementDataI.informationRT;
	
		// Check if it is necessary to go to a new interval
		const newInterval = intervalInfo.some(info => info.IntervalInfo.newInterval);
	
		// If the chart type is Histogram
		if (this.elementRawConfig.GeneralConfig.ChartType === "Histogram") {
			console.log("---------Processing Histogram Data-----------");
	
			// Get existing categories from the xAxis
			const existingCategories = this.chartReference.xAxis[0].categories;
			const newCategories = elementDataI.chartCategories;
	
			 // Merge existing and new categories, ensuring they are in the correct order
			newCategories.forEach((category) => {
				if (!existingCategories.includes(category)) {
					existingCategories.push(category);
				}
			});
	
			// Sort the categories
			existingCategories.sort((a, b) => {
				const aStart = parseFloat(a.split('-')[0]);
				const bStart = parseFloat(b.split('-')[0]);
				return aStart - bStart;
			});
			
			// Update the xAxis with the new categories
			this.chartReference.xAxis[0].setCategories(existingCategories, false);
	
			// Update series data
			elementDataI.chartSeries.forEach(updatingSeries => {
				// Find the corresponding series in the chart by name
				const chartSeriesItem = this.chartReference.series.find(series => series.name === this.defineChartLabel(updatingSeries.name));
				if (chartSeriesItem) {
					console.log("chartSeriesItem");
					console.log(chartSeriesItem);
					console.log("updatingSeries");
					console.log(updatingSeries);
					// Check and update each data point in the series
					updatingSeries.data.forEach((dataPoint, index) => {
						if (chartSeriesItem.data[index] && chartSeriesItem.data[index].y !== dataPoint) {
							chartSeriesItem.data[index].update(dataPoint, false);
						} else if (!chartSeriesItem.data[index]) {
							chartSeriesItem.addPoint(dataPoint, false);
						}
					});
				}
			});
			
			// Redraw the chart after updates
			this.chartReference.redraw(true);
		}
		
		//NON-Histogram charts
		 else {		
	
			// Update series data
			elementDataI.chartSeries.forEach(updatingSeries => {
				// Find the corresponding series in the chart by name
				const chartSeriesItem = this.chartReference.series.find(series => series.name === this.defineChartLabel(updatingSeries.name));
				if (chartSeriesItem) {
					const newValue = updatingSeries.data[0];
	
					if (newInterval) {
						// Add new data point and remove the first point						
						chartSeriesItem.addPoint(newValue, false);
						if (chartSeriesItem.data.length > 1) {
							chartSeriesItem.data[0].remove(false); // Remove the first point
						}
					} else {
						// Update the last point with the new value
						console.log("Updating New Value:");
						console.log(newValue);
						const lastPoint = chartSeriesItem.data[chartSeriesItem.data.length - 1];
						lastPoint.update(newValue, false);
					}
				}
			});
	
			if (newInterval) {
				// Add missing series with a value of 0
				this.chartReference.series.forEach(chartSeriesItem => {
					const isSeriesPresent = elementDataI.chartSeries.some(updatingSeries => this.defineChartLabel(updatingSeries.name) === chartSeriesItem.name);
					if (!isSeriesPresent) {
						chartSeriesItem.addPoint(0, false);
						if (chartSeriesItem.data.length > 1) {
							chartSeriesItem.data[0].remove(false); // Remove the first point
						}
					}
				});
			}
	
			// Update categories
			const xAxis = this.chartReference.xAxis[0];
			let updatedCategories;
	
			if (newInterval) {
				// Remove the first category and add the new one using elementDataI.chartCategories[0]
				xAxis.categories.push(elementDataI.chartCategories[0]);
				updatedCategories = xAxis.categories;
				this.chartReference.redraw(true); // Enable animation on redraw    
			} else {
				// Update the last category with the new one
				updatedCategories = xAxis.categories;
				updatedCategories[updatedCategories.length - 1] = elementDataI.chartCategories[0];
				this.chartReference.redraw(false); // Disable animation on redraw
			}
		}
	}
	
	//-----------------------------------------------//
	//----------For Single Chart Requests-----------//	
	
	// Single Chart Request
	async singleDataRequestCreator() {
	
		// Final Time
		const Final_Time = new Date();
	
		// Initial Time
		let Initial_Time = new Date(Final_Time); // Clone Final_Time
	
		switch (this.elementRawConfig.GeneralConfig.InitialRangeUnit) {
			case 's': // Seconds
				Initial_Time.setSeconds(Final_Time.getSeconds() - this.elementRawConfig.GeneralConfig.InitialRange);
			break;
			case 'min': // Minutes
				Initial_Time.setMinutes(Final_Time.getMinutes() - this.elementRawConfig.GeneralConfig.InitialRange);
			break;
			case 'h': // Hours
				Initial_Time.setHours(Final_Time.getHours() - this.elementRawConfig.GeneralConfig.InitialRange);
			break;
			case 'day': // Days
				Initial_Time.setDate(Final_Time.getDate() - this.elementRawConfig.GeneralConfig.InitialRange);
				break;
			case 'month': // Months
				Initial_Time.setMonth(Final_Time.getMonth() - this.elementRawConfig.GeneralConfig.InitialRange);
				break;
			default:
			console.error('Unsupported InitialRangeUnit:', this.elementRawConfig.GeneralConfig.InitialRangeUnit);
			break;
		}
	
		// SingledataRequest completed
		const singledataRequest = {
		  chartsNodes: [{
			chartID: this.chartID,
			chartNodes: this.elementConfig.chartNodes
		  }],
		  chartsConfig: [{
			elementType: this.elementConfig.chartsConfig.elementType,
			chartID: this.chartID,
			chartType: this.elementConfig.chartsConfig.chartType,
			dataType: this.elementConfig.chartsConfig.dataType,
			dataProcessingType: this.elementConfig.chartsConfig.dataProcessingType,
			dataReductionEnable: this.elementConfig.chartsConfig.dataReductionEnable,
			dataReductionMaxSize: this.elementConfig.chartsConfig.dataReductionMaxSize,
			dataoutOfLimitEnable: this.elementConfig.chartsConfig.dataoutOfLimitEnable,
			dataMaxLimit: this.elementConfig.chartsConfig.dataMaxLimit,
			dataMinLimit: this.elementConfig.chartsConfig.dataMinLimit,
			categoryType: this.elementConfig.chartsConfig.categoryType,
			categoryRound: this.elementConfig.chartsConfig.categoryRound,
			categorCustomValue: this.elementConfig.chartsConfig.categorCustomValue,
			categoryCustomIntervalLength: this.elementConfig.chartsConfig.categoryCustomIntervalLength,
			categoryCustomIntervalUnit: this.elementConfig.chartsConfig.categoryCustomIntervalUnit,
			categoryTimeOffset:this.elementConfig.chartsConfig.categoryTimeOffset,
			singleDataRequest: true,
			specialParameters:this.specialParameters
		  }],
		  updateRequest: [{
			OperationMode: "Hist",
			initialTime: Initial_Time,
			finalTime: Final_Time,
			customFilterType: "",
			cacheConfig:{
				CacheEnabled:"false",
				CacheIntervalSize:0,
				CacheMaxSize:0},
			chartID: this.chartID
		  }]
		};
	
		return singledataRequest;
	}	
	
	//Single Data Calling
	async singleelementDataCreator() {
		return new Promise((resolve, reject) => {			
			//Custom Request
			webMI.data.customRequest("GET", "Advanced_Dashboard_Data_Creator?DataRequest="+JSON.stringify(this.singleDataRequest)+"&format=binary", "responseType=string", function(e){
				try {  
					console.log("----------Single Request Answered--------");
					
					//Read dashboardData
					let dashboardData=e;
					
					//Check if its valid
					if (!dashboardData || !dashboardData.chartsData || !Array.isArray(dashboardData.chartsData) || dashboardData.chartsData.length === 0) {
						throw new Error("Invalid or empty chartsData array");
					}
				
					//Adapt Structure to single Element Data
					const elementDataI = {
						chartData: {
							chartID: dashboardData.chartsData[0].chartID,
							chartSeries: dashboardData.chartsData[0].chartSeries,
							chartCategories: dashboardData.chartsData[0].chartCategories
						},
						Errors: dashboardData.Errors
					};
					resolve (elementDataI);
				} 
				catch (error) {
					console.log("Error found with custom request")
					console.log(error);
				}
			});
		});
	}
	
	//-----------------------------------------------//
	//-------------Auxiliary Functions--------------//
	
	 // Creates Chart Colors
    createChartColors() {
        // Ensure Highcharts.color method is available for color manipulation
        if (typeof Highcharts === 'undefined' || typeof Highcharts.color !== 'function') {
            throw new Error("Highcharts library or Highcharts.color method is not available.");
        }
		
		const baseColor = this.elementRawConfig.Appearance.ColorSeriesPalette;
        const dataLength = this.isPiePyramid ? this.elementData.chartData.chartSeries[0].data.length : this.elementData.chartData.chartSeries.length;
        const colors = [];        
        
        //Color from Color Pallete
        if ( this.elementRawConfig.Appearance.ColorSeriesType=="Color-Pallete") {
			for (let i = 0; i < dataLength; i++) {
				// Calculate color variation
				const variation = 0.4 * i;
				const newColor = Highcharts.color(baseColor).brighten(variation).get();
				colors.push(newColor);
			}        
        }
        
        
        else if( this.elementRawConfig.Appearance.ColorSeriesType=="Color-Custom") {
        
			// Data Source Text
			if (this.elementRawConfig.GeneralConfig.SeriesSource === "Text") {		
				//Take source from parameters
				this.elementRawConfig.Series.forEach(function(seriesItem) {
					if (seriesItem.SeriesNode) { // Check if SeriesNode is not undefined
						colors.push(seriesItem.SeriesColor);
					}
				});
			}
			
			// Data Source Enum
			else if (this.elementRawConfig.GeneralConfig.SeriesSource === "EnumList") {
				for (const key in this.elementRawConfig.EnumList.EnumList) {
					if (this.elementRawConfig.EnumList.EnumList.hasOwnProperty(key)) {
						const enumItem = this.elementRawConfig.EnumList.EnumList[key];
						if (enumItem.Color) { // Check if Node is not undefined
							colors.push(enumItem.Color);
						}
					}
				}
			}
        
        }
        return colors;
    }
    
    defineBackgroundColor(){
		//If transparen Enabled
		if (this.elementRawConfig.Appearance.ColorBackgroundTranspartentEnable=="true"||this.elementRawConfig.Appearance.ColorBackground.length<=0){
			return 'transparent';
	    }
	    else{
			return this.elementRawConfig.Appearance.ColorBackground;
	    }
    
    }
    
    defineChartLabel(SeriesName) {
		//Series name comming from Dashboard Data Creator
		if (SeriesName.endsWith(this.limitKey)) { //Series for Limits

			const index_Limit = this.elementNodes.findIndex(node => {
				return node === SeriesName.slice(0, SeriesName.length-this.limitKey.length);
			}); 

			// Return the corresponding label from this.chartLabels or the SeriesName if the label is empty
			if (index_Limit !== -1) {

				const label = this.chartLabels[index_Limit] !== '' ? this.chartLabels[index_Limit]+this.limitKey: '';
				return label !== '' ? label : SeriesName.split('.').pop();
			} else {
				return SeriesName; // return SeriesName if index is not found
			}
			
		}
		
		else {
		
			
			// Find the index of the element in this.elementNodes where SeriesName is the last part
			const index = this.tableColumnIndex;
					
			// Return the corresponding label from this.chartLabels or the SeriesName if the label is empty
			if (index !== -1) {
				const label = this.chartLabels[index];
				return label !== '' ? label : SeriesName.split('.').pop();
			} else {
				return SeriesName; // return SeriesName if index is not found
			}
        }
    }
	
	dataLabelFormatter(rawLabel,columnType) {

		const labeTimelType = this.elementRawConfig.Appearance.DatalabelTimeType;
		const customFormat = this.elementRawConfig.Appearance.DatalabelCustomTimeFormat;
		const numberDecimals = this.elementRawConfig.Appearance.DatalabelNumberDecimals;

		
		if(columnType=="Value"){
			if (rawLabel!=this.elementRawConfig.DataProcessing.ReplacementText){
				// Number formatting logic when handling 'Value'
				if (rawLabel >= 1000000) {
					return (rawLabel / 1000000).toFixed(numberDecimals) + 'M '; // millions
				} else if (rawLabel >= 1000) {
					return (rawLabel / 1000).toFixed(numberDecimals) + 'k '; // thousands
				} else {
					return rawLabel.toFixed(numberDecimals); // less than 1000
				}
			}
			else{
				return this.elementRawConfig.DataProcessing.ReplacementText;
			}
		} 
		else if (columnType === "Time") {
			const date = new Date(rawLabel);
			// Return date in the format "DD/MM/YYYY hh:mm:ss"
			const day = date.getDate().toString().padStart(2, '0');
			const month = (date.getMonth() + 1).toString().padStart(2, '0');
			const year = date.getFullYear();
			const hours = date.getHours().toString().padStart(2, '0');
			const minutes = date.getMinutes().toString().padStart(2, '0');
			const seconds = date.getSeconds().toString().padStart(2, '0');
			const milliseconds = date.getMilliseconds().toString();
			
			
			if (labeTimelType === "Time-Dynamic") {		
				return `${day}/${month}/${year} ${hours}:${minutes}:${seconds}.${milliseconds}`;
			} 
			else if (labeTimelType === "Time-Custom") {
				let formattedTime = customFormat;
				
				// Replace the placeholders in customFormat with actual values
				if (customFormat.includes('YYYY')) {
					formattedTime = formattedTime.replace('YYYY', year.toString());
				}
				if (customFormat.includes('MM')) {
					formattedTime = formattedTime.replace('MM', month.toString());
				}
				if (customFormat.includes('DD')) {
					formattedTime = formattedTime.replace('DD', day.toString());
				}
				if (customFormat.includes('hh')) {
					formattedTime = formattedTime.replace('hh', hours.toString());
				}
				if (customFormat.includes('mm')) {
					formattedTime = formattedTime.replace('mm', minutes.toString());
				}
				if (customFormat.includes('ss')) {
					formattedTime = formattedTime.replace('ss', seconds.toString());
				}
	
				return formattedTime;
			}
		}
		 else {
			return rawLabel; // Default case: return raw label without formatting
		}	
	} 
}

]]></script>
</svg>
