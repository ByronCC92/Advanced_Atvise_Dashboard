<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<svg height="48.75" version="1.2" width="1361" xmlns="http://www.w3.org/2000/svg" xmlns:atv="http://webmi.atvise.com/2007/svgext" xmlns:xlink="http://www.w3.org/1999/xlink">
 <defs/>
 <metadata>
  <atv:parameter behavior="optional" defaultvalue="" desc="DashboardID" group="General Configuration" name="DashboardID" valuetype="string"/>
  <atv:parameter behavior="optional" config="CustomRange;CurrentHour;LastHour;Last_8Hours;FirstShift;SecondShift;ThirdShift;Today;Last_7Days;Yesterday;CurrentWeek;LastWeek;Last_2Weeks;CurrentMonth;LastMonth;Last_6Months;CurrentYear" defaultvalue="CustomRange" desc="Initial Range Method" group="General Configuration" name="InitialRangeMethod" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="2" desc="Initial Range" group="General Configuration" name="InitialRange" valuetype="number"/>
  <atv:parameter behavior="optional" config="s;min;h;day;month" defaultvalue="min" desc="Initial Range Unit" group="General Configuration" name="InitialRangeUnit" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="true" desc="Real Time Enabled" group="General Configuration" name="RealTimeEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="1000" desc="RealTime Update Time (ms)" group="General Configuration" name="RealTimeUpdateTime" valuetype="number"/>
  <atv:parameter behavior="optional" config="true;false" defaultvalue="true" desc="Cache Enabled" group="Cache Configuration" name="CacheEnabled" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="0" desc="Cache Max Size" group="Cache Configuration" name="CacheMaxSize" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="0" desc="Cache Interval Size" group="Cache Configuration" name="CacheIntervalSize" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="Custom Filter Active" group="Custom Filter" name="CustomFilterActive" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Node Reference" group="Custom Filter" name="NodeReference" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color Active" group="Appearance" name="ColorActive" substitute="$ColorActive$" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color Inactive" group="Appearance" name="ColorInactive" substitute="$ColorInactive$" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="12" desc="Font Size Menu" group="Appearance" name="FontSizeMenu" substitute="$FontSizeMenu$" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="10" desc="Font Size Date Pickers" group="Appearance" name="FontSizeDatePickers" valuetype="number"/>
  <atv:gridconfig enabled="true" gridstyle="lines" height="20" width="20"/>
  <atv:snapconfig enabled="true" height="10" width="10"/>
 </metadata>
 <g atv:refpx="45" atv:refpy="20" id="Real_Time" transform="matrix(1,0,0,1,0,-12)">
  <text atv:refpx="33.468" atv:refpy="32" fill="$ColorIactive$" font-family="Arial" font-size="$FontSizeMenu$" id="Text_Realtime" x="7.5" y="36.5">Real Time</text>
  <rect atv:refpx="48.273" atv:refpy="32" fill="#68a361" fill-opacity="0" height="40" id="Click_area_Realtime" stroke="none" stroke-width="2" width="90" x="0" y="12"/>
 </g>
 <g atv:refpx="185" atv:refpy="20" id="id_12" transform="matrix(1,0,0,1,0,-12)">
  <text atv:refpx="159.05" atv:refpy="32" fill="$ColorIactive$" font-family="Arial" font-size="$FontSizeMenu$" id="Text_Historic" x="140.5" y="36.5">Historic</text>
  <rect atv:refpx="219" atv:refpy="32" fill="#68a361" fill-opacity="0" height="40" id="Click_area_Historic" stroke="none" stroke-width="2" width="110" x="130" y="12"/>
 </g>
 <line atv:refpx="685" atv:refpy="46.75" id="id_4" stroke="$ColorInactive$" stroke-width="2" x1="10" x2="1360" y1="46.75" y2="46.75"/>
 <g atv:refpx="815.5" atv:refpy="20" id="Date_Element">
  <g atv:refpx="414" atv:refpy="20" id="id_14" transform="matrix(1,0,0,1,309,0)">
   <svg atv:refpx="449.888" atv:refpy="44.996" height="30" id="id_2" transform="matrix(1.25,0,0,1.1667,0,0)" width="160" x="271.2" xlink:href="SYSTEM.LIBRARY.ATVISE.OBJECTDISPLAYS.Advanced.picker_date" y="2.142">
    <atv:argument name="fontSize" prefix="FontSizeDatePickers"/>
    <atv:argument name="name" prefix="DashboardID" value="Initial_Date"/>
    <atv:overwrite id="button_stroke" transform="matrix(0.8,0,0,0.8571,0,0)" x="175.5" y="7.5"/>
    <atv:overwrite id="id_1" transform="matrix(0.72,0,0,0.7714,0,0)" x="196.111" y="9.445"/>
    <atv:overwrite id="button_bg" transform="matrix(0.8,0,0,0.8571,0,0)" x="175.5" y="7.5"/>
    <atv:overwrite id="datepicker_label" transform="matrix(0.969,0,0,0.8571,-14.1126,0)" x="150" y="22.75"/>
    <atv:overwrite height="31.001" id="focus_frame" transform="matrix(0.8,0,0,0.8571,0,0)" width="196"/>
    <atv:overwrite height="27.001" id="blinking_frame" transform="matrix(0.8,0,0,0.8571,0,0)" width="168"/>
    <atv:overwrite height="27.001" id="input_bg" transform="matrix(0.8,0,0,0.8571,0,0)" width="168"/>
    <atv:overwrite height="33.001" id="id_0" transform="matrix(0.8,0,0,0.8571,0,0)" width="198"/>
    <atv:overwrite height="35.001" id="id_2" transform="matrix(0.8,0,0,0.8571,0,0)" width="200"/>
   </svg>
   <text atv:refpx="240.733" atv:refpy="20" fill="$ColorIactive$" font-family="Arial" font-size="$FontSizeMenu$" id="id_3" x="215.5" y="24.5">Intial Date</text>
  </g>
  <g atv:refpx="793" atv:refpy="20" id="id_10" transform="matrix(1,0,0,1,688,52.5)">
   <svg atv:refpx="452.799" atv:refpy="-12.505" height="30" id="id_15" transform="matrix(1.25,0,0,1.1667,0,0)" width="160" x="271.2" xlink:href="SYSTEM.LIBRARY.ATVISE.OBJECTDISPLAYS.Advanced.picker_date" y="-42.857">
    <atv:argument name="fontSize" prefix="FontSizeDatePickers"/>
    <atv:argument name="name" prefix="DashboardID" value="Final_Date"/>
    <atv:overwrite id="button_stroke" transform="matrix(0.8,0,0,0.8571,0,0)" x="175.5" y="7.5"/>
    <atv:overwrite id="id_1" transform="matrix(0.72,0,0,0.7714,0,0)" x="196.111" y="9.445"/>
    <atv:overwrite id="button_bg" transform="matrix(0.8,0,0,0.8571,0,0)" x="175.5" y="7.5"/>
    <atv:overwrite id="datepicker_label" transform="matrix(0.969,0,0,0.8571,-14.1126,0)" x="150" y="22.75"/>
    <atv:overwrite height="31" id="focus_frame" transform="matrix(0.8,0,0,0.8571,0,0)" width="196"/>
    <atv:overwrite height="27" id="blinking_frame" transform="matrix(0.8,0,0,0.8571,0,0)" width="168"/>
    <atv:overwrite height="27" id="input_bg" transform="matrix(0.8,0,0,0.8571,0,0)" width="168"/>
    <atv:overwrite height="33" id="id_0" transform="matrix(0.8,0,0,0.8571,0,0)" width="198"/>
    <atv:overwrite height="35" id="id_2" transform="matrix(0.8,0,0,0.8571,0,0)" width="200"/>
   </svg>
   <text atv:refpx="240.763" atv:refpy="-32.499" fill="$ColorIactive$" font-family="Arial" font-size="$FontSizeMenu$" id="id_16" x="215.5" y="-27.999">Final Date</text>
  </g>
  <g atv:refpx="1084" atv:refpy="20" id="id_13" transform="matrix(1,0,0,1,231,-10)">
   <text atv:refpx="1043.972" atv:refpy="30" fill="$ColorIactive$" font-family="Arial" font-size="$FontSizeMenu$" id="Text_Confirm" x="1024.5" y="34.5">Confirm</text>
   <rect atv:refpx="1109" atv:refpy="30" fill="#68a361" fill-opacity="0" height="40" id="Click_area_Confirm" stroke="none" stroke-width="2" width="110" x="1020" y="10"/>
  </g>
  <svg atv:refpx="350" atv:refpy="20" height="30" id="Initial_Range_Method" width="160" x="270" xlink:href="SYSTEM.LIBRARY.ATVISE.OBJECTDISPLAYS.Advanced.combobox" y="5">
   <atv:argument name="text1" value="T{Test 1}"/>
   <atv:argument name="text1value" value="0"/>
   <atv:argument name="text2" value="T{Test 2}"/>
   <atv:argument name="text2value" value="1"/>
   <atv:argument name="text3" value="T{Test 3}"/>
   <atv:argument name="text3value" value="2"/>
  </svg>
 </g>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href=""/>
 <script atv:desc="" atv:name="" type="text/ecmascript"><![CDATA[//------Initialize Variables-----------//

//------Parameters
const dashboardMenuRawConfig = {
    GeneralConfig: {
        DashboardID: webMI.query["DashboardID"],
        InitialRangeMethod: webMI.query["InitialRangeMethod"],
        InitialRange: webMI.query["InitialRange"],  
        InitialRangeUnit: webMI.query["InitialRangeUnit"],
        RealTimeEnabled:webMI.query["RealTimeEnabled"],
        RealTimeUpdateTime:webMI.query["RealTimeUpdateTime"]
    },
    CacheConfig:{
        CacheEnabled: webMI.query["CacheEnabled"],
        CacheMaxSize: webMI.query["CacheMaxSize"],
        CacheIntervalSize: webMI.query["CacheIntervalSize"]
    },    
    CustomFilter: {
        CustomFilterActive: webMI.query["CustomFilterActive"],  
        NodeReference: webMI.query["NodeReference"] 
    },
    Appearance: {
        ColorActive: webMI.query["ColorActive"],  
        ColorInactive: webMI.query["ColorInactive"],  
        FontSizeMenu: webMI.query["FontSizeMenu"],  
        FontSizeDatePickers: webMI.query["FontSizeDatePickers"]  
    }
};

//uI Parameters
const uIElements= {
    Click_Area: ["Click_area_Realtime","Click_area_Historic"],
    Texts: ["Text_Realtime","Text_Historic"],
    Combobox: "Initial_Range_Method",
    Click_area_Confirm: "Click_area_Confirm",
    Text_Confirm: "Text_Confirm"    
};

//Initial Range Methods
const initialRangeMethods = [
  { text: 'CustomRange', value: 0 },
  { text: 'CurrentHour', value: 1 },
  { text: 'LastHour', value: 2 },
  { text: 'Last_8Hours', value: 3 },
  { text: 'FirstShift', value: 4 },
  { text: 'SecondShift', value: 5 },
  { text: 'ThirdShift', value: 6 },
  { text: 'Today', value: 7 },
  { text: 'Last_7Days', value: 8 },
  { text: 'Yesterday', value: 9 },
  { text: 'CurrentWeek', value: 10 },
  { text: 'LastWeek', value: 11 },
  { text: 'Last_2Weeks', value: 12 },
  { text: 'CurrentMonth', value: 13 },
  { text: 'LastMonth', value: 14 },
  { text: 'Last_6Months', value: 15 },
  { text: 'CurrentYear', value: 16 }
];


//Key Mapping for data transfer
const keyMapping = {
    "chartsConfig": "cChCfg",
    "categorCustomValue": "cCV",
    "categoryCustomIntervalLength": "cCIL",
    "categoryCustomIntervalUnit": "cCIU",
    "categoryRound": "cRnd",
    "categoryTimeOffset": "cTO",
    "categoryType": "cCatTyp",
    "chartID": "cID",
    "chartType": "cTyp",
    "dataMaxLimit": "dMxL",
    "dataMinLimit": "dMnL",
    "dataProcessingType": "dPrc",
    "dataReductionEnable": "dREn",
    "dataReductionMaxSize": "dRMx",
    "dataType": "dTyp",
    "dataoutOfLimitEnable": "dOLE",
    "singleDataRequest": "sDR",
    "specialParameters": "sPar",
    "OEECompleteRangeAnalisis": "OEECRA",
    "OEEProductionSpeed": "OEESP",
    "chartsNodes": "cChNds",
    "chartNodes": "cNds",
    "updateRequest": "uReq",
    "OperationMode": "opMd",
    "cacheConfig": "caCfg",
    "CacheEnabled": "cEna",
    "CacheIntervalSize": "cISz",
    "CacheMaxSize": "cMSz",
    "customFilterType": "cFT",
    "finalTime": "fTme",
    "initialTime": "iTme",
    "informationRT": "iRT",
    "AllDataRequired": "ADR",
    "IntervalInfo": "iInf",
    "end": "end",
    "intervalLength": "iLen",
    "newInterval": "nInt",
    "start": "strt",
    "LastDataPointProcessed": "lDPP",
    "LastDataPointRT": "lDPRT",
    "Value": "Val",
    "status": "sts",
    "timestamps": "tStmp",
    "LastDataPointRaw": "lDPR",
    "Node": "Nd",
    "OEEInfo": "OEEI",
    "ReduceInfo": "RInf",
    "reductionStepSize": "rSSz",
    "reductioniterationsBeforeNextStepRT": "rINS"
};


//------Initial Conditions-----------//
webMI.addOnload(function() {

	//Create dashboard Manager
	const dashboardManager1= new dashboardManager();
	
	//Create UI Handler
	const userInterfaceHandler1 = new userInterfaceHandler(dashboardMenuRawConfig,uIElements,initialRangeMethods);	
	
	//Initialize UI Handler
	userInterfaceHandler1.initialize(dashboardManager1);
    
});


//------------------------------------------//
//------------UI Handler Class-------------//

class userInterfaceHandler {

    // Attributes
	uIElements;
    currentConfig; // To store the current configuration state
    updateRequest; // To handle update requests

    // Constructor
    constructor(dashboardMenuRawConfig,uIElements,initialRangeMethods) {
		this.dashboardMenuRawConfig=dashboardMenuRawConfig;
		this.RealTime=dashboardMenuRawConfig.GeneralConfig.RealTimeEnabled=="true" ? true: false;
		this.FirstTime=true;
		this.uIElements=uIElements;
		this.InitialRangeMethods=initialRangeMethods;
		this.InitialRangeMethod=dashboardMenuRawConfig.GeneralConfig.InitialRangeMethod;
		this.InitialRangeMethodOriginal=this.InitialRangeMethod;
		this.InitialRange=dashboardMenuRawConfig.GeneralConfig.InitialRange;
		this.InitialRangeUnit=dashboardMenuRawConfig.GeneralConfig.InitialRangeUnit;
		this.CacheConfig=dashboardMenuRawConfig.CacheConfig;
		this.DashboardID=dashboardMenuRawConfig.GeneralConfig.DashboardID;
		this.IgnoreDateChanges=false;
		this.InitialTime;
		this.FinalTime;		
        this.currentConfig;        
        this.updateRequest; 
        this.dashboardManager;
    }
    
    // Initialize
    async initialize(dashboardManager) {       
       
	   //Store 
	   this.dashboardManager=dashboardManager;      
       
       //Calculate time
       await this.calculateTime();
       
       //Update Date Picker
       this.updateDatePicker();
       
	   //Initialize Triggers
	   this.addListeners();       
      
       //Real Time Trigger
	   this.changeMode(this.RealTime);
       
       //Set Active RT
	   this.setactive(this.dashboardMenuRawConfig.GeneralConfig.RealTimeEnabled=="true" ? 0: 1);   	   
	   
	   //Create First Update Request
	   this.createUpdateRequest();	   
	   
	   //Init Dashboard Manager
	   dashboardManager.initialize(this.updateRequest,false,this.dashboardMenuRawConfig.GeneralConfig.RealTimeEnabled,this.dashboardMenuRawConfig.GeneralConfig.RealTimeUpdateTime);    
       
    }


    // Add Listeners
    async addListeners() {
       
       //Listener Real Time
		webMI.addEvent(this.uIElements.Click_Area[0], "click", (e) => {
			
			if (this.dashboardMenuRawConfig.GeneralConfig.RealTimeEnabled=="true")				{
				//Back to Original Initial Range
				this.InitialRangeMethod=this.InitialRangeMethodOriginal;
							
				//Real Time Trigger
				this.changeMode(true);
				
				//Change Colors
				this.setactive(0);
			}
		});
		
		//Listener Historic
		webMI.addEvent(this.uIElements.Click_Area[1], "click", (e) => {
			
			//Real Time Trigger
			this.changeMode(false);
			
			//Calculate again time
			this.calculateTime();  

			//Update Date Picker
			this.updateDatePicker();
			
			//Change colors
			this.setactive(1);
		});
		
		//Listener Confirm
		webMI.addEvent(this.uIElements.Click_area_Confirm, "click", (e) => {
			
			//Toggle Color			
			this.toggleColor(this.uIElements.Text_Confirm);			
			
			//Create Update Request				
			this.createUpdateRequest();
			
			//Send Update Request
			this.sendUpdateRequests();			
			
		});
		
		//Listener for combobox values	
		webMI.trigger.connect("valuechanged", (e) => {
			
			//In Hist Mode			
			if (this.RealTime==false){
				
				//Update InitialRangeMethod
				this.InitialRangeMethod=(this.InitialRangeMethods.find(element => element.value === e.value)).text;
				
				//Calculate time
			    this.calculateTime();			   
			   
			    //Update Date Picker
			    this.IgnoreDateChanges=true;
			    this.updateDatePicker();	
			    this.IgnoreDateChanges=false;	
			    		
			}
			
		},this.uIElements.Combobox);
		
		
		
		//Listener for the Initial Time picker
		webMI.trigger.connect("com.atvise.datepicker_"+this.DashboardID+"Initial_Date", (e) => {
			
			//In Hist Mode			
			if (this.RealTime==false && !this.IgnoreDateChanges){
				//Update Initial Time
				this.InitialTime=(new Date(e.value));	
						
			}
		});
				
		
		//Listener for the Final Time picker
		webMI.trigger.connect("com.atvise.datepicker_"+this.DashboardID+"Final_Date", (e) => {
			
			if (this.RealTime==false && !this.IgnoreDateChanges){
				
				//Update Initial Time
				this.FinalTime=(new Date(e.value));
			}
		});       
    }

    // Method create Update Rquest
    createUpdateRequest() {
       this.updateRequest = {
            OperationMode: "Hist",
            initialTime: this.InitialTime,
            finalTime: this.FinalTime,
            customFilterType: "",
            cacheConfig: this.CacheConfig
        };
    }

    // Method to send Update Rquest
    sendUpdateRequests() {
        
        //Send Update Reguest Dashboard Manager
	   this.dashboardManager.updateRequestHandler(this.updateRequest, this.RealTime);  
	   
    }
    
    //Setactive element
    setactive(ID) {     
		
		//Set active only the current icon
		for (var i=0; i<this.uIElements.Click_Area.length; i++){
			if (i==ID){
				webMI.gfx.setFill(this.uIElements.Texts[i], dashboardMenuRawConfig.Appearance.ColorActive);
			}
			else
			{
				webMI.gfx.setFill(this.uIElements.Texts[i],dashboardMenuRawConfig.Appearance.ColorInactive);
			}
		}

    }
    
    //Toggle  Color
    toggleColor(ID) { 
    
		//First Active Color		
		webMI.gfx.setFill(ID, dashboardMenuRawConfig.Appearance.ColorActive);
		
		//Second Inactive Color
		setTimeout(async (e) => {
			webMI.gfx.setFill(ID,dashboardMenuRawConfig.Appearance.ColorInactive);
		},1000);
		
    }
    
	//Setactive element
    updateDatePicker() {

		//Fire Picker Updater
        webMI.trigger.fire("com.atvise.datepicker_"+this.DashboardID+"Initial_Date", new Date(this.InitialTime).getTime()); 
		webMI.trigger.fire("com.atvise.datepicker_"+this.DashboardID+"Final_Date", new Date(this.FinalTime).getTime());
    }
    
    //Fill Combobox
    fillCombobox(comboxID, comboboxElements) {
		
		//Excecute
        webMI.trigger.fire("setItems", comboboxElements, comboxID);
        
        //Set Default Item
        webMI.trigger.fire("setSelectedItem", this.InitialRangeMethod , comboxID);
        
    }

    // Method to log Request
    requestLogger() {
 
    }
    
    //General Calculation Initial Time Final Time    
    calculateTime() {
    
		// Final Time		
		let FinalTimeI= new Date();
	
		// Start
		let InitialTimeI = new Date(FinalTimeI); // Clone Final_Time
		
		//Auxiliary
		let dayOfWeek=FinalTimeI.getDay();
			
		
		switch (this.InitialRangeMethod) {
			case 'CustomRange':
				//Update FinalTime
				this.FinalTime = FinalTimeI;
				//Calculate InitialTime
				InitialTimeI=this.calculateTimeCustomRange()
				break;
			case 'CurrentHour':
				InitialTimeI.setMinutes(0, 0, 0); // Set to the beginning of the current hour
				break;
			case 'LastHour':
				//Update FinalTime
				FinalTimeI.setMinutes(0, 0, 0);
				InitialTimeI.setHours((new Date(FinalTimeI)).getHours() - 1);
				InitialTimeI.setMinutes(0, 0, 0); // Set to the beginning of the last hour
				break;
			case 'Last_8Hours':
				FinalTimeI.setMinutes(0, 0, 0);
				InitialTimeI.setHours((new Date(FinalTimeI)).getHours() - 8);
				InitialTimeI.setMinutes(0, 0, 0);
				break;
			case 'FirstShift': // Assuming 8-hour shifts, 00:00 - 08:00
				FinalTimeI.setHours(8, 0, 0, 0);
				InitialTimeI.setHours(0, 0, 0, 0); // Start of the day
				break;
			case 'SecondShift': // 08:00 - 16:00
				FinalTimeI.setHours(16, 0, 0, 0);
				InitialTimeI.setHours(8, 0, 0, 0);
				break;
			case 'ThirdShift': // 16:00 - 24:00
				FinalTimeI.setHours(24, 0, 0, 0);
				InitialTimeI.setHours(16, 0, 0, 0);
				break;
			case 'Today':
				InitialTimeI.setHours(0, 0, 0, 0); // Start of today
				break;
			case 'Last_7Days':
				InitialTimeI.setDate((new Date(FinalTimeI)).getDate() - 7);
				break;
			case 'Yesterday':
				FinalTimeI.setHours(0, 0, 0, 0);
				InitialTimeI.setDate((new Date(FinalTimeI)).getDate() - 1);
				InitialTimeI.setHours(0, 0, 0, 0); // Start of yesterday
				break;
			case 'CurrentWeek':
				InitialTimeI.setDate((new Date(FinalTimeI)).getDate() - (new Date(FinalTimeI)).getDay());
				InitialTimeI.setHours(0, 0, 0, 0); // Start of the current week
				break;
			case 'LastWeek':			
				
				FinalTimeI.setDate(FinalTimeI.getDate() - dayOfWeek);				
				FinalTimeI.setHours(23, 59, 59, 999);
				
				InitialTimeI.setDate((new Date(FinalTimeI)).getDate() - (new Date(FinalTimeI)).getDay() - 7);
				InitialTimeI.setHours(0, 0, 0, 0); // Start of the last week
				break;
			case 'Last_2Weeks':
				FinalTimeI.setDate(FinalTimeI.getDate() - dayOfWeek - 7); // Shift to the end of the previous complete week
				FinalTimeI.setHours(23, 59, 59, 999);
				
				InitialTimeI = new Date(FinalTimeI); // Duplicate FinalTimeI to preserve time part
				InitialTimeI.setDate(InitialTimeI.getDate() - 14); // Move back two weeks
				InitialTimeI.setHours(0, 0, 0, 0); // Set to the start of the day
			
				break;			
			case 'CurrentMonth':
				InitialTimeI.setDate(1);
				InitialTimeI.setHours(0, 0, 0, 0); // Start of the current month
				FinalTimeI.setMonth(FinalTimeI.getMonth() + 1, 0); // Set to the last day of the current month
				FinalTimeI.setHours(23, 59, 59, 999); // End of the last day of the month
				break;
			case 'LastMonth':
				InitialTimeI.setMonth(FinalTimeI.getMonth() - 1, 1); // Set to the first day of the last month
				InitialTimeI.setHours(0, 0, 0, 0);
				FinalTimeI.setMonth(FinalTimeI.getMonth(), 0); // Set to the last day of the last month
				FinalTimeI.setHours(23, 59, 59, 999); // End of the last day of the month
				break;
			case 'Last_6Months':
				InitialTimeI.setMonth(FinalTimeI.getMonth() - 6, 1); // Six months ago from the first day of that month
				InitialTimeI.setHours(0, 0, 0, 0);
				// Optionally, set FinalTimeI to the end of the last full month
				FinalTimeI.setDate(0); // Last day of the previous month
				FinalTimeI.setHours(23, 59, 59, 999); // End of the last day of the month
				break;
			case 'CurrentYear':
				InitialTimeI.setFullYear(FinalTimeI.getFullYear(), 0, 1); // Start of the current year
				InitialTimeI.setHours(0, 0, 0, 0);
				// Optionally, set FinalTimeI to the current time or end of the year
				FinalTimeI.setFullYear(FinalTimeI.getFullYear(), 11, 31); // Last day of the year
				FinalTimeI.setHours(23, 59, 59, 999);
				break;
			default:
				console.error('Unsupported InitialRangeMethod:', this.InitialRangeMethod);
				break;
		}
		
		this.FinalTime = new Date(FinalTimeI);
		this.InitialTime = new Date(InitialTimeI);
	}
    
    //Calculate Initial and Final Time for Custom Range
    calculateTimeCustomRange(){
    
		// Start
		var InitialTimeI = new Date(this.FinalTime); // Clone Final_Time
	
		switch (this.InitialRangeUnit) {
			case 's': // Seconds
				InitialTimeI.setSeconds(this.FinalTime.getSeconds() - this.InitialRange);
			break;
			case 'min': // Minutes
				InitialTimeI.setMinutes(this.FinalTime.getMinutes() - this.InitialRange);
			break;
			case 'h': // Hours
				InitialTimeI.setHours(this.FinalTime.getHours() - this.InitialRange);
			break;
			case 'day': // Days
				InitialTimeI.setDate(this.FinalTime.getDate() - this.InitialRange);
			break;
			case 'month': // Months
				InitialTimeI.setMonth(this.FinalTime.getMonth() - this.InitialRange);
			break;
			default:
				console.error('Unsupported InitialRangeUnit:', this.InitialRange);
			break;
		}
		
		return InitialTimeI;	
    }
    
    // Method to change from realTime to Historic
    changeMode(RTactive) {
		
		const RTactiveI=dashboardMenuRawConfig.GeneralConfig.RealTimeEnabled=="true" ? RTactive:false;		
		
		//Set RT Active
		this.RealTime=RTactiveI;    	
    	this.dashboardManager.RealTime=RTactiveI; 

		//Show/hide
		webMI.gfx.setVisible("Date_Element", !RTactiveI);
		
		//Fill Combobox
		if (!RTactiveI) {
			this.fillCombobox(this.uIElements.Combobox, this.InitialRangeMethods);
		}	
		//Recalculate Real Time
		else if(RTactiveI&&!this.FirstTime){
			console.log("Updating to RT")
			//Update Evaluation time
			this.calculateTime();
			
			//Create Update Request				
			this.createUpdateRequest();
			
			//Send Update Request
			this.sendUpdateRequests();
				
		}
		
		//Send command
        webMI.trigger.fire("RealTime_"+this.DashboardID, RTactiveI); 
        
        //No longer First time
        if(this.FirstTime){
			this.FirstTime=false;    
        }   
    }
    
    
}

//------------------------------------------//
//------------Dashboard Manager Class-------------//

class dashboardManager {
    // Attributes
    ElementsConfig;
    DataRequest;
    UpdateRequest;
    DashboardData;

    // Constructor
    constructor() {
		this.ElementsConfig=new Array();
        this.DataRequest;
        this.DataRequestRT;
        this.UniqueNodes;
        this.NodesRT=new Array();
        this.UpdateRequest;
        this.ChartTimeRange;
        this.RealTimeEnabled;
        this.RealTimeUpdateTime;
        this.DashboardData;
        this.DashboardDataRTProcessed;
        this.DashboardDataRTDirect;
        this.DashboardDataRTFinal;
        this.DashboardDataBase;
        this.RealTime;
        this.DataRTDistributed=true;
    }
    
    // Initialize
    async initialize(updateRequest,operationMode,RealTimeEnabled,RealTimeUpdateTime) {
		
		 //Define Operation Mode 
		 this.RealTime=operationMode;
		 
		 //Determine if RT is enabled
		 this.RealTimeEnabled=RealTimeEnabled;
		 
		 //Define RT Updatetime
		 this.RealTimeUpdateTime=RealTimeUpdateTime;
		 
		 //Set First Update Request
		 this.UpdateRequest=updateRequest;
		 console.log("------------First Update Request---------");
		 console.log(this.UpdateRequest);
		 
		 //Define chartTimeRange
		 this.ChartTimeRange=(this.UpdateRequest.finalTime-this.UpdateRequest.initialTime);		 
		 
		 //Add Listeners
		 this.addInitialListeners();    
		 
		 //Dashboard Ready
		 webMI.trigger.fire("Dashboard_Ready_"+this.DashboardID, true);
		 
		 //Wait for Elements for register
		 setTimeout(async (e) => {
			
			//Make sure there are Elements
			 if (this.ElementsConfig.length>=1){
				 //Create Data Request
				 this.createDataRequest();
				 console.log("------------Data Request Ready---------");
				 console.log(this.DataRequest);
				 
				 
				 //Create Dashboard Data
				 this.DashboardData = await this.dashboardDataCreator();
				 this.DashboardDataBase=this.DashboardData;
				 console.log("-----------Dashboard Data--------------");
				 console.log(this.DashboardData);
				 
				 //Distribuite Dashboard Data
				 this.distributeDashboardData();
				 
				 //Initialize RT
				 this.RealTime= this.RealTimeEnabled=="true" ? true:false;
				 this.UniqueNodes= await this.rawDataRequestProcessor(this.DataRequest,"nodesRequest");
				 this.addRTListeners();
			 }
			 
		 },500);
    
    }
	
	//------------------------------------------------//
	//------------Data Preparing Functions------------//    
    
    // Add Listeners
    addInitialListeners() {
		
		//Listener to recieve Element Config
		webMI.trigger.connect("Element_Config_Receiver_"+this.DashboardID, (e) => {
			this.registerElements(e.value);
		},"Real_Time");			
				
    }
    
    // Method to register elements based on configuration
    registerElements(ElementConfig) {
    
		console.log("--------------Registering-------------");
		console.log(this.ElementsConfig);
		
		//Add to Elements Config
		this.ElementsConfig.push(ElementConfig);				
    }    

    // Method to create data requests
    createDataRequest() {
        let chartsNodes = [];
        let chartsConfig = [];
        let updateRequest = [];

        // Process each element config to form the output structure
        this.ElementsConfig.forEach(config => {
            chartsNodes.push({
                chartID: config.chartsConfig.chartID,
                chartNodes: config.chartNodes
            });

            chartsConfig.push({
                chartID: config.chartsConfig.chartID,
                chartType: config.chartsConfig.chartType,
                dataType: config.chartsConfig.dataType,
                dataProcessingType: config.chartsConfig.dataProcessingType,
                dataReductionEnable: config.chartsConfig.dataReductionEnable,
                dataReductionMaxSize: config.chartsConfig.dataReductionMaxSize,
                dataoutOfLimitEnable: config.chartsConfig.dataoutOfLimitEnable,
                dataMaxLimit: config.chartsConfig.dataMaxLimit,
                dataMinLimit: config.chartsConfig.dataMinLimit,
                categoryType: config.chartsConfig.categoryType,
                categoryRound: config.chartsConfig.categoryRound,
                categorCustomValue: config.chartsConfig.categorCustomValue,
                categoryCustomIntervalLength: config.chartsConfig.categoryCustomIntervalLength,
                categoryCustomIntervalUnit: config.chartsConfig.categoryCustomIntervalUnit,
                categoryTimeOffset: config.chartsConfig.categoryTimeOffset,
                specialParameters: config.chartsConfig.specialParameters,
                singleDataRequest: false
            });
			
            updateRequest.push({
                chartID: config.chartsConfig.chartID,
                OperationMode: this.UpdateRequest.OperationMode,
                initialTime: this.UpdateRequest.initialTime,
                finalTime: this.UpdateRequest.finalTime,
                customFilterType: this.UpdateRequest.customFilterType,
                cacheConfig: this.UpdateRequest.cacheConfig
            });
        });

        // Construct the final object to be returned
        this.DataRequest = {
            chartsNodes,
            chartsConfig,
            updateRequest
        };
    }
    
    //Process Request
	rawDataRequestProcessor(dataRequest, infoRequired) {
		switch (infoRequired) {
			case "nodesRequest":
				// Use a Set to store unique nodes
				const uniqueNodes = new Set();
				
				// Ensure dataRequest has chartsNodes array
				if (dataRequest.chartsNodes && Array.isArray(dataRequest.chartsNodes)) {
					// Iterate over each chart object in the array
					dataRequest.chartsNodes.forEach(chart => {
						// Add each node to the Set (duplicates will be ignored)
						chart.chartNodes.forEach(node => uniqueNodes.add(node));
					});
				} else {
					console.error("Invalid dataRequest structure: chartsNodes is missing or not an array.");
				}
	
				// Convert the Set back to an array and return it
				return Array.from(uniqueNodes);
			
			default:
				console.error("Unsupported infoRequired:", infoRequired);
				return null;
		}
	}	
   
    // Handle New Request After Initialize
    async updateRequestHandler(updateRequest,RealTime) {
		
		//Update Request Initially is always Hist
		this.RealTime=false;	
		
		//Set Update Request
		 this.UpdateRequest=updateRequest;
		 console.log("------------New Update Request---------");
		 console.log(this.UpdateRequest);
		 
		 //Create Data Request
		 await this.createDataRequest();
		 console.log("------------Data Request Ready---------");
		 console.log(this.DataRequest);
		 
		 //Create Dashboard Data
		 this.DashboardData = await this.dashboardDataCreator();
		 console.log("-----------Dashboard Data--------------");
		 console.log(this.DashboardData);
		 
		 //Distribuite Dashboard Data
		 this.distributeDashboardData();
		 
		 //Update Real time		
		 this.RealTime=RealTime;
    }    
        
    // Method to create dashboard data	
	async dashboardDataCreator() {
		const MAX_CHARTS_PER_REQUEST_HIST = 5;
		const MAX_CHARTS_PER_REQUEST_RT = 2;
		let dataRequest = this.RealTime ? this.DataRequestRT : this.DataRequest;
		
		if (dataRequest.chartsNodes.length>0){
			const maxChartsPerRequest = this.RealTime ? MAX_CHARTS_PER_REQUEST_RT : MAX_CHARTS_PER_REQUEST_HIST;
		
			// Only split if the number of charts exceeds the MAX_CHARTS_PER_REQUEST
			if (dataRequest.chartsNodes.length > maxChartsPerRequest) {
				const dataRequests = this.splitDataRequest(dataRequest, maxChartsPerRequest);
				const responses = [];
		
				for (const request of dataRequests) {
					const response = await this.sendDataRequest(request);
					responses.push(response);
				}
		
				const mergedData = this.mergeResponses(responses);
				console.log("-----------Custom Request answer--------------");
				return mergedData;
			} else {
				const response = await this.sendDataRequest(dataRequest);
				console.log("-----------Custom Request answer--------------");
				return response;
			}
		}
		
		else{
			return {};
		}
	}
	
	// Split the data request into chunks of maximum size
	splitDataRequest(dataRequest, maxChartsPerRequest) {
		const { chartsNodes, chartsConfig, updateRequest } = dataRequest;
		const requests = [];
	
		for (let i = 0; i < chartsNodes.length; i += maxChartsPerRequest) {
			requests.push({
				chartsNodes: chartsNodes.slice(i, i + maxChartsPerRequest),
				chartsConfig: chartsConfig.slice(i, i + maxChartsPerRequest),
				updateRequest: updateRequest.slice(i, i + maxChartsPerRequest)
			});
		}
	
		return requests;
	}
	
	// Send the data request
	sendDataRequest(dataRequest) {
		return new Promise((resolve, reject) => {
			const requestString = JSON.stringify(dataRequest);
			const url = `Advanced_Dashboard_Data_Creator?DataRequest=${requestString}&format=binary`;
			webMI.data.customRequest("GET", url, "responseType=string", (response) => {
				try {
					resolve(response);
				} catch (error) {
					reject(error);
				}
			});
		});
	}
	
	// Merge the responses into a final result
	mergeResponses(responses) {
		const mergedData = {
			chartsData: [],
			Errors: []
		};
	
		responses.forEach(response => {
			if (response.chartsData) {
				mergedData.chartsData = mergedData.chartsData.concat(response.chartsData);
			}
			if (response.Errors) {
				mergedData.Errors = mergedData.Errors.concat(response.Errors);
			}
		});
	
		return mergedData;
	}
	
	// Distribute dashboard data 
    distributeDashboardData() {
		
		var DashboardData;
		//History Data
		if (!this.RealTime){
			DashboardData=this.DashboardData;				
		}
		//Real Time
		else{
			DashboardData=this.DashboardDataRTFinal;
		}
    
        if (DashboardData && DashboardData.chartsData) {
			
            // Iterate over each chartsData element
            DashboardData.chartsData.forEach((chartData, index) => {
				
				//Expected Structure
				var chartDataI={
								Errors:DashboardData.Errors,
								chartData:chartData,	
								RTInfo: {OperationMode:this.RealTime? "RealTime":"Hist",
										 ChartRange: this.ChartTimeRange}	
				};

                // Fire Each Trigger
                webMI.trigger.fire("Element_Data_" + chartData.chartID, chartDataI);
                console.log("Data distributed for chart ID:", chartData.chartID);
            });
        } else {
            console.log("No chartsData to distribute or DashboardData not set.");
        }
    }
    
    //------------------------------------------------//
	//------------Real Time Functions----------------//
    
    // Add Listeners
    addRTListeners() {
		console.log("this.UniqueNodes");
		console.log(this.UniqueNodes);
		
		//Subcribe to Variable Changes			
		webMI.data.subscribe(this.UniqueNodes,(e) => {
			if(this.RealTime){
				//Push Node to RTNodes for next Update	
				this.NodesRT.push({Node:e.address, Value: {Value:e.value,status:e.status,timestamps:e.timestamp}});
				
			}
		});	
		
		
		//Excecute RTUpdate every updateRate
		setInterval((e) => {		
			
			//Excecutes only in Real Time
			if(this.RealTime && this.NodesRT.length>0 && this.DataRTDistributed==true){
				
				//Update state
				this.DataRTDistributed=false;
				
				//Feed Nodes RTI For analisis and reset
				this.updateRTHandler(this.NodesRT);	
				
				this.NodesRT=new Array();
			}
			
		},this.RealTimeUpdateTime);   
		
    }
        
     //Handles RealTime Update
    async updateRTHandler(NodesRT){    
		
		//Create Data Request RT
		this.DataRequestRT= await this.createRTDataRequest(NodesRT);		 
		console.log("------------Data Request RT Ready---------");
		console.log(this.DataRequestRT);		
		
		//Create Dashboard Data Direct (No processing required)
		this.DashboardDataRTDirect=this.dashboardDataDirectCreator();
		console.log("-----------Dashboard Data RT Direct--------------");
		console.log(this.DashboardDataRTDirect);
				
		console.log("-----------DataRequestRT Required Processing--------------");
		console.log(this.DataRequestRT);
		
		//Create Dashboard data which requires processing
		this.DashboardDataRTProcessed= await this.dashboardDataCreator();
		this.updateRTInfo(); //Update interval info if necesary
		console.log("-----------DashboardRT Processed Data--------------");
		console.log(this.DashboardDataRTProcessed);
		
		this.DashboardDataRTFinal=this.dashboardRTDataMerger(this.DashboardDataRTDirect,this.DashboardDataRTProcessed);
		console.log("-----------DashboardRT Data Final--------------");
		console.log(this.DashboardDataRTFinal);
		
		//Distribute Data
		this.distributeDashboardData();
		
		//Ensure data has been Distributed
		this.DataRTDistributed=true;
		
		//Reset Nodes RT
		this.DataRequestRT=new Array();
	}   
    
    async createRTDataRequest(NodesRT) {
		try {
			// Initialize the RT DataRequest object
			let dataRequestRT = {
				chartsNodes: [],
				chartsConfig: [],
				updateRequest: []
			};
			
			// Extract the nodes from NodesRT to filter chartsNodes
			let currentNodes = new Set(NodesRT.map(nodeObj => nodeObj.Node));
	
			// Create a map of chartID to chartNodes for quick lookup
			let chartNodesMap = new Map();
			this.DataRequest.chartsNodes.forEach(chart => {
				let filteredNodes = chart.chartNodes.filter(node => currentNodes.has(node));
				if (filteredNodes.length > 0) {
					chartNodesMap.set(chart.chartID, filteredNodes);
					dataRequestRT.chartsNodes.push({
						chartID: chart.chartID,
						chartNodes: filteredNodes
					});
				}
			});
			
			console.log("dataRequestRT");
			console.log(dataRequestRT);
	
			// Filter chartsConfig based on the filtered chartsNodes chartID
			let validChartIDs = Array.from(chartNodesMap.keys());
			dataRequestRT.chartsConfig = this.DataRequest.chartsConfig.filter(config => validChartIDs.includes(config.chartID));
	
			// Filter updateRequest based on the validChartIDs
			dataRequestRT.updateRequest = this.DataRequest.updateRequest
				.filter(request => validChartIDs.includes(request.chartID))
				.map(request => {
					try {
						// Find the corresponding chartData in DashboardDataBase
						let chartData = this.DashboardDataBase.chartsData.find(chart => chart.chartID === request.chartID);
	
						// Update LastDataPointRT with the corresponding value from NodesRT
						if (chartData && chartData.informationRT) {
							chartData.informationRT.forEach(infoRT => {
								let nodesRT = NodesRT.filter(node => node.Node === infoRT.Node);
								if (nodesRT.length > 0) {
									infoRT.LastDataPointRT = nodesRT.map(nodeObj => ({
										Value: nodeObj.Value.Value,
										status: nodeObj.Value.status,
										timestamps: nodeObj.Value.timestamps
									}));
								} else {
									// If the node is not present in NodesRT, update the timestamp
									// of LastDataPointRT to the timestamp of the node that actually changed
									let changedNode = NodesRT[0]; // Assuming at least one node has changed
									if (infoRT.LastDataPointRT && infoRT.LastDataPointRT.length > 0) {
										infoRT.LastDataPointRT.forEach(dataPoint => {
											dataPoint.timestamps = changedNode.Value.timestamps;
										});
									}
								}
							});
						}
	
						return {
							...request,
							OperationMode: "RealTime",
							informationRT: chartData.informationRT,
						};
					} catch (error) {
						console.error(`Error processing update request for chartID ${request.chartID}:`, error);
						return request; // Return the original request in case of an error
					}
				});
	
			// Return the new RT DataRequest object
			return dataRequestRT;
		} catch (error) {
			console.error("Error creating RT Data Request:", error);
			return null; // Return null or an empty object in case of an error
		}
	}
	
	//DashboardRTDataMerger
	dashboardRTDataMerger(obj1, obj2) {
        // If either of the input objects is empty, return the other one
        if (Object.keys(obj1).length === 0) return obj2;
        if (Object.keys(obj2).length === 0) return obj1;

        // Merge chartsData and Errors
        return {
            chartsData: [...obj1.chartsData, ...obj2.chartsData],
            Errors: [...obj1.Errors, ...obj2.Errors],
        };
    }
   
    //Method to create Dashboard data which is direct
	dashboardDataDirectCreator() {
		try {
			// Initialize the preliminary dashboardData structure
			let dashboardData = {
				chartsData: [],
				Errors: []
			};
	
			// Define criteria for filtering chartsConfig
			const criteria = config => {
				const categoryTypeMatch = (config.categoryType === "AllData-DateTime" || config.categoryType === "Single-Simple");
				const dataProcessingTypeMatch = (config.dataProcessingType === "Simple-None" || config.dataProcessingType === "SinglePoint-LastValue" || config.dataProcessingType === "None");
				const dataReductionEnableMatch = true; //Always
				const dataoutOfLimitEnableMatch = config.dataoutOfLimitEnable === false;
	
				const match = categoryTypeMatch && dataProcessingTypeMatch && dataReductionEnableMatch && dataoutOfLimitEnableMatch;
				return match;
			};
	
			// Filter chartsConfig based on the criteria
			let filteredConfigs = this.DataRequestRT.chartsConfig.filter(criteria);
	
			//console.log("Filtered Configs:", JSON.stringify(filteredConfigs, null, 2));
	
			// Iterate over each filteredConfig to create the required structure
			filteredConfigs.forEach(config => {
				try {
					// Find the corresponding updateRequest
					let updateRequest = this.DataRequestRT.updateRequest.find(req => req.chartID === config.chartID);
					if (!updateRequest) {
						throw new Error(`No updateRequest found for chartID ${config.chartID}`);
					}
	
					// Create chartSeries and chartCategories based on the updateRequest and config
					let chartSeries = [];
					let chartCategories = [];
	
					if (config.categoryType === "AllData-DateTime") {
						// Process for AllData-DateTime category type
						updateRequest.informationRT.forEach(infoRT => {
							chartSeries.push({
								name: infoRT.Node,
								data: [infoRT.LastDataPointRT.map(nodeObj => (
										[nodeObj.timestamps, nodeObj.Value]))]
							});
						});
					} else if (config.categoryType === "Single-Simple") {
						if (config.chartType === "Pyramid"||config.chartType === "Pie"){
							let chartDataI = {};
							let chartDataII=[];
							chartDataI["name"]="Aggregate";
							// Process for Single-Simple category type
							updateRequest.informationRT.forEach(infoRT => {
								chartDataII.push({									 
									y:infoRT.LastDataPointRT[infoRT.LastDataPointRT.length-1].Value,
									name:infoRT.Node										
								});
							});
							chartDataI["data"]=chartDataII;
							chartSeries.push(chartDataI);
						}
						else{
							// Process for Single-Simple category type
							updateRequest.informationRT.forEach(infoRT => {
								chartSeries.push({
									name: infoRT.Node,
									data: [infoRT.LastDataPointRT[infoRT.LastDataPointRT.length-1].Value]
								});
							});
						}
					}
	
					// Create chartData object
					let chartData = {
						chartID: config.chartID,
						chartSeries: chartSeries,
						chartCategories: chartCategories
					};
	
					// Add chartData to dashboardData
					dashboardData.chartsData.push(chartData);
				} catch (error) {
					// Add error to Errors array
					dashboardData.Errors.push(error.message);
				}
			});
	
			// Remove the used chartNodes, chartConfig, and updateRequest
			this.DataRequestRT.chartsNodes = this.DataRequestRT.chartsNodes.filter(
				node => !filteredConfigs.some(config => config.chartID === node.chartID)
			);
			this.DataRequestRT.chartsConfig = this.DataRequestRT.chartsConfig.filter(
				config => !filteredConfigs.includes(config)
			);
			this.DataRequestRT.updateRequest = this.DataRequestRT.updateRequest.filter(
				req => !filteredConfigs.some(config => config.chartID === req.chartID)
			);
	
			// Return the preliminary dashboardData
			return dashboardData;
		} catch (error) {
			console.error("Error creating dashboard data directly:", error);
			return {
				chartsData: [],
				Errors: [error.message]
			};
		}
	}	    
	
	// Method to update RT Info
	updateRTInfo() {
		// Check if both DashboardDataBase and DashboardDataRTProcessed are defined
		if (!this.DashboardDataBase || !this.DashboardDataRTProcessed || !Array.isArray(this.DashboardDataRTProcessed.chartsData)) {
			//console.error("Invalid DashboardDataBase or DashboardDataRTProcessed");
			return;
		}
	
		let hasNewInterval = false;
		let rTNodeNewInterval=new Array();
	
		// Single pass: update intervals and process points
		this.DashboardDataRTProcessed.chartsData.forEach(rtProcessedChart => {
			const baseChart = this.DashboardDataBase.chartsData.find(baseChart => baseChart.chartID === rtProcessedChart.chartID);
	
			if (!baseChart || !Array.isArray(rtProcessedChart.informationRT)) return;
	
			let newStartValue = null;
			
			//Update each informationRT based on the node
			rtProcessedChart.informationRT.forEach(rtProcessedInfo => {
				const baseInfo = baseChart.informationRT.find(baseInfo => baseInfo.Node === rtProcessedInfo.Node);
				if (!baseInfo) return;
	
				// Always update LastDataPointProcessed, LastDataPointRaw, ReduceInfo and OEEinfo
				baseInfo.LastDataPointProcessed = rtProcessedInfo.LastDataPointProcessed;
				baseInfo.LastDataPointRaw = rtProcessedInfo.LastDataPointRaw;
				baseInfo.ReduceInfo = rtProcessedInfo.ReduceInfo;
				baseInfo.OEEInfo = rtProcessedInfo.OEEInfo;
				baseInfo.HistInfo = rtProcessedInfo.HistInfo;
				
				// Always update IntervalInfo (except start)
				baseInfo.IntervalInfo = {
					...baseInfo.IntervalInfo,
					...rtProcessedInfo.IntervalInfo,
					start: baseInfo.IntervalInfo.start // Keep the original start value
				};
	
				// Set new start value if newInterval is true
				if (rtProcessedInfo.IntervalInfo.newInterval) {
					newStartValue = rtProcessedInfo.IntervalInfo.start;
					hasNewInterval = true; // Set flag to true when an update is made
					rTNodeNewInterval.push(rtProcessedInfo.Node);
				}
			});
	
			// If any newInterval is true, set all IntervalInfo.start to new start value for this chart
			if (newStartValue !== null) {
				baseChart.informationRT.forEach(baseInfo => {
					baseInfo.IntervalInfo.start = newStartValue;
					if(!rTNodeNewInterval.includes(baseInfo.Node)){
						baseInfo.LastDataPointProcessed=0;
					}
				});
			}
		});
	
		if (hasNewInterval) {
			console.log("Updated DashboardDataBase with new IntervalInfo.start values");
		}
	}
	
	//Compress data
	 compressData(data, keyMapping) {
        if (Array.isArray(data)) {
            return data.map(item => this.compressData(item, keyMapping));
        } 
        if (typeof data === 'object' && data !== null) {
            return Object.entries(data).reduce((acc, [key, value]) => {
                const newKey = keyMapping[key] || key;
                acc[newKey] = (key === 'initialTime' || key === 'finalTime') 
                    ? new Date(value).toISOString() 
                    : this.compressData(value, keyMapping);
                return acc;
            }, {});
        }
        return data;
    }
}]]></script>
</svg>
