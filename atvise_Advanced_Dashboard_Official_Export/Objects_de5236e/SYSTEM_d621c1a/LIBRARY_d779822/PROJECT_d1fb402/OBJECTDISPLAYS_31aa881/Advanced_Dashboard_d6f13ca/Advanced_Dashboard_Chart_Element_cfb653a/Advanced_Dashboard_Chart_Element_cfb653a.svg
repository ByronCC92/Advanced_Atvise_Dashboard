<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<svg height="304.80000000000001" version="1.2" width="607.60000000000002" xmlns="http://www.w3.org/2000/svg" xmlns:atv="http://webmi.atvise.com/2007/svgext" xmlns:xlink="http://www.w3.org/1999/xlink">
 <defs/>
 <metadata>
  <atv:parameter behavior="optional" defaultvalue="" desc="Dashboard ID" group="GeneralConfig" name="DashboardID" valuetype="string"/>
  <atv:parameter behavior="optional" config="Line;Spline;Area;Column;Bar;Pie;Pyramid;Solidgauge;Histogram;Gauge" defaultvalue="" desc="Chart Type" group="GeneralConfig" name="ChartType" valuetype="enum"/>
  <atv:parameter behavior="optional" config="Values;Alarms;Aggregates" defaultvalue="Values" desc="Data Type" group="GeneralConfig" name="DataType" valuetype="enum"/>
  <atv:parameter behavior="optional" config="EnumList;Text" defaultvalue="Text" desc="Series Source" group="GeneralConfig" name="SeriesSource" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="2" desc="InitialRange" group="GeneralConfig" name="InitialRange" valuetype="number"/>
  <atv:parameter behavior="optional" config="s;min;h;day;month" defaultvalue="min" desc="Initial Range Unit" group="GeneralConfig" name="InitialRangeUnit" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="true" desc="ZoomEnabled" group="Zoom" name="ZoomEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="Data Reduction Enabled" group="DataOptimization" name="DataReductionEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="1000" desc="Data Reduction Max Size" group="DataOptimization" name="DataReductionMaxSize" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="DataLimitEnabled" group="LimitAnalysis" name="DataLimitEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Data Max Limit" group="LimitAnalysis" name="DataMaxLimit" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="#aa0000" desc="Color Limit Point Max" group="LimitAnalysis" name="ColorLimitPointMax" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="#aa0000" desc="Color Limit Line Max" group="LimitAnalysis" name="ColorLimitLineMax" valuetype="color"/>
  <atv:parameter behavior="optional" config="Dash;DashDot;Dot;LongDash;LongDashDot;LongDashDotDot;ShortDash;ShortDashDot;ShortDashDotDot;ShortDot;Solid" defaultvalue="Solid" desc="Type Limit Line Max" group="LimitAnalysis" name="TypeLimitLineMax" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="Max" desc="Text Limit Line Max" group="LimitAnalysis" name="TextLimitLineMax" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Data Min Limit" group="LimitAnalysis" name="DataMinLimit" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="#aa0000" desc="Color Limit Point Min" group="LimitAnalysis" name="ColorLimitPointMin" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="#aa0000" desc="Color Limit Line Min" group="LimitAnalysis" name="ColorLimitLineMin" valuetype="color"/>
  <atv:parameter behavior="optional" config="Dash;DashDot;Dot;LongDash;LongDashDot;LongDashDotDot;ShortDash;ShortDashDot;ShortDashDotDot;ShortDot;Solid" defaultvalue="Solid" desc="Type Limit Line Min" group="LimitAnalysis" name="TypeLimitLineMin" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="Min" desc="Text Limit Line Min" group="LimitAnalysis" name="TextLimitLineMin" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="Data Processing Enabled" group="DataProcessing" name="DataProcessingEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" config="Simple-None;SinglePoint-LastValue;SinglePoint-FirstValue;SinglePoint-Max;SinglePoint-Min;Interval-Addition;Interval-Average;Interval-CountChanges;Interval-CountTimeOff;Interval-CountTimeOn;Interval-Difference;Interval-Histogram;Interval-Integration;FullRange-Addition;FullRange-Average;FullRange-Difference;FullRange-OEEAvailability;FullRange-OEEProductivity" defaultvalue="Simple-None" desc="Data Processing Type" group="DataProcessing" name="DataProcessingType" valuetype="enum"/>
  <atv:parameter behavior="optional" config="AllData-DateTime;Interval-CustomText;Interval-CustomInterval;Interval-Dynamic;Interval-Histogram;Single-Simple" defaultvalue="" desc="Category Type" group="Category Selection" name="CategoryType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="true" desc="Category Round Up" group="Category Selection" name="CategoryRound" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Custom Category" group="Category Selection" name="CategoryCustomText" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="1" desc="Custom Interval Length" group="Category Selection" name="CategoryCustomIntervalLength" valuetype="number"/>
  <atv:parameter behavior="optional" config="s;min;h;day;month" defaultvalue="h" desc="Custom Interval Unit" group="Category Selection" name="CategoryCustomIntervalUnit" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="0" desc="Category Time Offset" group="Category Selection" name="CategoryTimeOffset" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Global Enum List" group="EnumList" name="EnumList" valuetype="global"/>
  <atv:parameter behavior="optional" desc="Input1" group="Series 1" name="Series1Node" valuetype="address"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Label1" group="Series 1" name="Series1Label" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color1" group="Series 1" name="Series1Color" valuetype="color"/>
  <atv:parameter behavior="optional" desc="Input2" group="Series 2" name="Series2Node" valuetype="address"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Label2" group="Series 2" name="Series2Label" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color2" group="Series 2" name="Series2Color" valuetype="color"/>
  <atv:parameter behavior="optional" desc="Input3" group="Series 3" name="Series3Node" valuetype="address"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Label3" group="Series 3" name="Series3Label" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color3" group="Series 3" name="Series3Color" valuetype="color"/>
  <atv:parameter behavior="optional" desc="Input4" group="Series 4" name="Series4Node" valuetype="address"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Label4" group="Series 4" name="Series4Label" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color4" group="Series 4" name="Series4Color" valuetype="color"/>
  <atv:parameter behavior="optional" desc="Input5" group="Series 5" name="Series5Node" valuetype="address"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Label5" group="Series 5" name="Series5Label" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color5" group="Series 5" name="Series5Color" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Title" group="Appereance" name="Title" valuetype="string"/>
  <atv:parameter behavior="optional" config="center;left;rigth" defaultvalue="center" desc="TitleAlign" group="Appereance" name="TitleAlign" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Subtitle" group="Appereance" name="Subtitle" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="YName" group="Appereance" name="YName" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="XName" group="Appereance" name="XName" valuetype="string"/>
  <atv:parameter behavior="optional" config="Color-Pallete;Color-Custom" defaultvalue="Color-Pallete" desc="Color Series Type" group="Appereance" name="ColorSeriesType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Series Palette Color" group="Appereance" name="ColorSeriesPalette" substitute="$Color$" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="Background Transparent Enabled" group="Appereance" name="ColorBackgroundTranspartentEnable" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Background Color" group="Appereance" name="ColorB" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Grid Color" group="Appereance" name="ColorG" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color Title" group="Appereance" name="ColorTitle" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color Subtitle" group="Appereance" name="ColorSubTitle" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Color Legend" group="Appereance" name="ColorLegend" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="#000000" desc="Color xAxis" group="Appereance" name="ColorxAxis" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="#000000" desc="Color yAxis" group="Appereance" name="ColoryAxis" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="SYSTEM.GLOBALS.atvFontColor" desc="Color dataLabels" group="Appereance" name="ColordataLabels" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="14" desc="TitleFontSize" group="Appereance" name="FontSizeTitle" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="12" desc="xAxis FontSize" group="Appereance" name="FontSizexAxis" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="12" desc="yAxis FontSize" group="Appereance" name="FontSizeyAxis" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="12" desc="Legend FontSize" group="Appereance" name="FontSizeLegend" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="12" desc="Data Labels FontSize" group="Appereance" name="FontSizedataLabels" valuetype="number"/>
  <atv:parameter behavior="optional" config="Value-Simple;Time-Dynamic;Time-Custom" defaultvalue="Value-Simple" desc="Data Label Type" group="Appereance" name="DatalabelType" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="mm:ss" desc="Data Label CustomTime Format" group="Appereance" name="DatalabelCustomTimeFormat" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="2" desc="Datalabel Number Decimals" group="Appereance" name="DatalabelNumberDecimals" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Datalabel Unit" group="Appereance" name="DatalabelUnit" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="2" desc="Line Width" group="Line Only" name="LineLineWidth" valuetype="number"/>
  <atv:parameter behavior="optional" config="Dash;DashDot;Dot;LongDash;LongDashDot;LongDashDotDot;ShortDash;ShortDashDot;ShortDashDotDot;ShortDot;Solid" defaultvalue="Solid" desc="Line Dash Style" group="Line Only" name="LineDashStyle" valuetype="enum"/>
  <atv:parameter behavior="optional" config="left;center;right" defaultvalue="center" desc="Label Position" group="Column Only" name="ColumnLabelPosition" valuetype="enum"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="Stack Enabled" group="Column Only" name="ColumnStackEnabled" valuetype="bool"/>
  <atv:parameter behavior="optional" defaultvalue="100" desc="Max Value" group="Solid Gauge Only" name="SolidGaugeMaxValue" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Unit" group="Solid Gauge Only" name="SolidGaugeUnit" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="80" desc="OuterRadius" group="Solid Gauge Only" name="SolidGaugeOuterRadius" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="55" desc="InnerRadius" group="Solid Gauge Only" name="SolidGaugeInnerRadius" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Gauge Unit" group="Gauge Only" name="GaugeUnit" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="0" desc="Gauge Min" group="Gauge Only" name="GaugeMin" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="100" desc="Gauge Max" group="Gauge Only" name="GaugeMax" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Gauge Pane Color" group="Gauge Only" name="GaugePaneColor" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="0" desc="Gauge Band 1 Min" group="Gauge Only" name="GaugeBand1Min" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="50" desc="Gauge Band 1 Max" group="Gauge Only" name="GaugeBand1Max" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="#00aa00" desc="Gauge Band 1 Color" group="Gauge Only" name="GaugeBand1Color" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="50" desc="Gauge Band 2 Min" group="Gauge Only" name="GaugeBand2Min" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="75" desc="Gauge Band 2 Max" group="Gauge Only" name="GaugeBand2Max" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="#ecec00" desc="Gauge Band 2 Color" group="Gauge Only" name="GaugeBand2Color" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="75" desc="Gauge Band 3 Min" group="Gauge Only" name="GaugeBand3Min" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="100" desc="Gauge Band 3 Max" group="Gauge Only" name="GaugeBand3Max" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="#aa0000" desc="Gauge Band 3 Color" group="Gauge Only" name="GaugeBand3Color" valuetype="color"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Gauge Outer Radius" group="Gauge Only" name="GaugeOuterRadius" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Gauge Inner Radius" group="Gauge Only" name="GaugeInnerRadius" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Number of Bins" group="Histogram Only" name="HistogramNumberBins" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Production Speed (U/h)" group="OEE Only" name="OEEProductionSpeed" valuetype="number"/>
  <atv:parameter behavior="optional" defaultvalue="false" desc="Complete Range Analisis" group="OEE Only" name="OEECompleteRangeAnalisis" valuetype="bool"/>
  <atv:gridconfig enabled="true" gridstyle="lines" height="20" width="20"/>
  <atv:snapconfig enabled="true" height="10" width="10"/>
 </metadata>
 <rect atv:refpx="303.798" atv:refpy="140.5" fill="none" height="279" id="Border" stroke="#000000" stroke-width="2" width="605.597" x="1" y="1"/>
 <text atv:refpx="222.595" atv:refpy="160.4" fill="none" font-family="Arial" font-size="36" id="Label" text-anchor="middle" x="303.8" y="164.9">Advanced Chart</text>
 <foreignObject height="280" id="Chart_Container" width="605.597" x="0" y="0">
  <div style="width:100%;height:100%" xmlns="http://www.w3.org/1999/xhtml"/>
 </foreignObject>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/highcharts.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/highcharts-more.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/modules/exporting.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/modules/funnel.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/modules/solid-gauge.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript" xlink:href="../../highcharts/modules/histogram-bellcurve.js"/>
 <script atv:desc="" atv:name="" type="text/ecmascript"><![CDATA[//------Initialize Variables-----------//

//------Parameters   
var Initializing=true;
var chartContainter;

//Chart Config Construction 
const elementRawConfig = { 

	// General Configuration
	GeneralConfig: {
		DashboardID: webMI.query["DashboardID"],
		ChartType: webMI.query["ChartType"],
		DataType: webMI.query["DataType"],
		SeriesSource: webMI.query["SeriesSource"],
		InitialRange: webMI.query["InitialRange"],
		InitialRangeUnit: webMI.query["InitialRangeUnit"]
	},
	
	// Zoom Configuration
	Zoom: {
		ZoomEnabled: webMI.query["ZoomEnabled"] 
	},
	
	// Data Optimization
	DataOptimization: {
		DataReductionEnabled: webMI.query["DataReductionEnabled"],
		DataReductionMaxSize: webMI.query["DataReductionMaxSize"]
	},
	
	// Limit Analysis	
	LimitAnalysis: {
		DataLimitEnabled: webMI.query["DataLimitEnabled"],
		DataMaxLimit: webMI.query["DataMaxLimit"],
		ColorLimitPointMax: webMI.query["ColorLimitPointMax"],
		ColorLimitLineMax: webMI.query["ColorLimitLineMax"],
		TypeLimitLineMax: webMI.query["TypeLimitLineMax"],
		TextLimitLineMax: webMI.query["TextLimitLineMax"],
		DataMinLimit: webMI.query["DataMinLimit"],		
		ColorLimitPointMin: webMI.query["ColorLimitPointMin"],		
		ColorLimitLineMin: webMI.query["ColorLimitLineMin"],
		TypeLimitLineMin: webMI.query["TypeLimitLineMin"],
		TextLimitLineMin: webMI.query["TextLimitLineMin"]
	},
	
	// Data Processing
	DataProcessing: {
		DataProcessingEnabled: webMI.query["DataProcessingEnabled"]=== "true",
		ProcessingType: webMI.query["DataProcessingType"] !== undefined ? webMI.query["DataProcessingType"] : "Simple-None"
	},
	
	// Category
	Category: {
		CategoryType: webMI.query["CategoryType"],
		CategoryRound: webMI.query["CategoryRound"],
		CategoryCustomText: webMI.query["CategoryCustomText"] !== undefined ? webMI.query["CategoryCustomText"] : "",
		CategoryCustomIntervalLength: webMI.query["CategoryCustomIntervalLength"],
		CategoryCustomIntervalUnit: webMI.query["CategoryCustomIntervalUnit"],
		CategoryTimeOffset: webMI.query["CategoryTimeOffset"],
	},
	
	// EnumList
	EnumList: {
		EnumList: webMI.query["EnumList"]
	},
	
	// Series
	Series: [
		{
		  SeriesNode: webMI.query["Series1Node"],
		  SeriesLabel: webMI.query["Series1Label"],
		  SeriesColor: webMI.query["Series1Color"]
		},
		{
		  SeriesNode: webMI.query["Series2Node"],
		  SeriesLabel: webMI.query["Series2Label"],
		  SeriesColor: webMI.query["Series2Color"]
		},
		{
		  SeriesNode: webMI.query["Series3Node"],
		  SeriesLabel: webMI.query["Series3Label"],
		  SeriesColor: webMI.query["Series3Color"]
		},
		{
		  SeriesNode: webMI.query["Series4Node"],
		  SeriesLabel: webMI.query["Series4Label"],
		  SeriesColor: webMI.query["Series4Color"]
		},
		{
		  SeriesNode: webMI.query["Series5Node"],
		  SeriesLabel: webMI.query["Series5Label"],
		  SeriesColor: webMI.query["Series5Color"]
		}
	],
	
	// Appearance
	Appearance: {
		Title: webMI.query["Title"],
		TitleAlign: webMI.query["TitleAlign"],
		Subtitle: webMI.query["Subtitle"],
		YName: webMI.query["YName"],
		XName: webMI.query["XName"],
		ColorSeriesType:webMI.query["ColorSeriesType"],
		ColorSeriesPalette: webMI.query["ColorSeriesPalette"],
		ColorBackgroundTranspartentEnable:webMI.query["ColorBackgroundTranspartentEnable"],
		ColorBackground: webMI.query["ColorB"],
		ColorGrid: webMI.query["ColorG"],
		ColorTitle: webMI.query["ColorTitle"],
		ColorSubTitle: webMI.query["ColorSubTitle"],
		ColorLegend: webMI.query["ColorLegend"],
		ColorXaxis: webMI.query["ColorxAxis"],
		ColorYaxis: webMI.query["ColoryAxis"],
		ColorDataLabels: webMI.query["ColordataLabels"],
		FontSizeTitle: webMI.query["FontSizeTitle"],
		FontSizeXaxis: webMI.query["FontSizexAxis"],
		FontSizeYaxis: webMI.query["FontSizeyAxis"],
		FontSizeLegend: webMI.query["FontSizeLegend"],
		FontSizeDataLabels: webMI.query["FontSizedataLabels"],
		DatalabelType: webMI.query["DatalabelType"],
		DatalabelCustomTimeFormat: webMI.query["DatalabelCustomTimeFormat"],
		DatalabelNumberDecimals: webMI.query["DatalabelNumberDecimals"],
		DatalabelUnit: webMI.query["DatalabelUnit"]
	},
	
	// Line
	Line: {
		LineLineWidth: webMI.query["LineLineWidth"],
		LineDashStyle: webMI.query["LineDashStyle"]
	},	
	 
	// Column
	Column: {
		LabelPosition: webMI.query["ColumnLabelPosition"],
		StackEnabled: webMI.query["ColumnStackEnabled"]
	},
	
	// SolidGauge
	SolidGauge: {
		Unit: webMI.query["SolidGaugeUnit"],
		MaxValue: webMI.query["SolidGaugeMaxValue"],
		OuterRadius: webMI.query["SolidGaugeOuterRadius"],
		InnerRadius: webMI.query["SolidGaugeInnerRadius"]
	},
	
	//Gauge
	Gauge: {
		Unit: webMI.query["GaugeUnit"],
		Min: webMI.query["GaugeMin"],
		Max: webMI.query["GaugeMax"],
		PaneColor:webMI.query["GaugePaneColor"],
		Band1Min: webMI.query["GaugeBand1Min"],
		Band1Max: webMI.query["GaugeBand1Max"],
		Band1Color:webMI.query["GaugeBand1Color"],
		Band2Min: webMI.query["GaugeBand2Min"],
		Band2Max: webMI.query["GaugeBand2Max"],
		Band2Color:webMI.query["GaugeBand2Color"],
		Band3Min: webMI.query["GaugeBand3Min"],
		Band3Max: webMI.query["GaugeBand3Max"],
		Band3Color:webMI.query["GaugeBand3Color"],
		OuterRadius: webMI.query["GaugeOuterRadius"],
		InnerRadius: webMI.query["GaugeInnerRadius"]
	},
	
	// Histogram
	Histogram: {
		NumberBins: webMI.query["HistogramNumberBins"]
	},
	
	
	// OEE
	OEE: {
		OEEProductionSpeed: webMI.query["OEEProductionSpeed"],
		OEECompleteRangeAnalisis: webMI.query["OEECompleteRangeAnalisis"]
	}
	
};


//Initialize Process
webMI.addOnload(function() {
	
	//Get Chart container
	chartContainter=document.getElementById("Chart_Container");
	
	//Create Chart Manager
    const singleChartManagerI=new singleChartManager(elementRawConfig);
    
    //Initialize Chart
    singleChartManagerI.initialize();


});


//Single Chart Manager
class singleChartManager {
	// Attributes
	elementRawConfig;
	elementConfig;
	elementID;
	elementData;
	elementNodes;
	operationMode;
	singleDataRequest;
	chartReference;
	specialParameters;	
	chartLabels;
	configConflicts;
	
	// Constructor
	constructor(elementRawConfig) {
		this.chartReference;
		this.elementData;
		this.limitData;
		this.elementDataRT;
		this.elementID;
		this.chartLabels=[];
		this.configConflicts={};
		this.chartID=this.createChartID();
		this.chartTimeRange;
		this.elementRawConfig=elementRawConfig;   
		this.specialParameters=this.createSpecialParameters(); 
		this.operationMode="RealTime"; //Real time by default
		this.elementConfig=this.elementConfigCreator(elementRawConfig);
		this.elementNodes=this.elementConfig.chartNodes;   
		this.dashboardReady=false;
		this.elementDataReady=false;
		this.firstTime=true;
		this.firstTimeRT=true;
		this.chartColors;	
		this.isPiePyramid=this.elementRawConfig.GeneralConfig.ChartType.toLowerCase() === "pie" || this.elementRawConfig.GeneralConfig.ChartType.toLowerCase() === "pyramid";		
		this.isSG=this.elementRawConfig.GeneralConfig.ChartType.toLowerCase() === "solidgauge";
		this.limitAnalysisEnabled = (this.elementRawConfig.LimitAnalysis.DataLimitEnabled=="true" && (this.elementRawConfig.LimitAnalysis.DataMaxLimit.length >0 || this.elementRawConfig.LimitAnalysis.DataMinLimit.length >0)) ;
		this.limitKey="_Limit"
	}
	
	//Initialize everything
	async initialize() {
		
		console.log("-----------Element Config------------");
		console.log(this.elementConfig);	
		console.log(this.chartLabels);
		
		//Add listeners           
		this.addListeners(); 
		
		//-----------------------------------------------//
		//----------For Single Chart Requests-----------//	
		
		if (this.elementRawConfig.GeneralConfig.DashboardID == "") {
						
			//Create Single Data Request
			this.singleDataRequest = await this.singleDataRequestCreator();
			console.log("-----------Single Data Request------------");
			console.log(this.singleDataRequest);
			
			//Call for data
			this.elementData = await this.singleelementDataCreator();
			console.log("-----------Single Element Data------------");

			//Initialize Chart
			this.initializeChart();
	
			//UpdateChart
			this.updateChart();
			
		}
			   
		//-----------------------------------------------//
		//----------In Dashboard Chart Requests---------//       
		else {   
			
			console.log("-----Registering from chart: "+this.chartID+"----------");
			
			//Wait for Dashboard ready
			await this.waitForDashboardReady();
			
			//First Register Elements
			this.registerElements();
			
			//Wait for Data Ready
			await this.waitForElementDataReady();	
			
			console.log("-----------Single Element Data------------");
			console.log(this.elementData);
			console.log(this.elementData);
			
			
			//Initialize Chart
			this.initializeChart();
	
			//UpdateChart
			this.updateChart();
			
		}
			 
		
	}
	
	//-----------------------------------------------//
	//----------------Data Methods-----------------//	
	//---------------------------------------------//
	
	// Adds Listeners
	addListeners() {
	
		//Dashboard Ready Listener
		webMI.trigger.connect("Dashboard_Ready_"+this.DashboardID, (e) => {
			this.dashboardReady=e;
			
			setTimeout((e) => {
				this.dashboardReady=false;
			},200);
		});	
		
		//Recieve Element Info		
		webMI.trigger.connect("Element_Data_"+this.chartID, (e) => {
			
			this.elementData=e.value;
			console.log("-------------this.elementData------------");	
			console.log(this.elementData);	
			
			//Historic Data
			if(this.elementData.RTInfo.OperationMode=="Hist"){
			
				//First time receives Element Data
				if(this.firstTime){
					this.elementDataReady=true;
					this.firstTime=false;
					
					//Toggle
					setTimeout((e) => {
						this.elementDataReady=false;
					},200);
				}
				
				//After Initialization
				else{
					
					console.log("-------------Updating Chart------------")
					//UpdateChart
					this.updateChart();
				
				}
			}
			
			//Real Time Data
			else if(this.elementData.RTInfo.OperationMode=="RealTime"){
				
				this.elementDataRT=this.elementData;
				console.log("this.elementDataRT");
				console.log(JSON.stringify(this.elementDataRT)); 
				console.log("-------------Updating RT Chart------------");				
				//UpdateChart RT
				this.updateRTChart();
			}
			
		});
		
		//Subcribe to Variable Changes	
		/*
		webMI.data.subscribe(this.elementNodes,(e) => {
			console.log("-------------New Value------------");
			console.log(e.address);
			
			// Updates chart with RT data
			this.updateChartRT(e.value); 
		});	*/
		
	}	
	
	// Registers Element in Menu
	registerElements() {
	
		//Register Element
		webMI.trigger.fire("Element_Config_Receiver_"+this.DashboardID, this.elementConfig); 
			
	}	
		
	// Creates Element Config
	elementConfigCreator() {  
	
		// ElementConfig Structure
		var elementConfig = {
			chartNodes: [],
			chartsConfig: {
				chartID: this.chartID,
				chartType: this.elementRawConfig.GeneralConfig.ChartType,
				dataType: this.elementRawConfig.GeneralConfig.DataType,
				dataProcessingType: this.elementRawConfig.DataProcessing.DataProcessingEnabled == true ? this.elementRawConfig.DataProcessing.ProcessingType:"Simple-None",
				dataReductionEnable: this.elementRawConfig.DataOptimization.DataReductionEnabled === "true",
				dataReductionMaxSize: Number(this.elementRawConfig.DataOptimization.DataReductionMaxSize),
				dataoutOfLimitEnable: this.elementRawConfig.LimitAnalysis.DataLimitEnabled === "true",
				dataMaxLimit: this.elementRawConfig.LimitAnalysis.DataMaxLimit,
				dataMinLimit: this.elementRawConfig.LimitAnalysis.DataMinLimit,
				categoryType: this.elementRawConfig.Category.CategoryType,
				categoryRound: this.elementRawConfig.Category.CategoryRound,
				categorCustomValue: this.elementRawConfig.Category.CategoryCustomText,				
				categoryCustomIntervalLength: this.elementRawConfig.Category.CategoryCustomIntervalLength,
				categoryCustomIntervalUnit: this.elementRawConfig.Category.CategoryCustomIntervalUnit,
				categoryTimeOffset:this.elementRawConfig.Category.CategoryTimeOffset,
				specialParameters:this.specialParameters
			}
		};
		
		// Data Source Text
		if (this.elementRawConfig.GeneralConfig.SeriesSource === "Text") {		
			//Take source from parameters
			this.elementRawConfig.Series.forEach((seriesItem) => {
				if (seriesItem.SeriesNode && !elementConfig.chartNodes.includes(seriesItem.SeriesNode)) { // Check if SeriesNode is not undefined and not already included
					elementConfig.chartNodes.push(seriesItem.SeriesNode);
					this.chartLabels.push(seriesItem.SeriesLabel);
				}
				else if (elementConfig.chartNodes.includes(seriesItem.SeriesNode)){
					this.configConflicts["repeatedNode"]=true;
				}
			});
		}
		
		// Data Source Enum
		else if (this.elementRawConfig.GeneralConfig.SeriesSource === "EnumList") {
			for (const key in this.elementRawConfig.EnumList.EnumList) {
				if (this.elementRawConfig.EnumList.EnumList.hasOwnProperty(key)) {
					const enumItem = this.elementRawConfig.EnumList.EnumList[key];
					if (enumItem.Node && !elementConfig.chartNodes.includes(enumItem.Node)) { // Check if Node is not undefined and not already included
						elementConfig.chartNodes.push(enumItem.Node);
						this.chartLabels.push(enumItem.Label);
					}
					else if (elementConfig.chartNodes.includes(seriesItem.SeriesNode)){
						this.configConflicts["repeatedNode"]=true;
					}
				}
			}
		}
			// Return elementConfig
			return elementConfig;
	}	
	
	// Creates ChartID based position and size
	createChartID() {
		const thisElement = document.getElementById('Chart_Container');
		let index = thisElement.id.indexOf('_Chart_Container');
		return thisElement.id.substring(0, index);	
	}
		
	// Create Special Parameters
	createSpecialParameters() {
	
		var specialParametersI={};
		
		if (this.elementRawConfig.DataProcessing.ProcessingType.includes("OEE")){
			//Add Production Speed
			if (this.elementRawConfig.OEE.OEEProductionSpeed!=null){
				specialParametersI["OEEProductionSpeed"]=this.elementRawConfig.OEE.OEEProductionSpeed;
			}
			
			//Add Full Range Analisis
			if (this.elementRawConfig.OEE.OEECompleteRangeAnalisis!=null){
				specialParametersI["OEECompleteRangeAnalisis"]=this.elementRawConfig.OEE.OEECompleteRangeAnalisis;
			}
		}
		else if (this.elementRawConfig.GeneralConfig.ChartType=="Histogram"){
			specialParametersI["HistogramNumberBins"]=this.elementRawConfig.Histogram.NumberBins;
		}
		
		return specialParametersI;
		
	}
	
	// Wait for Dashboard ready
	waitForDashboardReady() {
		return new Promise((resolve) => {
			const checkReady = () => {
				if (this.dashboardReady) {
					resolve();
				} else {
					setTimeout(checkReady, 100);
				}
			};
			checkReady();
		});
	}
	
	// Wait for Element Data ready
	waitForElementDataReady() {
		return new Promise((resolve) => {
			const checkReady = () => {
				if (this.elementDataReady) {
					console.log("-------Element Data Ready--------")
					resolve();
				} else {
					setTimeout(checkReady, 100);
				}
			};
			checkReady();
		});
	}
  
  
  
	//-----------------------------------------------//
	//----------------Chart Methods-----------------//	
	//---------------------------------------------//
	
	
	//-----------------------------------------------//
	//--------Historical Chart Functions------------//		
	
	// Initialize Chart
	initializeChart() {
	
		//Hide Label and Border
		webMI.gfx.setVisible("Label", false);
		webMI.gfx.setVisible("Border", false);	
		
		const labelFormatterR=this.dataLabelFormatter.bind(this);
		
		//Chart Options
		const chartOptions =  {
			chart: {
				type: (this.elementRawConfig.GeneralConfig.ChartType).toLowerCase(),
				backgroundColor: this.defineBackgroundColor()
			},
			title: {
				text: this.elementRawConfig.Appearance.Title,
				style: {
						fontSize: this.elementRawConfig.Appearance.FontSizeTitle + 'px',
						color: this.elementRawConfig.Appearance.ColorTitle
					}	
			},
			subtitle: {
				text: this.elementRawConfig.Appearance.Subtitle,
				style: {
					color: this.elementRawConfig.Appearance.ColorSubTitle
				}
			},
			xAxis: {
				title: {
					text: this.elementRawConfig.Appearance.XName,
					style: {
						color: this.elementRawConfig.Appearance.ColorYaxis,
						fontSize: this.elementRawConfig.Appearance.FontSizeYaxis + 'px'
					  }
				},
				labels: {
					style: {
						color: this.elementRawConfig.Appearance.ColorXaxis,  
						fontSize: this.elementRawConfig.Appearance.FontSizeXaxis + 'px' 
					}
				},						
			},
			yAxis: {
				title: {
					text: this.elementRawConfig.Appearance.YName,
					style: {
						color: this.elementRawConfig.Appearance.ColorYaxis,
						fontSize: this.elementRawConfig.Appearance.FontSizeYaxis + 'px'
					  }
				},
				visible: true,
				labels: {
				  style: {
					color: this.elementRawConfig.Appearance.ColorYaxis,
					fontSize: this.elementRawConfig.Appearance.FontSizeYaxis + 'px'
				  }
				}
			},
			legend: {
				itemStyle: {
				  color: this.elementRawConfig.Appearance.ColorLegend,
				  fontSize: this.elementRawConfig.Appearance.FontSizeLegend + 'px'
				}
			  },
		   	series: [{
				name: '',
				data: []
			}]
		}
		console.log("-----------Chart Selected Options------------");
		console.log(chartOptions);
	
		this.chartReference = Highcharts.chart(chartContainter, chartOptions);
		
	}
	
	// Updates chart 
	updateChart() {
		
		console.log("-----------Update Chart------------");

		//Update chartRange
		this.chartTimeRange=this.elementData.RTInfo.ChartRange;	    
	    
	    //--------Update Categories-----//	
		this.updateCategories();
		
		//--------Update Series-----//	
		this.updateSeries();	
		
		//--------Specific Type Update-----//			
		this.specificUpdate();
		
		//--------Specific Type Update-----//	
		this.chartReference.redraw();
		
		console.log("-------Chart reference-----");		
		console.log(this.chartReference);
		
	}
	
	//Update Categories
	updateCategories(){
		console.log("-----------Update Categories------------");
		
		//Prepare conditions
		const isDateTime = this.elementRawConfig.Category.CategoryType === "AllData-DateTime";
		const elementDataI = this.elementData.chartData;
		//--------Update Category-----//	
		
		//DateTime Category
		if (isDateTime) { 
			
			//Use Site Time Zone
			Highcharts.setOptions({
				global: {
					useUTC: false
				}
			});
			
			this.chartReference.xAxis[0].update({
				type: 'datetime',
			}, false);			
		} 
		
		// Other Category		
		else {
			if (elementDataI!=null) {

				//Special Categories for Singlepoint Processing
				if(this.elementRawConfig.DataProcessing.DataProcessingEnabled&&(this.elementRawConfig.DataProcessing.ProcessingType.includes("SinglePoint"))){
					let customCategories=elementDataI.chartCategories.map((category, index) => ({
						name:this.defineChartLabel(elementDataI.chartSeries[0].data[index].name),
						x:category
					}));

					this.chartReference.xAxis[0].setCategories(customCategories, false);
					
				}
				//Common Categories
				else{
					this.chartReference.xAxis[0].setCategories(elementDataI.chartCategories, false);
				}
			}
		}
	}
	
	//Update Series
	updateSeries(){
	
		//This update the series based on the type
				
		//Prepare conditions
		const isDateTime = this.elementRawConfig.Category.CategoryType === "AllData-DateTime";
		const elementDataI = this.elementData.chartData;
		
		// Remove existing series 
		while (this.chartReference.series.length > 0) {
			this.chartReference.series[0].remove(false);
		}
		
		//Create Colors
		this.chartColors=this.createChartColors();
				
		//Add Series based on type
		switch (this.elementRawConfig.GeneralConfig.ChartType) {
			case "Pie":
			case "Pyramid":
				console.log("---------Is Pie or Pyramid-------");
				var seriesData;
				var seriesI={};
				
				//Add limits to the series
				if (this.limitAnalysisEnabled){ 
					console.log("-------Adding limits-----");	
					this.addLimitSeries();	
					
					seriesData=this.elementData.chartData.chartSeries[0].data;
					seriesI={
							name: this.elementRawConfig.GeneralConfig.ChartType,
							data: seriesData
							}
				}	
				
				else{
					seriesData = elementDataI.chartSeries[0].data.map((dataPoint, index) => ({
						y:dataPoint.y,
						color: this.chartColors[index],
						name: this.defineChartLabel(dataPoint.name)
					}));
					seriesI={
						name: this.elementRawConfig.GeneralConfig.ChartType,
						data: seriesData
					}
				}
				this.chartReference.addSeries(seriesI, false);
			break;		
				
			case "Solidgauge":
			case "Gauge":
				console.log("---------Is SG o Gauge-------");
				var seriesData;
				var seriesI={};
				
				//Add limits to the series
				if (this.limitAnalysisEnabled){ 
					console.log("-------Adding limits-----");	
					this.addLimitSeries();	

					seriesData= this.elementData.chartData.chartSeries[0].data;
					seriesI={
						name: this.defineChartLabel(elementDataI.chartSeries[0].name),
						data: seriesData,
						dial:this.elementData.chartData.chartSeries[0].dial
					}
				}				
				else{				
					// For Pie or Pyramid charts, apply different colors to each datapoint
					seriesData = elementDataI.chartSeries[0].data.map((dataPoint, index) => ({
						y:dataPoint,
						color: this.chartColors[index],
					}));	
					seriesI={
						name: this.defineChartLabel(elementDataI.chartSeries[0].name),
						data: seriesData
					}				
				}	
				
				this.chartReference.addSeries(seriesI, false);
			break;			
			
			case "Line":
			case "Area":
			case "Spline":
				console.log("---------Is Line,Area or Spline-------");
				
				//Add limits to the series
				if (this.limitAnalysisEnabled){ 
					console.log("-------Adding limits-----");	
					this.addLimitSeries();		
				}
				

				// Add new series for other chart types
				elementDataI.chartSeries.forEach((series, index) => {
				
					//It is a Limit Series (All Data only)
					if(series.custom==this.limitKey){
						this.chartReference.addSeries(series, false);
					}
					else { //It is not a Limit Series
						this.chartReference.addSeries({
							name: this.defineChartLabel(series.name),
							data: series.data,
							color: this.chartColors[index]
						}, false);
					}				
				});
				break;
						
				case "Column":
				case "Histogram":
				default:
					console.log("---------Is Column or Histogram-------");
					if (this.limitAnalysisEnabled){ 
							console.log("-------Adding limits-----");
							console.log("elementDataI.chartSeries");
							console.log(elementDataI.chartSeries);	
							this.addLimitSeries();	
					}
							console.log("elementDataI.chartSeries");
							console.log(elementDataI.chartSeries);	
						// Add new series for other chart types
					elementDataI.chartSeries.forEach((series, index) => {
						if (this.limitAnalysisEnabled){ 				
							this.chartReference.addSeries(series, false);	
						}					
						//No limits
						else{
							
							this.chartReference.addSeries({
								name: this.defineChartLabel(series.name),
								data: series.data,
								color: this.chartColors[index]
							}, false);			
						}
					});
				break;				
		}
	}
	
	//Specific Chart Update
	specificUpdate() {
		
		console.log("----------Apply Specific Config------------");
		let DataProcessingEnabledI=this.elementRawConfig.DataProcessing.DataProcessingEnabled;
		let ProcessingTypeI=this.elementRawConfig.DataProcessing.ProcessingType;			
		const labelFormatterR=this.dataLabelFormatter.bind(this);	
		
		//Apply Specific Config
		switch (this.elementRawConfig.GeneralConfig.ChartType) {
			
			//Line Chart
			case "Line":
				console.log("Updating line");
				this.chartReference.update({
					chart: {
						zooming: this.elementRawConfig.Zoom.ZoomEnabled ? {
							type: 'x'
						}: {},
						panning: this.elementRawConfig.Zoom.ZoomEnabled ? true:false,
						panKey: this.elementRawConfig.Zoom.ZoomEnabled ? 'shift':''
					},					
					plotOptions: {
						line: {
							dashStyle: this.elementRawConfig.Line.LineDashStyle, // Solid, ShortDash, ShortDot, etc.
							lineWidth: this.elementRawConfig.Line.LineLineWidth // Width of the line
						},
						series: this.elementRawConfig.LimitAnalysis.DataLimitEnabled=="true" ? {
							turboThreshold: 5000,
							dataGrouping: {
								enabled: true
							}
						} : []
					},
					
					 yAxis: {
						
						plotLines: this.limitAnalysisEnabled ? [
						//Min Limit						
						{
							color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMin, // Color of the min limit line
							value: this.elementRawConfig.LimitAnalysis.DataMinLimit, // Value where the min limit line will appear
							width: 2, // Width of the min limit line
							dashStyle: this.elementRawConfig.LimitAnalysis.TypeLimitLineMin, // Solid, ShortDash, ShortDot, etc.
							label: {
								text: this.elementRawConfig.LimitAnalysis.TextLimitLineMin,
								align: 'right',
								style: {
									color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMin,
									fontWeight: 'bold'
								}
							}
						},
						//Max Limit	
						{
							color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMax, // Color of the max limit line
							value: this.elementRawConfig.LimitAnalysis.DataMaxLimit, // Value where the max limit line will appear
							width: 2, // Width of the max limit line
							dashStyle: this.elementRawConfig.LimitAnalysis.TypeLimitLineMax,
							label: {
								text: this.elementRawConfig.LimitAnalysis.TextLimitLineMax,
								align: 'right',
								style: {
									color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMax,
									fontWeight: 'bold'
								}
							}
						}] : []
					},
					tooltip: {
						formatter: function () {
							const date = new Date(this.x).toLocaleString(); // Converts x-value to a formatted date string
							return `<b style="color: ${this.series.color};">${"Date"}</b>: ${date}<br><b style="color: ${this.series.color};">${this.series.name}</b>: ${(this.y).toFixed(3)}`;
						}
					}
				}, false); 
				break;
			
			//Spline Chart
			case "Spline":
				this.chartReference.update({
					chart: {
						zooming: this.elementRawConfig.Zoom.ZoomEnabled ? {
							type: 'x'
						}: {},
						panning: this.elementRawConfig.Zoom.ZoomEnabled ? true:false,
						panKey: this.elementRawConfig.Zoom.ZoomEnabled ? 'shift':''
					},	
					plotOptions: {
						line: {
							dashStyle: this.elementRawConfig.Line.LineDashStyle, // Solid, ShortDash, ShortDot, etc.
							lineWidth: this.elementRawConfig.Line.LineLineWidth // Width of the line
						}
					},
					 yAxis: {
						plotLines: this.limitAnalysisEnabled ? [
						//Min Limit						
						{
							color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMin, // Color of the min limit line
							value: this.elementRawConfig.LimitAnalysis.DataMinLimit, // Value where the min limit line will appear
							width: 2, // Width of the min limit line
							dashStyle: this.elementRawConfig.LimitAnalysis.TypeLimitLineMin,
							label: {
								text: this.elementRawConfig.LimitAnalysis.TextLimitLineMin,
								align: 'right',
								style: {
									color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMin,
									fontWeight: 'bold'
								}
							}
						},
						//Max Limit	
						{
							color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMax, // Color of the max limit line
							value: this.elementRawConfig.LimitAnalysis.DataMaxLimit, // Value where the max limit line will appear
							width: 2, // Width of the max limit line
							dashStyle: this.elementRawConfig.LimitAnalysis.TypeLimitLineMax,
							label: {
								text: this.elementRawConfig.LimitAnalysis.TextLimitLineMax,
								align: 'right',
								style: {
									color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMax,
									fontWeight: 'bold'
								}
							}
						}] : []
					},
					tooltip: {
						formatter: function () {
							const date = new Date(this.x).toLocaleString(); // Converts x-value to a formatted date string
							return `<b style="color: ${this.series.color};">${"Date"}</b>: ${date}<br><b style="color: ${this.series.color};">${this.series.name}</b>: ${(this.y).toFixed(3)}`;
						}
					}
				}, false);  
				break;
			
			//Area Chart
			case "Area":
				this.chartReference.update({
					chart: {
						zooming: this.elementRawConfig.Zoom.ZoomEnabled ? {
							type: 'x'
						}: {},
						panning: this.elementRawConfig.Zoom.ZoomEnabled ? true:false,
						panKey: this.elementRawConfig.Zoom.ZoomEnabled ? 'shift':''
					},	
					plotOptions: {
						area: {
							fillOpacity: 0.5
						},
						line: {
							dashStyle: this.elementRawConfig.Line.LineDashStyle, // Solid, ShortDash, ShortDot, etc.
							lineWidth: this.elementRawConfig.Line.LineLineWidth // Width of the line
						}
					},
					yAxis: {
						plotLines: this.limitAnalysisEnabled ? [
						//Min Limit						
						{
							color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMin, // Color of the min limit line
							value: this.elementRawConfig.LimitAnalysis.DataMinLimit, // Value where the min limit line will appear
							width: 2, // Width of the min limit line
							dashStyle: this.elementRawConfig.LimitAnalysis.TypeLimitLineMin,
							label: {
								text: this.elementRawConfig.LimitAnalysis.TextLimitLineMin,
								align: 'right',
								style: {
									color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMin,
									fontWeight: 'bold'
								}
							}
						},
						//Max Limit	
						{
							color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMax, // Color of the max limit line
							value: this.elementRawConfig.LimitAnalysis.DataMaxLimit, // Value where the max limit line will appear
							width: 2, // Width of the max limit line
							dashStyle: this.elementRawConfig.LimitAnalysis.TypeLimitLineMax,
							label: {
								text: this.elementRawConfig.LimitAnalysis.TextLimitLineMax,
								align: 'right',
								style: {
									color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMax,
									fontWeight: 'bold'
								}
							}
						}] : []
					},
					tooltip: {
						formatter: function () {
							const date = new Date(this.x).toLocaleString(); // Converts x-value to a formatted date string
							return `<b style="color: ${this.series.color};">${"Date"}</b>: ${date}<br><b style="color: ${this.series.color};">${this.series.name}</b>: ${(this.y).toFixed(3)}`;
						}
					}
				}, false);  // Set redraw to false
				break;
				
			//Column Chart
			case "Column":
				this.chartReference.update({
					chart: {
						zooming: this.elementRawConfig.Zoom.ZoomEnabled ? {
							type: 'x'
						}: {},
						panning: this.elementRawConfig.Zoom.ZoomEnabled ? true:false,
						panKey: this.elementRawConfig.Zoom.ZoomEnabled ? 'shift':''
					},	
					plotOptions: {
						column: {
							stacking: this.elementRawConfig.Column.StackEnabled == "true" ? 'normal':undefined, // Enable stacking here
							borderWidth: 0,
							groupPadding: 0.2,
							dataLabels: {
								enabled: true,
								style: {
									color: this.elementRawConfig.Appearance.ColorDataLabels,
									fontSize: this.elementRawConfig.Appearance.FontSizeDataLabels + 'px'
								  },
								align: this.elementRawConfig.Column.LabelPosition,
								verticalAlign: 'bottom',	
								formatter: function() {
									let time = this.y;
									const label=labelFormatterR(time);
									return labelFormatterR(time);
								}
							}
						}
					},
					yAxis: {
						plotLines: this.limitAnalysisEnabled ? [
						
						//Min Limit						
						{
							color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMin, // Color of the min limit line
							value: this.elementRawConfig.LimitAnalysis.DataMinLimit, // Value where the min limit line will appear
							width: 2, // Width of the min limit line
							dashStyle: this.elementRawConfig.LimitAnalysis.TypeLimitLineMin,
							label: {
								text: this.elementRawConfig.LimitAnalysis.TextLimitLineMin,
								align: 'right',
								style: {
									color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMin,
									fontWeight: 'bold'
								}
							}
						},
						//Max Limit	
						{
							color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMax, // Color of the max limit line
							value: this.elementRawConfig.LimitAnalysis.DataMaxLimit, // Value where the max limit line will appear
							width: 2, // Width of the max limit line
							dashStyle: this.elementRawConfig.LimitAnalysis.TypeLimitLineMax,
							label: {
								text: this.elementRawConfig.LimitAnalysis.TextLimitLineMax,
								align: 'right',
								style: {
									color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMax,
									fontWeight: 'bold'
								}
							}
						}] : []
					},
					tooltip: {
						formatter: function () {
							return `<b style="color: ${this.series.color};">${"Date"}</b>: ${this.key}<br><b style="color: ${this.series.color};">${this.series.name}</b>: ${this.y}`;
						}
					}
				}, false);  // Set redraw to false
				break;
			
			//Bar Chart
			case "Bar":
				this.chartReference.update({
					plotOptions: {
						bar: {
							dataLabels: {
								enabled: true
							}
						}
					}
				}, false);  // Set redraw to false
				break;
			case "Pie":
				console.log("Updating Pie");				
				this.chartReference.update({
					plotOptions: {
						pie: {
							allowPointSelect: true,
							cursor: 'pointer',
							dataLabels: {
								enabled: true,
								format: '<b>{point.name}</b>: {point.percentage:.1f} %'
							}
						}
					},
					tooltip: {
						formatter: function () {
							let chartReferenceI = this.series.chart;
							let chartCategoriesI=chartReferenceI.xAxis[0].categories;

							if(chartCategoriesI!=undefined && chartCategoriesI.length>0){
								if(DataProcessingEnabledI==true&&(ProcessingTypeI.includes("SinglePoint"))){							
									const foundcategory= chartCategoriesI.find(obj => obj.name === this.key).x;		
									const date = new Date(foundcategory).toLocaleString(); // Converts x-value to a formatted date string
									return `<b style="color: ${this.color};">${"Date"}</b>: ${date}<br><b style="color: ${this.color};">${this.key}</b>: ${(this.y).toFixed(3)}`;
								}
							}
							else{
								return `<b style="color: ${this.color};">${this.key}</b>: ${(this.y).toFixed(3)}`;
							}
						}
					}
				}, false);  // Set redraw to false
				break;
				
			//Pyramid Chart
			case "Pyramid":
				console.log("Updating Pyramid");					
				this.chartReference.update({
					plotOptions: {
						pyramid: {
							reversed: false,
							width: '70%',
							height: '80%'
						}
					},
					tooltip: {
						formatter: function () {
							let chartReferenceI = this.series.chart;
							let chartCategoriesI=chartReferenceI.xAxis[0].categories;

							if(chartCategoriesI!=undefined && chartCategoriesI.length>0){
								if(DataProcessingEnabledI==true&&(ProcessingTypeI.includes("SinglePoint"))){							
									const foundcategory= chartCategoriesI.find(obj => obj.name === this.key).x;		
									const date = new Date(foundcategory).toLocaleString(); // Converts x-value to a formatted date string
									return `<b style="color: ${this.color};">${"Date"}</b>: ${date}<br><b style="color: ${this.color};">${this.key}</b>: ${(this.y).toFixed(3)}`;
								}
							}
							else{
								return `<b style="color: ${this.color};">${this.key}</b>: ${(this.y).toFixed(3)}`;
							}
						}
					}
				}, false);  // Set redraw to false
				break;
			
			case "Histogram":
				this.chartReference.update({
					xAxis: [{	
						
						alignTicks: true,
						labels: {
							align: 'left', // Center the labels
							x: 0, // Adjust x position if needed
							y: 35,
						},
					}],
					yAxis: {
						plotLines: this.limitAnalysisEnabled ? [
						
						//Min Limit						
						{
							color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMin, // Color of the min limit line
							value: this.elementRawConfig.LimitAnalysis.DataMinLimit, // Value where the min limit line will appear
							width: 2, // Width of the min limit line
							dashStyle: this.elementRawConfig.LimitAnalysis.TypeLimitLineMin,
							label: {
								text: this.elementRawConfig.LimitAnalysis.TextLimitLineMin,
								align: 'right',
								style: {
									color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMin,
									fontWeight: 'bold'
								}
							}
						},
						//Max Limit	
						{
							color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMax, // Color of the max limit line
							value: this.elementRawConfig.LimitAnalysis.DataMaxLimit, // Value where the max limit line will appear
							width: 2, // Width of the max limit line
							dashStyle: this.elementRawConfig.LimitAnalysis.TypeLimitLineMax,
							label: {
								text: this.elementRawConfig.LimitAnalysis.TextLimitLineMax,
								align: 'right',
								style: {
									color: this.elementRawConfig.LimitAnalysis.ColorLimitLineMax,
									fontWeight: 'bold'
								}
							}
						}] : []
					},
					plotOptions: {
						histogram: {
							binWidth: 10,
							dataLabels: {
								enabled: true,
								style: {
									color: this.elementRawConfig.Appearance.ColorDataLabels,
									fontSize: this.elementRawConfig.Appearance.FontSizeDataLabels + 'px'
								  },
								align: this.elementRawConfig.Column.LabelPosition,
								verticalAlign: 'top',
							},
							accessibility: {
								point: {
									valueDescriptionFormat: '{index}. {point.x:.3f} to {point.x2:.3f}, {point.y}.'
								}
							}
						}
					},
					tooltip: {
						formatter: function () {
							return `<b>${this.series.name}</b>: ${this.y}`;
						}
					}
				}, false);  // Set redraw to false
				break;
				
			//Solidgauge
			case "Solidgauge":				
				this.chartReference.update({
					chart: {
						height: '100%',
						marginTop: -10 
					},
					tooltip: {
						headerFormat: '<span style="font-size:10px">{point.key}</span><table>',
						pointFormat: '<tr><td style="color:{series.color};padding:0">{series.name}: </td>' +
									 '<td style="padding:0"><b>{point.y:.3f}' + this.elementRawConfig.SolidGauge.Unit + '</b></td></tr>',
						footerFormat: '</table>',
						shared: true,
						useHTML: true
					},
					pane: {
						startAngle: 0,
						endAngle: 360,
						background: [{
							outerRadius: this.elementRawConfig.SolidGauge.OuterRadius+"%",
							innerRadius: this.elementRawConfig.SolidGauge.InnerRadius+"%",
							backgroundColor: Highcharts.color(this.chartColors[0])
								.setOpacity(0.3)
								.get(),
							borderWidth: 0
						}]
					},
					yAxis: {
						min: 0,
						max: this.elementRawConfig.SolidGauge.MaxValue,
						lineWidth: 0,
						tickPositions: []
					},
					plotOptions: {
						solidgauge: {
							innerRadius: this.elementRawConfig.SolidGauge.InnerRadius+"%",
							radius: this.elementRawConfig.SolidGauge.OuterRadius+"%", 
							dataLabels: {
								enabled: true,
								backgroundColor: 'none',
								borderWidth: 0,
								color: this.elementRawConfig.Appearance.ColorDataLabels,
								shadow: false,
								style: {
									color: this.elementRawConfig.Appearance.ColorDataLabels,
									fontSize: (this.elementRawConfig.Appearance.FontSizeDataLabels == 12 ? 22: this.elementRawConfig.Appearance.FontSizeDataLabels)+ 'px'
								},
								valueSuffix: 'H',
								y: -18,
								align: 'center',
								formatter: function () {
									var value = this.y;
									const label=labelFormatterR(value);
									// Return the custom label format
									return label;
								}
							},
							linecap: 'square',
							stickyTracking: false,
						}
					}
				}, false); // Set redraw to false
				break;
				
			//SimpleGauge
			case "Gauge":
				const Gauge_unit=this.elementRawConfig.Gauge.Unit;
				
				this.chartReference.update({
					chart: {
						plotBackgroundColor: null,
						plotBackgroundImage: null,
						plotBorderWidth: 0,
						plotShadow: false,
						height: '80%'
					},
				
					pane: {
						startAngle: -90,
						endAngle: 89.9,
						background: [{
							backgroundColor: this.elementRawConfig.Gauge.PaneColor.length>0 ? this.elementRawConfig.Gauge.PaneColor: 'transparent',
							borderWidth: 0
						}],
						center: ['50%', '75%'],
						size: '110%'
					},
				
					// the value axis
					yAxis: {
						min: Number(this.elementRawConfig.Gauge.Min),
						max: Number(this.elementRawConfig.Gauge.Max),
						tickPixelInterval: 72,
						tickPosition: 'inside',
						tickColor: Highcharts.defaultOptions.chart.backgroundColor || '#FFFFFF',
						tickLength: 20,
						tickWidth: 2,
						minorTickInterval: null,
						labels: {
							distance: 20,
							style: {
								fontSize: this.elementRawConfig.Appearance.FontSizeYaxis + 'px'
							}
						},
						lineWidth: 0,
						plotBands: [{
							from: this.elementRawConfig.Gauge.Band1Min,
							to: this.elementRawConfig.Gauge.Band1Max,
							color: this.elementRawConfig.Gauge.Band1Color, // green
							thickness: 20,
							borderRadius: '50%'
						}, {
							from: this.elementRawConfig.Gauge.Band2Min,
							to: this.elementRawConfig.Gauge.Band2Max,
							color: this.elementRawConfig.Gauge.Band2Color, // yellow
							thickness: 20
						}, {
							from: this.elementRawConfig.Gauge.Band3Min,
							to: this.elementRawConfig.Gauge.Band3Max,
							color: this.elementRawConfig.Gauge.Band3Color, // red
							thickness: 20,
							borderRadius: '50%'
						}]
					},
					
					plotOptions: {
						gauge: {
							dataLabels: {
								borderWidth: 0,
								color: this.elementRawConfig.Appearance.ColorDataLabels,
								style: {
									color: this.elementRawConfig.Appearance.ColorDataLabels,
									fontSize: (this.elementRawConfig.Appearance.FontSizeDataLabels == 12 ? 16: this.elementRawConfig.Appearance.FontSizeDataLabels)+ 'px'
								},
								formatter: function () {
									var value = this.y;
									const label=labelFormatterR(value);
									// Return the custom label format
									return label;
								}
							},
							dial: {
								radius: '80%',
								backgroundColor: 'gray',
								baseWidth: 12,
								baseLength: '0%',
								rearLength: '0%'
							},
							pivot: {
								backgroundColor: 'gray',
								radius: 6
							},
							tooltip: {
								pointFormatter: function() {
									return '<b>' + this.series.name + '</b><br/>' +
										   'Value: ' + this.y.toFixed(2) +' ' +Gauge_unit;
								}
							}
						}
					},
				}, false); // Set redraw to false
			break;
			
			default:
				console.log("No specific configurations applied.");
		}
	}	
	
	//Add limits	
	addLimitSeries() {
		if (!this.elementData || !this.elementData.chartData || !this.elementData.chartData.LimitDashboardData) {
			console.error("Element data is not available or does not contain limit data.");
			return;
		}
	
		const chartSeries = this.elementData.chartData.chartSeries;
		this.limitData = this.elementData.chartData.LimitDashboardData;
	
		// Check the category type
		if (this.elementConfig.chartsConfig.categoryType === "AllData-DateTime") {
			
			this.limitData.forEach(limitData => {

				// Create a new series for the limit data
				const limitSeries = {
					type: 'scatter',
					name: this.defineChartLabel(limitData.name),
					custom: this.limitKey,
					data: limitData.data.map(limitPoint => ({
						x: limitPoint[0],
						y: limitPoint[1],
						color: limitPoint[1] > this.elementRawConfig.LimitAnalysis.DataMaxLimit
							? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
							: limitPoint[1] < this.elementRawConfig.LimitAnalysis.DataMinLimit
								? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
								: undefined // Default color if within limits
					})),
					marker: {
						enabled: true,
						symbol: 'circle'
					},
					lineWidth: 0 // No connecting line
				};
	
				// Add the limit series to the chart series
				chartSeries.push(limitSeries);
			});
		} 
		
		else if (this.elementConfig.chartsConfig.categoryType.includes("Interval")) {
			// New action for "Interval" category type
			chartSeries.forEach((series, indexS) => {
				// Find the corresponding limitData by name
				const limitData = this.limitData.find(limit => limit.name === (series.name)+this.limitKey);
				const colorIndex = this.elementNodes.findIndex(node => node === (series.name));
				
				if(this.elementRawConfig.GeneralConfig.ChartType== "Column"){				
					if (limitData) {
						series.name= this.defineChartLabel(series.name);
						series.color= this.chartColors[colorIndex];
						
						series.data = series.data.map((dataPoint, index) => {
							if (limitData.data[index] === 1) {
								return {
									y: dataPoint,
									color: dataPoint > this.elementRawConfig.LimitAnalysis.DataMaxLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
										: dataPoint < this.elementRawConfig.LimitAnalysis.DataMinLimit
											? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
											: this.chartColors[colorIndex] // Default color if within limits
								};
							} else {
								return {
									y: dataPoint,
									color:this.chartColors[colorIndex] // Default color if within limits
								};
							}
						});
					}
				}
				
				else if(this.elementRawConfig.GeneralConfig.ChartType== "Histogram"){
					console.log("Entering to Histogram")
					series.name= this.defineChartLabel(series.name);
					series.type="histogram";
					series.data = series.data.map((dataPoint, index) => {						
						return {
							y: dataPoint,
							color: dataPoint > this.elementRawConfig.LimitAnalysis.DataMaxLimit
								? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
								: dataPoint < this.elementRawConfig.LimitAnalysis.DataMinLimit
									? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
									: this.chartColors[colorIndex] // Default color if within limits
						};
					});
				}
			});
		}
		
		else if (this.elementConfig.chartsConfig.categoryType.includes("Single")) {
			console.log("Excecuting Single logic")
			// Find the corresponding limitData by name		
			
			const colorIndex = this.elementNodes.findIndex(node => node === (chartSeries[0].name));
			var chartSeriesI={};
				
			if (this.elementRawConfig.GeneralConfig.ChartType== "Gauge"||this.elementRawConfig.GeneralConfig.ChartType== "Solidgauge"){			
				chartSeriesI["data"] = chartSeries[0].data.map((dataPoint, index) => ({
					y:dataPoint,
					color: dataPoint > this.elementRawConfig.LimitAnalysis.DataMaxLimit
									? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
									: dataPoint < this.elementRawConfig.LimitAnalysis.DataMinLimit
									? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
									: this.chartColors[colorIndex], // Default color if within limits,
				}));
				
				//Special Dial Update
				if (this.elementRawConfig.GeneralConfig.ChartType== "Gauge"){
					const limitDialColor=chartSeriesI.data[0].color==this.chartColors[colorIndex] ? "#808080":chartSeriesI.data[0].color;
					chartSeriesI["dial"]= {
						backgroundColor: limitDialColor, // Custom color for the needle
						borderColor: limitDialColor // Border color for the needle
					
					}
					chartSeries[0]["dial"]=chartSeriesI.dial;				
				}

			}
		
			else if	(this.elementRawConfig.GeneralConfig.ChartType== "Pie"||this.elementRawConfig.GeneralConfig.ChartType== "Pyramid")
			{
				chartSeriesI["data"] = chartSeries[0].data.map((dataPoint, index) => ({
						y:dataPoint.y,
						color: dataPoint.y > this.elementRawConfig.LimitAnalysis.DataMaxLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
										: dataPoint.y < this.elementRawConfig.LimitAnalysis.DataMinLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
										: this.chartColors[this.elementNodes.findIndex(node => node === (dataPoint.name))], // Default color if within limits,
						name: this.defineChartLabel(dataPoint.name)
				}));
			}	
			chartSeries[0].data=chartSeriesI.data;						
						
		}
		// Update this.elementData.chartData.chartSeries
		this.elementData.chartData.chartSeries = chartSeries;		
	}
	
	//-----------------------------------------------//
	//--------RT Chart Functions------------//

	updateRTChart() {

		const dataProcessingType = this.elementConfig.chartsConfig.dataProcessingType;
		const elementDataRT = this.elementDataRT;

		//Add limits to the series
		if (this.limitAnalysisEnabled){ 
			console.log("-------Adding limits-----");	
			this.addLimitSeriesRT();		
		}
		
		//Simple Processing (All Data)
		if (dataProcessingType.includes("Simple")) {
				this.updateSimpleData();
		} 
		//FullRange/SinglePoint Processing (One Point)
		else if (dataProcessingType.includes("FullRange") || dataProcessingType.includes("SinglePoint")) {
		
			console.log("-----Updating Full Range--------")
			if (this.firstTimeRT)	{
				setTimeout((e) => {	
					this.updateFullRangeOrSinglePointData();
				},500);
			}
			else{				
				this.updateFullRangeOrSinglePointData();				
			}
		} 
		//Interval Processing (Intervals)
		else if (dataProcessingType.includes("Interval")) {
			if (this.firstTimeRT)	{
				setTimeout((e) => {	
					this.updateIntervalData();
				},200);
			}
			else{				
				this.updateIntervalData();				
			}
			
		} 
		else {
			console.error("Unsupported dataProcessingType: ", dataProcessingType);
		}
	
	}	
	
	addLimitSeriesRT() {
		if (!this.elementDataRT || !this.elementDataRT.chartData || !this.elementDataRT.chartData.LimitDashboardData) {
			console.error("Element data is not available or does not contain limit data.");
			return;
		}
		
		const chartSeries = this.elementDataRT.chartData.chartSeries;
		this.limitData = this.elementDataRT.chartData.LimitDashboardData;
	
		// Check the category type
		if (this.elementConfig.chartsConfig.categoryType === "AllData-DateTime") {
			this.limitData.forEach(limitData => {
				// Create a new series for the limit data
				const limitSeries = {
					name: this.defineChartLabel(limitData.name),
					custom: this.limitKey,
					data: limitData.data.map(limitPoint => ({
						x: limitPoint[0],
						y: limitPoint[1],
						color: limitPoint[1] > this.elementRawConfig.LimitAnalysis.DataMaxLimit
							? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
							: limitPoint[1] < this.elementRawConfig.LimitAnalysis.DataMinLimit
								? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
								: undefined // Default color if within limits
					})),
					marker: {
						enabled: true,
						symbol: 'circle'
					},
					lineWidth: 0 // No connecting line
				};
	
				// Add the limit series to the chart series
				chartSeries.push(limitSeries);
			});
		} 
		
		else if (this.elementConfig.chartsConfig.categoryType.includes("Interval")) {
			console.log("For Interval")
			// Process interval data
			chartSeries.forEach((series, indexS) => {
				// Find the corresponding limitData by name
				const limitData = this.limitData.find(limit => limit.name === (series.name + this.limitKey));
				const colorIndex = this.elementNodes.findIndex(node => node === (series.name));
				
				if(this.elementRawConfig.GeneralConfig.ChartType== "Column"){	
					if (limitData) {
						console.log("Entered Limit Data");
						series.data = series.data.map((dataPoint, index) => {
							if (limitData.data[index] === 1) {
								return {
									y: dataPoint,
									color: dataPoint > this.elementRawConfig.LimitAnalysis.DataMaxLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
										: dataPoint < this.elementRawConfig.LimitAnalysis.DataMinLimit
											? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
											: this.chartColors[colorIndex] // Default color if within limits
								};
							} else {
								return {
									y: dataPoint,
									color:this.chartColors[colorIndex] // Default color if within limits
								};
							}
						});
					}					
				}	
				
				else if(this.elementRawConfig.GeneralConfig.ChartType== "Histogram"){
					console.log("Entering to Histogram")
					series.name= this.defineChartLabel(series.name);
					series.type="histogram";
					series.data = series.data.map((dataPoint, index) => {						
						return {
							y: dataPoint,
							color: dataPoint > this.elementRawConfig.LimitAnalysis.DataMaxLimit
								? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
								: dataPoint < this.elementRawConfig.LimitAnalysis.DataMinLimit
									? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
									: this.chartColors[colorIndex] // Default color if within limits
						};
					});
				}			
			});
		}
		else if (this.elementConfig.chartsConfig.categoryType.includes("Single")) {
						
			// Find the corresponding limitData by name		
			const colorIndex = this.elementNodes.findIndex(node => node === (chartSeries[0].name));			
			var chartSeriesI={};

			if (this.elementRawConfig.GeneralConfig.ChartType== "Gauge"||this.elementRawConfig.GeneralConfig.ChartType== "Solidgauge"){						
				chartSeriesI["data"] = chartSeries[0].data.map((dataPoint, index) => ({
					y:dataPoint,
					color: dataPoint > this.elementRawConfig.LimitAnalysis.DataMaxLimit
									? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
									: dataPoint < this.elementRawConfig.LimitAnalysis.DataMinLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
										: this.chartColors[colorIndex], // Default color if within limits,
				}));
				
				if (this.elementRawConfig.GeneralConfig.ChartType== "Gauge"){
					const limitDialColor=chartSeriesI.data[0].color==this.chartColors[colorIndex] ? "#808080":chartSeriesI.data[0].color;
					chartSeriesI["dial"]= {
						backgroundColor: limitDialColor, // Custom color for the needle
						borderColor: limitDialColor // Border color for the needle
					}	
					chartSeries[0]["dial"]=chartSeriesI.dial;			
				}
			}
			else if	(this.elementRawConfig.GeneralConfig.ChartType== "Pie"||this.elementRawConfig.GeneralConfig.ChartType== "Pyramid")
			{
				chartSeriesI["data"] = chartSeries[0].data.map((dataPoint, index) => ({
						y:dataPoint.y,
						color: dataPoint.y > this.elementRawConfig.LimitAnalysis.DataMaxLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMax
										: dataPoint.y < this.elementRawConfig.LimitAnalysis.DataMinLimit
										? this.elementRawConfig.LimitAnalysis.ColorLimitPointMin
										: this.chartColors[this.elementNodes.findIndex(node => node === (dataPoint.name))], // Default color if within limits,
						name: this.defineChartLabel(dataPoint.name)
				}));
			}
			
			chartSeries[0].data=chartSeriesI.data;			
		}	
	
		// Update this.elementDataRT.chartData.chartSeries
		this.elementDataRT.chartData.chartSeries = chartSeries;
	}
	
	// Process data for "Simple" type
	updateSimpleData() {
		// Check if the category type is "AllData-DateTime"
		if (this.elementConfig.chartsConfig.categoryType === "AllData-DateTime") {
			// Processing simple data
			console.log("---------Updating Simple Data-----------");
	
			// Get the series from the chart reference
			const chartSeries = this.chartReference.series;
	
			// Iterate through the updatingData to find the matching series by name
			this.elementDataRT.chartData.chartSeries.forEach(updatingSeries => {
				
				// Find the corresponding series in the chart
				const chartSeriesItem = chartSeries.find(series => series.name === this.defineChartLabel(updatingSeries.name));
				const chartrange = this.chartTimeRange;
	
				if (chartSeriesItem) {
					if (this.limitAnalysisEnabled) {
						updatingSeries.data = [updatingSeries.data];
					}
	
					// Check if there are new data points to add
					if (updatingSeries.data.length > 0) {
						// Add new data points to the series
						updatingSeries.data.forEach(dataPoints => {
							// Ensure dataPoints is an array of points
							if (Array.isArray(dataPoints) && dataPoints.length > 0) {
								dataPoints.forEach(dataPoint => {
									chartSeriesItem.addPoint(dataPoint, false); // Set redraw to false
								});
							}
						});
	
						// Calculate minTime after adding new points
						const dataLength = chartSeriesItem.data.length;
						if (dataLength > 1 && chartSeriesItem.data[dataLength - 1] != null) {
							const lastPointTime = chartSeriesItem.data[dataLength - 1].x;
							const minTime = lastPointTime - chartrange;
	
							// Remove points outside the range from all series
							chartSeries.forEach(series => {
								while (series.data.length > 0 && series.data[0].x < minTime) {
									series.data[0].remove(false); // Set redraw to false
								}
							});
						}
					}
				}
			});
			
			// Redraw the chart after updates
			this.chartReference.redraw();
		}
	}
	
	// Process data for "FullRange Or SinglePoint" type
	updateFullRangeOrSinglePointData() {
		// Processing full range or single point data
		console.log("---------Updating Full Range or Single Point Data-----------");
		// Get the series from the chart reference
		const chartSeries = this.chartReference.series;
		
		//Pie and Pyramid Case
		if (this.isPiePyramid) {  //For Pie chart Data		
			
			// Update each data point in the pie chart based on the name
			const updatingData = this.elementDataRT.chartData.chartSeries[0].data;	
			const elementDataI=this.elementDataRT.chartData;
			
			//Special Categories for Singlepoint Processing
			if(this.elementRawConfig.DataProcessing.DataProcessingEnabled&&(this.elementRawConfig.DataProcessing.ProcessingType.includes("SinglePoint"))){
				
				let updatedCategories=this.chartReference.xAxis[0].categories.map((category, index) => {

					const foundIndex = elementDataI.chartSeries[0].data.findIndex(dataPoint => this.defineChartLabel(dataPoint.name) === category.name);;
					const foundcategory =elementDataI.chartCategories[foundIndex];
		
					//Updated category
					if(foundcategory!=undefined){
						return ({
							name:this.defineChartLabel(category.name),
							x:foundcategory
						})				
					}
					//Keep the same category
					else{
						return category;
					}
					
				});
				
				this.chartReference.xAxis[0].setCategories(updatedCategories, false);
			}
			
			//Updating points
			updatingData.forEach(updatingPoint => {
				const dataPoint = chartSeries[0].data.find(point => point.name === this.defineChartLabel(updatingPoint.name));
				if (dataPoint) {							
					if (this.limitAnalysisEnabled){
						dataPoint.update(updatingPoint, false); // Update the data point, no redraw yet
					}
					else{										
						dataPoint.update(updatingPoint.y, false); // Update the data point, no redraw yet
					}								
				}
			});
		}
		
		//Any other case
		else{		
			// Iterate through the updatingData to find the matching series by name
			this.elementDataRT.chartData.chartSeries.forEach(updatingSeries => {
				// Find the corresponding series in the chart
				const chartSeriesItem = chartSeries.find(series => series.name === this.defineChartLabel(updatingSeries.name));
				if (chartSeriesItem) {
					// Check if there is a new data point to add
					if (updatingSeries.data.length > 0) {
						// Update the series with the new data point
						const newValue = updatingSeries.data[0];
						const lastPoint = chartSeriesItem.data[chartSeriesItem.data.length - 1];
		
						// Update the last point with the new value or add the point if the series is empty
						if (lastPoint) {
							lastPoint.update(newValue, true); // Update last point, no redraw
							if(this.elementRawConfig.GeneralConfig.ChartType== "Gauge" &&this.limitAnalysisEnabled){
								chartSeriesItem.update({
										dial:updatingSeries.dial
								});
							} 
						} 
					}
				}
			});
			
		}
	
		// Redraw the chart after updates
		this.chartReference.redraw();
	}
	
	// Process data for "Interval" type
    updateIntervalData() {
		console.log("---------Processing Interval Data-----------");
	
		const elementDataI = this.elementDataRT.chartData;
		const intervalInfo = elementDataI.informationRT;
	
		// Check if it is necessary to go to a new interval
		const newInterval = intervalInfo.some(info => info.IntervalInfo.newInterval);
	
		// If the chart type is Histogram
		if (this.elementRawConfig.GeneralConfig.ChartType === "Histogram") {
			console.log("---------Processing Histogram Data-----------");
	
			// Get existing categories from the xAxis
			const existingCategories = this.chartReference.xAxis[0].categories;
			const newCategories = elementDataI.chartCategories;
	
			 // Merge existing and new categories, ensuring they are in the correct order
			newCategories.forEach((category) => {
				if (!existingCategories.includes(category)) {
					existingCategories.push(category);
				}
			});
	
			// Sort the categories
			existingCategories.sort((a, b) => {
				const aStart = parseFloat(a.split('-')[0]);
				const bStart = parseFloat(b.split('-')[0]);
				return aStart - bStart;
			});
			
			// Update the xAxis with the new categories
			this.chartReference.xAxis[0].setCategories(existingCategories, false);
	
			// Update series data
			elementDataI.chartSeries.forEach(updatingSeries => {
				// Find the corresponding series in the chart by name
				const chartSeriesItem = this.chartReference.series.find(series => series.name === this.defineChartLabel(updatingSeries.name));
				if (chartSeriesItem) {
					console.log("chartSeriesItem");
					console.log(chartSeriesItem);
					console.log("updatingSeries");
					console.log(updatingSeries);
					// Check and update each data point in the series
					updatingSeries.data.forEach((dataPoint, index) => {
						if (chartSeriesItem.data[index] && chartSeriesItem.data[index].y !== dataPoint) {
							chartSeriesItem.data[index].update(dataPoint, false);
						} else if (!chartSeriesItem.data[index]) {
							chartSeriesItem.addPoint(dataPoint, false);
						}
					});
				}
			});
			
			// Redraw the chart after updates
			this.chartReference.redraw(true);
		}
		
		//NON-Histogram charts
		 else {		
	
			// Update series data
			elementDataI.chartSeries.forEach(updatingSeries => {
				// Find the corresponding series in the chart by name
				const chartSeriesItem = this.chartReference.series.find(series => series.name === this.defineChartLabel(updatingSeries.name));
				if (chartSeriesItem) {
					const newValue = updatingSeries.data[0];
	
					if (newInterval) {
						// Add new data point and remove the first point						
						chartSeriesItem.addPoint(newValue, false);
						if (chartSeriesItem.data.length > 1) {
							chartSeriesItem.data[0].remove(false); // Remove the first point
						}
					} else {
						// Update the last point with the new value
						console.log("Updating New Value:");
						console.log(newValue);
						const lastPoint = chartSeriesItem.data[chartSeriesItem.data.length - 1];
						lastPoint.update(newValue, false);
					}
				}
			});
	
			if (newInterval) {
				// Add missing series with a value of 0
				this.chartReference.series.forEach(chartSeriesItem => {
					const isSeriesPresent = elementDataI.chartSeries.some(updatingSeries => this.defineChartLabel(updatingSeries.name) === chartSeriesItem.name);
					if (!isSeriesPresent) {
						chartSeriesItem.addPoint(0, false);
						if (chartSeriesItem.data.length > 1) {
							chartSeriesItem.data[0].remove(false); // Remove the first point
						}
					}
				});
			}
	
			// Update categories
			const xAxis = this.chartReference.xAxis[0];
			let updatedCategories;
	
			if (newInterval) {
				// Remove the first category and add the new one using elementDataI.chartCategories[0]
				xAxis.categories.push(elementDataI.chartCategories[0]);
				updatedCategories = xAxis.categories;
				this.chartReference.redraw(true); // Enable animation on redraw    
			} else {
				// Update the last category with the new one
				updatedCategories = xAxis.categories;
				updatedCategories[updatedCategories.length - 1] = elementDataI.chartCategories[0];
				this.chartReference.redraw(false); // Disable animation on redraw
			}
		}
	}
	
	//-----------------------------------------------//
	//----------For Single Chart Requests-----------//	
	
	// Single Chart Request
	async singleDataRequestCreator() {
	
		// Final Time
		const Final_Time = new Date();
	
		// Initial Time
		let Initial_Time = new Date(Final_Time); // Clone Final_Time
	
		switch (this.elementRawConfig.GeneralConfig.InitialRangeUnit) {
			case 's': // Seconds
				Initial_Time.setSeconds(Final_Time.getSeconds() - this.elementRawConfig.GeneralConfig.InitialRange);
			break;
			case 'min': // Minutes
				Initial_Time.setMinutes(Final_Time.getMinutes() - this.elementRawConfig.GeneralConfig.InitialRange);
			break;
			case 'h': // Hours
				Initial_Time.setHours(Final_Time.getHours() - this.elementRawConfig.GeneralConfig.InitialRange);
			break;
			case 'day': // Days
				Initial_Time.setDate(Final_Time.getDate() - this.elementRawConfig.GeneralConfig.InitialRange);
				break;
			case 'month': // Months
				Initial_Time.setMonth(Final_Time.getMonth() - this.elementRawConfig.GeneralConfig.InitialRange);
				break;
			default:
			console.error('Unsupported InitialRangeUnit:', this.elementRawConfig.GeneralConfig.InitialRangeUnit);
			break;
		}
	
		// SingledataRequest completed
		const singledataRequest = {
		  chartsNodes: [{
			chartID: this.chartID,
			chartNodes: this.elementConfig.chartNodes
		  }],
		  chartsConfig: [{
			chartID: this.chartID,
			chartType: this.elementConfig.chartsConfig.chartType,
			dataType: this.elementConfig.chartsConfig.dataType,
			dataProcessingType: this.elementConfig.chartsConfig.dataProcessingType,
			dataReductionEnable: this.elementConfig.chartsConfig.dataReductionEnable,
			dataReductionMaxSize: this.elementConfig.chartsConfig.dataReductionMaxSize,
			dataoutOfLimitEnable: this.elementConfig.chartsConfig.dataoutOfLimitEnable,
			dataMaxLimit: this.elementConfig.chartsConfig.dataMaxLimit,
			dataMinLimit: this.elementConfig.chartsConfig.dataMinLimit,
			categoryType: this.elementConfig.chartsConfig.categoryType,
			categoryRound: this.elementConfig.chartsConfig.categoryRound,
			categorCustomValue: this.elementConfig.chartsConfig.categorCustomValue,
			categoryCustomIntervalLength: this.elementConfig.chartsConfig.categoryCustomIntervalLength,
			categoryCustomIntervalUnit: this.elementConfig.chartsConfig.categoryCustomIntervalUnit,
			categoryTimeOffset:this.elementConfig.chartsConfig.categoryTimeOffset,
			singleDataRequest: true,
			specialParameters:this.specialParameters
		  }],
		  updateRequest: {
			OperationMode: "Hist",
			initialTime: Initial_Time,
			finalTime: Final_Time,
			customFilterType: ""
		  }
		};
	
		return singledataRequest;
	}	
	
	//Single Data Calling
	async singleelementDataCreator() {
		return new Promise((resolve, reject) => {			
			//Custom Request
			webMI.data.customRequest("GET", "Advanced_Dashboard_Data_Creator?DataRequest="+JSON.stringify(this.singleDataRequest)+"&format=binary", "responseType=string", function(e){
				try {  
					console.log("----------Single Request Answered--------");
					
					//Read dashboardData
					let dashboardData=e;
					
					//Check if it´s valid
					if (!dashboardData || !dashboardData.chartsData || !Array.isArray(dashboardData.chartsData) || dashboardData.chartsData.length === 0) {
						throw new Error("Invalid or empty chartsData array");
					}
				
					//Adapt Structure to single Element Data
					const elementDataI = {
						chartData: {
							chartID: dashboardData.chartsData[0].chartID,
							chartSeries: dashboardData.chartsData[0].chartSeries,
							chartCategories: dashboardData.chartsData[0].chartCategories
						},
						Errors: dashboardData.Errors
					};
					resolve (elementDataI);
				} 
				catch (error) {
					console.log("Error found with custom request")
					console.log(error);
				}
			});
		});
	}
	
	//-----------------------------------------------//
	//-------------Auxiliary Functions--------------//
	
	 // Creates Chart Colors
    createChartColors() {
        // Ensure Highcharts.color method is available for color manipulation
        if (typeof Highcharts === 'undefined' || typeof Highcharts.color !== 'function') {
            throw new Error("Highcharts library or Highcharts.color method is not available.");
        }
		
		const baseColor = this.elementRawConfig.Appearance.ColorSeriesPalette;
        const dataLength = this.isPiePyramid ? this.elementData.chartData.chartSeries[0].data.length : this.elementData.chartData.chartSeries.length;
        const colors = [];        
        
        //Color from Color Pallete
        if ( this.elementRawConfig.Appearance.ColorSeriesType=="Color-Pallete") {
			for (let i = 0; i < dataLength; i++) {
				// Calculate color variation
				const variation = 0.4 * i;
				const newColor = Highcharts.color(baseColor).brighten(variation).get();
				colors.push(newColor);
			}        
        }
        
        
        else if( this.elementRawConfig.Appearance.ColorSeriesType=="Color-Custom") {
        
			// Data Source Text
			if (this.elementRawConfig.GeneralConfig.SeriesSource === "Text") {		
				//Take source from parameters
				this.elementRawConfig.Series.forEach(function(seriesItem) {
					if (seriesItem.SeriesNode) { // Check if SeriesNode is not undefined
						colors.push(seriesItem.SeriesColor);
					}
				});
			}
			
			// Data Source Enum
			else if (this.elementRawConfig.GeneralConfig.SeriesSource === "EnumList") {
				for (const key in this.elementRawConfig.EnumList.EnumList) {
					if (this.elementRawConfig.EnumList.EnumList.hasOwnProperty(key)) {
						const enumItem = this.elementRawConfig.EnumList.EnumList[key];
						if (enumItem.Color) { // Check if Node is not undefined
							colors.push(enumItem.Color);
						}
					}
				}
			}
        
        }
        return colors;
    }
    
    defineBackgroundColor(){
		//If transparen Enabled
		if (this.elementRawConfig.Appearance.ColorBackgroundTranspartentEnable=="true"||this.elementRawConfig.Appearance.ColorBackground.length<=0){
			return 'transparent';
	    }
	    else{
			return this.elementRawConfig.Appearance.ColorBackground;
	    }
    
    }
    
    defineChartLabel(SeriesName) {
		console.log("---------Definining Chart Labels----------")

		//Series name comming from Dashboard Data Creator
		if (SeriesName.endsWith(this.limitKey)) { //Series for Limits

			const index_Limit = this.elementNodes.findIndex(node => {
				return node === SeriesName.slice(0, SeriesName.length-this.limitKey.length);
			}); 

			// Return the corresponding label from this.chartLabels or the SeriesName if the label is empty
			if (index_Limit !== -1) {

				const label = this.chartLabels[index_Limit] !== '' ? this.chartLabels[index_Limit]+this.limitKey: '';
				return label !== '' ? label : SeriesName.split('.').pop();
			} else {
				return SeriesName; // return SeriesName if index is not found
			}
			
		}
		
		else {
		
			console.log("Excecuting chart label logic");
			// Find the index of the element in this.elementNodes where SeriesName is the last part
			const index = this.elementNodes.findIndex(node => {
				return node === SeriesName;
			});			
			// Return the corresponding label from this.chartLabels or the SeriesName if the label is empty
			if (index !== -1) {
				const label = this.chartLabels[index];
				return label !== '' ? label : SeriesName.split('.').pop();
			} else {
				return SeriesName; // return SeriesName if index is not found
			}
        }
    }
	
	dataLabelFormatter(rawLabel) {

		const labelType = this.elementRawConfig.Appearance.DatalabelType;
		const customFormat = this.elementRawConfig.Appearance.DatalabelCustomTimeFormat;
		const numberDecimals = this.elementRawConfig.Appearance.DatalabelNumberDecimals;
		const DatalabelUnit = this.elementRawConfig.Appearance.DatalabelUnit;


		if (labelType === "Value-Simple") {
			// Number formatting logic when handling 'Value'
			if (rawLabel >= 1000000) {
				return (rawLabel / 1000000).toFixed(numberDecimals) + 'M '+ DatalabelUnit; // millions
			} else if (rawLabel >= 1000) {
				return (rawLabel / 1000).toFixed(numberDecimals) + 'k '+DatalabelUnit; // thousands
			} else {
				return rawLabel.toFixed(numberDecimals)+DatalabelUnit; // less than 1000
			}
		} 
		else if (labelType === "Time-Dynamic") {
			let time = rawLabel;
	
			if (time <= 3600000) {
				const minutes = Math.floor(time / 60000);
				const seconds = Math.floor((time % 60000) / 1000);
				return `${minutes} m ${seconds} s`;
			} else if (time < 86400000) {
				const hours = Math.floor(time / 3600000);
				const minutes = Math.floor((time % 3600000) / 60000);
				return `${hours} h ${minutes} m`;
			} else if (time < 2592000000) {
				const days = Math.floor(time / 86400000);
				const hours = Math.floor((time % 86400000) / 3600000);
				return `${days} days ${hours} h`;
			} else {
				const months = Math.floor(time / 2592000000);
				const days = Math.floor((time % 2592000000) / 86400000);
				return `${months} M ${days} d`;
			}
		} 		
		else if (labelType === "Time-Custom") {
			let time = rawLabel;
		
			// Extract components for all time hierarchies
			let years = Math.floor(time / 31536000000); // Total milliseconds in a year
			time %= 31536000000;
		
			let months = Math.floor(time / 2592000000); // Total milliseconds in a month
			time %= 2592000000;
		
			let days = Math.floor(time / 86400000); // Total milliseconds in a day
			time %= 86400000;
		
			let hours = Math.floor(time / 3600000); // Total milliseconds in an hour
			time %= 3600000;
		
			let minutes = Math.floor(time / 60000); // Total minutes (including hours)
			let seconds = Math.floor((time % 60000) / 1000); // Remaining seconds
		
			// Determine the highest hierarchy present in the custom format
			const hierarchy = ['YYYY', 'MM', 'DD', 'hh', 'mm', 'ss'];
			const presentHierarchy = hierarchy.filter(unit => customFormat.includes(unit));
			
			console.log("presentHierarchy: "+presentHierarchy);
			
			
			if (presentHierarchy.length > 0) {
				const highestHierarchy = presentHierarchy[0];
		
				// Convert higher units to the highest present unit
				switch (highestHierarchy) {
					case 'YYYY':
						// No higher unit to convert
						break;
					case 'MM':
						months = years * 12 + months; // Convert years to months;
						break;
					case 'DD':
						days = years * 365 + months * 30 + days;
						break;
					case 'hh':
						hours = (years * 365 + months * 30 + days) * 24 + hours; // Convert years, months, days to hours
						break;
					case 'mm':
						minutes = ((years * 365 + months * 30 + days) * 24 + hours) * 60 + minutes; // Convert everything to minutes
						break;
					case 'ss':
						seconds = (((years * 365 + months * 30 + days) * 24 + hours) * 60 + minutes) * 60 + seconds; // Convert everything to seconds;
						break;
				}
		
				// Now, for the second highest hierarchy, if it exists, we convert the higher values into that unit as well
				for (let i = 1; i < presentHierarchy.length; i++) {
					const currentHierarchy = presentHierarchy[i];
					const previousHierarchy = presentHierarchy[i - 1];
		
					switch (currentHierarchy) {
						case 'DD':
							if (previousHierarchy === 'YYYY') {
								days += months * 30; // Convert years to days if YYYY is missing but DD is present
							}
							break;
						case 'hh':

							if (previousHierarchy === 'MM') {
								hours += (days * 24); // Convert months to hours if MM is missing but hh is present
							}
							if (previousHierarchy === 'YYYY') {
								hours += (days* 24)+(months* 30 * 24); // Convert years to hours if YYYY is missing but hh is present
							}
							break;
						case 'mm':
							if (previousHierarchy === 'DD') {
								minutes += (hours * 60); // Convert days to minutes if DD is missing but mm is present
							}
							if (previousHierarchy === 'MM') {
								minutes += (hours * 60) + (days* 24 * 60); // Convert months to minutes if MM is missing but mm is present
							}
							if (previousHierarchy === 'YYYY') {
								minutes += (hours * 60) + (days* 24 * 60)+(months* 30 * 24 * 60); // Convert years to minutes if YYYY is missing but mm is present
								years = 0;
							}
							break;
						case 'ss':
							if (previousHierarchy === 'hh') {
								seconds += minutes * 60; // Convert hours to seconds if hh is missing but ss is present
							}
							if (previousHierarchy === 'DD') {
								seconds += (minutes * 60) + (hours* 60 * 60); // Convert days to seconds if DD is missing but ss is present
							}
							if (previousHierarchy === 'MM') {
								seconds += (minutes * 60) + (hours* 60 * 60) + (days* 24 * 60 * 60); // Convert months to seconds if MM is missing but ss is present
							}
							if (previousHierarchy === 'YYYY') {
								seconds += (minutes * 60) + (hours* 60 * 60) + (days* 24 * 60 * 60)+(months* 30 * 24 * 60 * 60); // Convert years to seconds if YYYY is missing but ss is present
							}
							break;
					}
				}
				let formattedTime = customFormat;
				
				// Format the custom string with the remaining values
				formattedTime = customFormat.replace('YYYY', years.toString().padStart(4, '0'));
				formattedTime = formattedTime.replace('MM', months.toString().padStart(2, '0'));
				formattedTime = formattedTime.replace('DD', days.toString().padStart(2, '0'));
				formattedTime = formattedTime.replace('hh', hours.toString().padStart(2, '0'));
				formattedTime = formattedTime.replace('mm', minutes.toString().padStart(2, '0'));
				formattedTime = formattedTime.replace('ss', seconds.toString().padStart(2, '0'));
		
				return formattedTime;
			} 
		}	
		 else {
			return rawLabel; // Default case: return raw label without formatting
		}	
	} 
}

]]></script>
</svg>
