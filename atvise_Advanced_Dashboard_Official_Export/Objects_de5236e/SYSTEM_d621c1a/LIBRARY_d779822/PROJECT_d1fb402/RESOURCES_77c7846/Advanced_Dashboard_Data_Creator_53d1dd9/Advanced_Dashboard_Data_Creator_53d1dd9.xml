<?xml version="1.0" encoding="UTF-8"?>
<script>
  <metadata>
    <priority>0</priority>
    <owner>root</owner>
    <runcontext>caller</runcontext>
  </metadata>
  <parameter name="Parameters" type="http" trigger="false" relative="false" value=""/>
  <code><![CDATA[//-------------------------------------------------------------// 
//-------------------Dashboard Data Creator-------------------//
/*   The Dashboard Data creator takes instructions called 
	 Data Request and returns Dashboard Data.
	 
	 This is en example of the Data Request Format 
	 
	 chartsNodes: [{chartID: 0,
				   chartNodes: ["AGENT.OBJECTS.Simulacion.Counter.Line_Counter_1",
							   "AGENT.OBJECTS.Simulacion.Counter.Line_Counter_2"]
				  },
				  {chartID: 1,
				   chartNodes: ["AGENT.OBJECTS.Simulacion.Counter.Line_Counter_1"]
				  }],
    chartsConfig: [
					{chartID: 0,
					 chartType: "Pie",
					 dataProcessingType: "SimpleAddition",
					 dataReductionEnable: true,
					 dataReductionMaxSize: 1000,
					 dataoutOfLimitEnable: false,
					 dataMaxLimit:"",
					 dataMinLimit:"",
					 categoryType: "AllData-DateTime",
					 categorCustomValue: "",
					 specialParameters: ""
					},
					{chartID: 1,
					 chartType: "Line",
					 dataProcessingType: "Integration",
					 dataReductionEnable: true,
					 dataReductionMaxSize: 1000,
					 dataoutOfLimitEnable: false,
					 dataMaxLimit:"",
					 dataMinLimit:"",
					 categoryType: "Interval-Dynamic",
					 categoryRound: "true",
					 categorCustomValue: "",
					 categoryCustomIntervalLength: 1
					 categoryCustomIntervalUnit: "h"
					 categoryTimeOffset: "30"
					 specialParameters: ""
					},
				], 
	updateRequest: { 
					OperationMode: "Hist",
					initialTime: Initial_Time,
					finalTime: Final_Time,
					customFilterType: "",
					cacheConfig:{					
						CacheEnabled:true
						CacheIntervalSize:0
						CacheMaxSize:0
						}
				   }
}
	 
*/



//Variables Declaration

console.log("---------------------Excecuting--------------");
console.log("---------------------------------------------");
console.log("---------------------------------------------");
console.log("---------------------------------------------");


var ParametersI= Parameters.request.getvalues;
var dataRequest=JSON.parse(Parameters.request.getvalues["DataRequest"].replace(/'/g, '"'));
console.log("-----------DataRequest------------");
console.log(dataRequest);

//Time Constants
const ONE_MINUTE = 60 * 1000;
const HALF_HOUR = 30 * ONE_MINUTE;
const ONE_HOUR = 60 * ONE_MINUTE;
const ONE_DAY = 24 * ONE_HOUR;



//---------------Dashboard Data Processor----------------//
//-----------------------------------------------------//

class dashboardDataProcessor {
	
	//Attributes
	processedData;
	dynamicCategory;
	
	constructor(dashboardCreatorNotifier) {
		this.processedData = null; // Initialize processedData 
		this.dataRequest;
		this.rawData;
		this.timeRange;
		this.OperationMode;
		this.intervalLength;
		this.uniqueCategoriesConfig=[]; // Initialize unique Config
		this.uniqueCategoriesConfigRT=[];
		this.uniqueCategories=[]; // Initialize unique Categories complete
		this.uniqueCategoriesRT=[];
		this.DCNotfier;
		
		//For each Element Config
		this.uniqueCategoriesConfigI;
		this.intervalLengthI;
		this.processedDataI;
		this.chartConfigI;
		this.updateRequestI;
		this.chartNodesI;
		this.chartCategoriesI=[];
		this.categoryTimeOffsetI;
		this.rawDataI;
		this.nodeI;
		this.indexNodeI;
		this.reductionExcecutedI=false;
		this.partialDashboardDataI;
		this.LimitDashboardDataI;
		this.TooltipDashboardDataI;
		this.DataInfoRTI;
		this.informationRTI;
		this.reductionStepSizeI=0;
		this.reductionreductioniterationsBeforeNextStepRTI=0;
		this.limitAnalysisEnabledI=false;
		this.OEEinfoRTI={};
		this.HistInfoRTI={};
		this.DCNotfier=dashboardCreatorNotifier;
		
		this.newIntervalI=false;
		this.processedDataII;
		this.relevantTimestampII;
		this.processedDataStruct;
	}

	//Initialize Elements
	initialize(dataRequest,rawData) { 
		
		this.DCNotfier.dgConsole("----------Initialize Processor----------");		
		this.dataRequest=dataRequest;
		this.OperationMode=this.dataRequest.updateRequest[0].OperationMode;
		this.rawData=rawData;
		this.timeRange=(new Date(this.dataRequest.updateRequest[0].finalTime)).getTime() - (new Date(this.dataRequest.updateRequest[0].initialTime)).getTime();

		//Operation in Hist Mode
		if (this.OperationMode==="Hist"){
			
			this.DCNotfier.dgConsole("Initial Time");
			this.DCNotfier.dgConsole((new Date(this.dataRequest.updateRequest[0].initialTime)).getTime());
			this.DCNotfier.dgConsole((new Date(this.dataRequest.updateRequest[0].initialTime)).toString());
			this.DCNotfier.dgConsole("Final Time");
			this.DCNotfier.dgConsole((new Date(this.dataRequest.updateRequest[0].finalTime)).getTime());
			this.DCNotfier.dgConsole((new Date(this.dataRequest.updateRequest[0].finalTime)).toString());
				
			//Find all the unique Chart Categories
			this.uniqueCategoriesConfig=this.uniqueChartCategoriesFinder();
			this.DCNotfier.dgConsole("----------Unique Config Categories----------");
			this.DCNotfier.dgConsole(this.uniqueCategoriesConfig);
			
			//Create all unique Chart Categories
			this.uniqueCategories=this.uniqueCategoriesCreator();
			this.DCNotfier.dgConsole("----------Unique Categories Created----------");
			this.DCNotfier.dgConsole(this.uniqueCategories);
		}
		else if (this.OperationMode==="RealTime"){
			
			//Find all the unique Chart Categories
			this.uniqueCategoriesConfigRT=this.uniqueChartCategoriesFinder();
			this.DCNotfier.dgConsole("----------Unique RT Config Categories----------");
			this.DCNotfier.dgConsole(this.uniqueCategoriesConfigRT);
			
			//Create all unique Chart Categories
			this.uniqueCategoriesRT=this.uniqueCategoriesCreatorRT();
			this.DCNotfier.dgConsole("----------Unique RT Categories Created----------");
			this.DCNotfier.dgConsole(this.uniqueCategoriesRT)
			
		}
		
	}

	// Method to handle the processing of requests
	processRequestHandler(dataRequest,rawData) { 
		
		//Process each chartConfig request
		this.processedData = this.dataRequest.chartsConfig.map((chartConfigI, index) => {
		
		
			//Define current chartConfig
			this.chartConfigI=this.dataRequest.chartsConfig[index];
			
			//Define current UpdateRequest
			this.updateRequestI=this.dataRequest.updateRequest[index];

			//Find Nodes of ChartConfig
			this.chartNodesI=this.chartNodesIFinder();
			
			//Process each Data Series (each node)
			this.processedDataI=this.chartNodesI.map((nodeI,indexNodeI) => {
			
				//Current Node
				this.nodeI=nodeI;
				this.indexNodeI=indexNodeI;
				this.DCNotfier.dgConsole("------------this.nodeI--------------");	
				this.DCNotfier.dgConsole(this.nodeI);
				
				//Operation in Hist Mode
				if (this.updateRequestI.OperationMode==="Hist"){	
				
					//Current rawData
					this.rawDataI=rawData[rawData.findIndex(data => data.Nodeaddress === this.nodeI)];	
	
					//Category Handling				
					this.chartCategoriesI=this.categoryHandling();				
					this.DCNotfier.dgConsole("------------Selecting Categories------------");
					this.DCNotfier.dgConsole(this.chartCategoriesI);
					 
					//Data Reduction
					this.partialDashboardDataI=this.dataReductor().reducedData;
					this.updateChartCategory();
					this.DCNotfier.dgConsole("------------Partial Dahsboard Data------------");
					this.DCNotfier.dgConsole(this.partialDashboardDataI);					
		
					//Data Processing
					this.processedDataII=this.dataProcessingHandling();
					this.DCNotfier.dgConsole("------------Processed Data------------");
					this.DCNotfier.dgConsole(this.processedDataII);
					
					//Limits
					this.LimitDashboardDataI=this.limitCalculator().filteredData;
					this.DCNotfier.dgConsole("------------Limits Found------------");
					this.DCNotfier.dgConsole(this.LimitDashboardDataI);	
					
					//Tooltip
					this.TooltipDashboardDataI=this.tooltipInfoCreator();
					this.DCNotfier.dgConsole("------------Tooltip Created------------");
					this.DCNotfier.dgConsole(this.TooltipDashboardDataI);			
					
					//Data for RT Creation 
					this.DataInfoRTI=this.dataInfoRTCreator();	
					this.DCNotfier.dgConsole("------------Data for RT------------");
					this.DCNotfier.dgConsole(this.DataInfoRTI);				
					
					//Create Structure for processed Data				
					this.processedDataStruct=this.createProcessedDataStruct();
					this.DCNotfier.dgConsole("------------Processed Structure------------");
					this.DCNotfier.dgConsole(this.processedDataStruct);
					
					
					return this.processedDataStruct
				}
					
				//Operation in Real time Mode
				else if (this.updateRequestI.OperationMode==="RealTime"){
					
					this.informationRTI=this.dataInfoRTFinder();
					this.DCNotfier.dgConsole("----------Information RT----------");
					this.DCNotfier.dgConsole(this.informationRTI);
					
					//Category Handling				
					this.chartCategoriesI=this.categoryHandling();				
					this.DCNotfier.dgConsole("------------Selecting RT Categories------------");
					this.DCNotfier.dgConsole(this.chartCategoriesI);
					
					//Data Reduction
					this.partialDashboardDataI=this.dataReductor().reducedData;
					this.DCNotfier.dgConsole("------------Partial RT Dahsboard Data------------");
					this.DCNotfier.dgConsole(this.partialDashboardDataI);
					
					//Data Processing
					this.processedDataII=this.dataProcessingHandling();
					this.DCNotfier.dgConsole("------------Processed RT Data------------");
					this.DCNotfier.dgConsole(this.processedDataII);	
					
					//Limits					
					this.LimitDashboardDataI=this.limitCalculator().filteredData;
					this.DCNotfier.dgConsole("------------Limits RT Found------------");
					this.DCNotfier.dgConsole(this.LimitDashboardDataI);	
					
					//Tooltip
					this.TooltipDashboardDataI=this.tooltipInfoCreator();
					this.DCNotfier.dgConsole("------------Tooltip Created------------");
					this.DCNotfier.dgConsole(this.TooltipDashboardDataI)						
					
					//Data for RT Creation 
					this.DataInfoRTI=this.dataInfoRTCreator();	
					this.DCNotfier.dgConsole("------------Data for RT in RT------------");
					this.DCNotfier.dgConsole(this.DataInfoRTI);				
					
					//Create Structure for processed Data				
					this.processedDataStruct=this.createProcessedDataStruct();
					this.DCNotfier.dgConsole("------------Processed Structure------------");
					this.DCNotfier.dgConsole(this.processedDataStruct);
					
					return this.processedDataStruct;
				}	
			});
			
			return {chartID:this.chartConfigI.chartID,
					processedDataStruct:this.processedDataI,
					chartType:this.chartConfigI.chartType,
					elementType:this.chartConfigI.elementType,
					categoryType:this.chartConfigI.categoryType}
		});	
	
		return this.processedData;
	} 
  
	//----------Auxiliary Functions---------------------//
	//--------------------------------------------------//
  
	//Handles Category Per node
	categoryHandling() {
		try {
			const categoryFound=this.chartCategoryIFinder();
			return categoryFound;		  
		} catch (error) {
		  console.error("Error handling category: ", error);
		  console.error(error.message);
		  return { categories: [] }; // Return an empty categories array or handle the error as needed
		}
	}
  
    //Chart Nodes Finder
	chartNodesIFinder() {
		try {
		  // Find index of matching ID
		  const nodesIndex = this.dataRequest.chartsNodes.findIndex(chart => chart.chartID === this.chartConfigI.chartID);
		  
		  if (nodesIndex === -1) {
			throw new Error(`Chart ID ${this.chartConfigI.chartID} not found`);
		  }
		  
		  // Get the Nodes Corresponding to the chartID
		  const chartNodesI = this.dataRequest.chartsNodes[nodesIndex].chartNodes;
		  
		  return chartNodesI;
		} catch (error) {
		  console.error("Error finding chart nodes: ", error);
		  console.error(error.message);
		  return []; // Return an empty array or handle the error as needed
		}
	}
	
	//Find current Chart Category 
	chartCategoryIFinder() {
		
		var uniqueCategories;
		
		if (this.OperationMode==="Hist"){
			const uniqueCategoriesI=this.uniqueCategories;
			uniqueCategories=uniqueCategoriesI;
		}
		else if (this.OperationMode==="RealTime"){
			const uniqueCategoriesI=this.uniqueCategoriesRT;
			uniqueCategories=uniqueCategoriesI;
		}				
		
        // Find the category entry where the current chartID is included in the chartIDs array
        const categoryEntry = uniqueCategories.find(category => category.chartIDs.includes(this.chartConfigI.chartID));
        
        // Return the categories array if an entry is found, otherwise return null or an empty array
        return categoryEntry ? categoryEntry: null;
    }
  
	//Data Processing Handling
	dataProcessingHandling(){
	
		this.DCNotfier.dgConsole("------------Processing Type------------")
		this.DCNotfier.dgConsole(this.chartConfigI.dataProcessingType);
		
		switch (this.chartConfigI.dataProcessingType) {
			case "Simple-None": //No change
				this.DCNotfier.dgConsole("Not changed");
				if (this.chartConfigI.elementType === "Chart") {
					if (this.OperationMode === "Hist") {
						return {ProcessedData:this.partialDashboardDataI.Values};
					}
					else if (this.OperationMode === "RealTime") {
						let ProcessedDataI=this.informationRTI.LastDataPointRT.map(DataPointRT=>DataPointRT.Value)
						return {ProcessedData:ProcessedDataI};
					}
				}
				else if (this.chartConfigI.elementType === "Table"){
					this.DCNotfier.dgConsole("Simple-None Table")
					return this.SimpleNoneTableProcessing();
				}
				break;	
			case "SinglePoint-LastValue": 	//Use Last Value
				this.DCNotfier.dgConsole("Last Value")
				return this.SinglePoint_lastValue(this.partialDashboardDataI);
				break;	
			case "SinglePoint-FirstValue": 	//Use Last Value
				this.DCNotfier.dgConsole("First Value")
				return this.SinglePoint_firstValue(this.partialDashboardDataI);
				break;
			case "SinglePoint-Max": 	//Use Last Value
				this.DCNotfier.dgConsole("Single Point Max")
				return this.SinglePoint_Max(this.rawDataI);
				break;
			case "SinglePoint-Min": 	//Use Last Value
				this.DCNotfier.dgConsole("Single Point Min")
				return this.SinglePoint_Min(this.rawDataI);
				break;
			case "Interval-Addition": 	//Add all the elements within intervals	
				this.DCNotfier.dgConsole("Adding Intervals")
				return this.Interval_Addition(this.partialDashboardDataI,this.chartCategoriesI.chartCategory.intervals);
				break;
			case "Interval-CountChanges":  //Count Number of Changes
				this.DCNotfier.dgConsole("Counting Changes")
				return this.Interval_ChangesCounter(this.partialDashboardDataI,this.chartCategoriesI.chartCategory.intervals);
				break;
			case "Interval-CountTimeOn":  //Count Number of Changes
				this.DCNotfier.dgConsole("Count Time On")
				return this.Interval_CountTimeOn(this.partialDashboardDataI,this.chartCategoriesI.chartCategory.intervals);
				break;
			case "Interval-Difference": 	//Add all the elements	
				this.DCNotfier.dgConsole("Interval Difference");
				return this.Interval_Difference(this.partialDashboardDataI,this.chartCategoriesI.chartCategory.intervals);
				break;
			case "Interval-Integration":  //Integrate Data
				this.DCNotfier.dgConsole("Integrated Data")
				return this.Interval_Integration(this.partialDashboardDataI,this.chartCategoriesI.chartCategory.intervals);
				break;	
			case "Interval-Average":  //Interval Average
				this.DCNotfier.dgConsole("Interval Average Data")
				return this.Interval_Average(this.partialDashboardDataI,this.chartCategoriesI.chartCategory.intervals);
				break;		
			case "Interval-Histogram": 	//Use Histogram Calculatio
				this.DCNotfier.dgConsole("Interval-Histogram")
				return this.Interval_Histogram(this.partialDashboardDataI,this.chartCategoriesI.chartCategory.categories);
				break;	
			case "FullRange-Addition": 	//Add all the elements	
				this.DCNotfier.dgConsole("Simple Addition")
				return this.FullRange_Addition(this.partialDashboardDataI);
				break;
			case "FullRange-Average": 	//Add all the elements	
				this.DCNotfier.dgConsole("FullRange Average")
				return this.FullRange_Average(this.partialDashboardDataI);
				break;				
			case "FullRange-Difference": 	//Add all the elements	
				this.DCNotfier.dgConsole("Interval Difference")
				return this.FullRange_Difference(this.partialDashboardDataI);
				break;																		
			case "FullRange-OEEProductivity": 	//OEE Productivity
				this.DCNotfier.dgConsole("OEE Productivity")
				return this.FullRange_OEEProductivity(this.partialDashboardDataI);
				break;	
			case "FullRange-OEEAvailability": 	//OEE Productivity
				this.DCNotfier.dgConsole("OEE Availability")
				return this.FullRange_OEEAvailability(this.partialDashboardDataI, this.chartCategoriesI.chartCategory.intervals);
				break;																
			default: //No processing done
				this.DCNotfier.dgConsole("No processing done")
				return {ProcessedData:this.partialDashboardDataI.Values};
				break;
		}
	
	}
	
	//Creating Process Data Structure
	createProcessedDataStruct() {
	
	//Create structure based on if it has limits or not
	if(this.limitAnalysisEnabledI)
		{
			return {processedDataI:this.processedDataII.ProcessedData,
								 chartCategories:this.chartCategoriesI.chartCategory.categories,
								 LimitDashboardData:this.LimitDashboardDataI,
								 tooltipInfo:this.TooltipDashboardDataI,
								 informationRT: this.DataInfoRTI,
								 processedNode:this.nodeI
								 }
		}
		else{
			return {processedDataI:this.processedDataII.ProcessedData,
								 chartCategories:this.chartCategoriesI.chartCategory.categories,
								 informationRT: this.DataInfoRTI,
								 tooltipInfo:this.TooltipDashboardDataI,
								 processedNode:this.nodeI
								 }
		}  
	}
		
	//----------Optimization Functions---------------------//
	//--------------------------------------------------//
	
	
	// Method to reduce data as needed
	dataReductor() {
        try {
            this.DCNotfier.dgConsole("----------Reducing Data--------------");
            let reducedData = { Values: [], status: [], timestamps: [] };
			if (this.rawDataI != undefined) {
				if (this.OperationMode === "Hist") {
					const step = this.rawDataI.DataSize > this.chartConfigI.dataReductionMaxSize ? Math.ceil(this.rawDataI.DataSize / this.chartConfigI.dataReductionMaxSize) : 0;
					this.reductionStepSizeI=step;
					
					//Reduction needed
					if (this.chartConfigI.dataReductionEnable === true && step > 0) {
						// Reduce the data to MaxSize by removing elements
						for (let i = 0; i < this.rawDataI.Values.length; i += step) {
							reducedData.Values.push(this.rawDataI.Values[i]);
							reducedData.status.push(this.rawDataI.status[i]);
							reducedData.timestamps.push(this.rawDataI.timestamps[i]);
	
							// Track the iterations needed for the next step
							this.iterationsBeforeNextStep = i + step - this.rawDataI.Values.length;        
						}                   
						this.reductionExcecutedI = true;
						// Update DataSize for both objects
						reducedData.DataSize = reducedData.Values.length;                    
					}               
					else {
						this.reductionExcecutedI = false;
						reducedData = this.rawDataI;
					}				      
				} else if (this.OperationMode === "RealTime") {
					if (this.chartConfigI.dataReductionEnable === true) {
						let reductionStepSize = this.informationRTI.ReduceInfo.reductionStepSize;
						let reductionIterationsBeforeNextStepRT = this.informationRTI.ReduceInfo.reductionIterationsBeforeNextStepRT;
						
						if (this.informationRTI.ReduceInfo.reductionStepSize<=0){
								this.informationRTI.LastDataPointRT.forEach(dataPoint => {
								reducedData.Values.push(dataPoint.Value);
								reducedData.status.push(dataPoint.status);
								reducedData.timestamps.push(dataPoint.timestamps)
							});
						}
						else{
							this.informationRTI.LastDataPointRT.forEach(dataPoint => {
								if (reductionIterationsBeforeNextStepRT === 0) {
									reducedData.Values.push(dataPoint.Value);
									reducedData.status.push(dataPoint.status);
									reducedData.timestamps.push(dataPoint.timestamps);
			
									reductionIterationsBeforeNextStepRT = reductionStepSize;
								} else {
									reductionIterationsBeforeNextStepRT--;
								}
							});
						}
		
						this.iterationsBeforeNextStep = reductionIterationsBeforeNextStepRT;
	
						this.reductionExcecutedI = true;
						reducedData.DataSize = reducedData.Values.length;
					}
					//Reduction Disabled
					else{
						this.reductionExcecutedI = false;
						reducedData = this.informationRTI.LastDataPointRT;            
					}
				}
            }

            //this.DCNotfier.dgConsole({reducedData});
            this.DCNotfier.dgConsole("Iterations before next step: ", this.iterationsBeforeNextStep);

            return { reducedData};
        } catch (error) {
            console.error("Error reducing data: ", error);
            console.error(error.message);
            return { reducedData: {}, filteredData: [] }; // Return empty objects or handle the error as needed
        }
    }
    
    tableCategoryProcessor(categoriesData) {
    
    try {
        this.DCNotfier.dgConsole("----------Processing Table Categories--------------");
        this.DCNotfier.dgConsole(this.uniqueCategoriesConfigI.categoryConfig);
		this.DCNotfier.dgConsole(this.uniqueCategoriesConfigI.categoryConfig.dataReductionEnable);
        if (this.uniqueCategoriesConfigI.categoryConfig.dataReductionEnable === true) {
			this.DCNotfier.dgConsole("----------Redudcing categories---------");
            const maxSize = this.uniqueCategoriesConfigI.categoryConfig.dataReductionMaxSize;
            const categories = categoriesData[0].categories;
            const chartNode = categoriesData[0].chartNode;

            // Calculate the step size for reduction
            const step = categories.length > maxSize ? Math.ceil(categories.length / maxSize) : 0;
            let reducedCategories = [];
            let reducedChartNode = chartNode; // Assuming chartNode remains the same

            if (step > 0) {
                // Reduce the categories array
                for (let i = 0; i < categories.length; i += step) {
                    reducedCategories.push(categories[i]);
                }
                this.DCNotfier.dgConsole("Categories reduced from", categories.length, "to", reducedCategories.length);
            } else {
                // No reduction needed
                reducedCategories = categories;
            }

            // Return the reduced data
            return { categories: reducedCategories, chartNode: reducedChartNode };

        } else {
            // Data reduction not enabled, return original data
            return categoriesData;
        }
    } catch (error) {
        console.error("Error in tableCategoryProcessor: ", error);
        console.error(error.message);
        return { categories: [], chartNode: [] };
    }
	}
    
    //----------Limit Functions---------------------//
	//--------------------------------------------------//
	
	//Limit Calculator Handling
	limitCalculator(){
	
		 //Determine If Analysis is Enabled
		this.limitAnalysisEnabledI = this.chartConfigI.dataoutOfLimitEnable==true && (this.chartConfigI.dataMaxLimit.length >0 || this.chartConfigI.dataMinLimit.length >0) ;
		
		let filteredData;
		
		if (this.limitAnalysisEnabledI ){
		
			//For Data processing Simple-None
			if(this.chartConfigI.dataProcessingType.includes("Simple")){
				filteredData=this.limitCalculatorAllData().filteredData;
			}
			else if(this.chartConfigI.dataProcessingType.includes("Interval")){
				filteredData=this.limitCalculatorInterval().filteredData;
			}
			else if(this.chartConfigI.dataProcessingType.includes("SinglePoint")||this.chartConfigI.dataProcessingType.includes("FullRange")){
				filteredData=this.limitCalculatorSingleElement().filteredData;
			}
		}
		else{
			let filteredData = {"Enabled":this.limitAnalysisEnabledI};
		} 
		 return {filteredData};		
	}
    
    //Limit Calculator for All Data
    limitCalculatorAllData(){       

		 let filteredData = { Values: [], status: [], timestamps: [] };

		 if (this.OperationMode === "Hist") {
			
				// Filter data by MaxValue and MinValue
				for (let i = 0; i < this.rawDataI.Values.length; i++) {
					if ((this.chartConfigI.dataMaxLimit.length >0 && this.rawDataI.Values[i] > this.chartConfigI.dataMaxLimit) || (this.chartConfigI.dataMinLimit.length >0 && this.rawDataI.Values[i] < this.chartConfigI.dataMinLimit)) {
														
						filteredData.Values.push(this.rawDataI.Values[i]);
						filteredData.status.push(this.rawDataI.status[i]);
						filteredData.timestamps.push(this.rawDataI.timestamps[i]);
					}
				}
				filteredData.Enabled = this.limitAnalysisEnabledI;
				filteredData.DataSize = filteredData.Values.length;
			}
		
		else if (this.OperationMode === "RealTime") {       

			this.informationRTI.LastDataPointRT.forEach((dataPoint,i) => {
				if ((this.chartConfigI.dataMaxLimit.length >0 && dataPoint.Value> this.chartConfigI.dataMaxLimit) || (this.chartConfigI.dataMinLimit.length >0 &&  dataPoint.Value < this.chartConfigI.dataMinLimit)) {
					filteredData.Values.push(dataPoint.Value);
					filteredData.status.push(dataPoint.status);
					filteredData.timestamps.push(dataPoint.timestamps);
				}
			});
			
			filteredData.DataSize = filteredData.Values.length;			
			filteredData.Enabled = this.limitAnalysisEnabledI;	 	
		}			
	

		 return {filteredData};
    }
    
    // Limit Calculator for Intervals
    limitCalculatorInterval() {
        let filteredData = { Values: [] };
        
		// Iterate through processedDataII.ProcessedData and check limits
		this.processedDataII.ProcessedData.forEach((value, i) => {
			if (value !== null) {
				if ((this.chartConfigI.dataMaxLimit.length > 0 && value >= this.chartConfigI.dataMaxLimit) || 
					(this.chartConfigI.dataMinLimit.length > 0 && value <= this.chartConfigI.dataMinLimit)) {
					filteredData.Values.push(1);
				} else {
					filteredData.Values.push(0);
				}
			} else {
				filteredData.Values.push(null);
			}
		});

		// Add additional attributes
		filteredData.Enabled = this.limitAnalysisEnabledI;
		filteredData.DataSize = filteredData.Values.length;
			
        return { filteredData };
    }
    
    // Limit Calculator for Intervals
    limitCalculatorSingleElement() {
        let filteredData = { Values: [] };
        
		// Iterate through processedDataII.ProcessedData and check limits
		this.processedDataII.ProcessedData.forEach((value, i) => {
			if (value !== null) {
				if ((this.chartConfigI.dataMaxLimit.length > 0 && value >= this.chartConfigI.dataMaxLimit) || 
					(this.chartConfigI.dataMinLimit.length > 0 && value <= this.chartConfigI.dataMinLimit)) {
					filteredData.Values.push(1);
				} else {
					filteredData.Values.push(0);
				}
			} else {
				filteredData.Values.push(null);
			}
		});

		// Add additional attributes
		filteredData.Enabled = this.limitAnalysisEnabledI;
		filteredData.DataSize = filteredData.Values.length;
			
        return { filteredData };
    }

	//----------Interval/Category Functions--------------//
	//--------------------------------------------------//
	
	//Find all unique categories
	uniqueChartCategoriesFinder() {
        const categoriesMap = new Map();
        const isRealTimeMode = this.OperationMode === "RealTime";

        // Analyze each chart configuration and group by unique category settings
        this.dataRequest.chartsConfig.forEach(chartConfig => {
            const {
				chartType,
				elementType,
                categoryType,
                categoryRound,
                categorCustomValue,
                dataReductionEnable,
                dataReductionMaxSize,
                categoryCustomIntervalLength,
                categoryCustomIntervalUnit,
                categoryTimeOffset,
                specialParameters,
                chartID
            } = chartConfig;

            // Find the nodes associated with the chartID
            const chartNodes = this.dataRequest.chartsNodes.find(chart => chart.chartID === chartID)?.chartNodes || [];

            // Find the corresponding informationRT for the chartID if in RealTime mode
            const informationRT = isRealTimeMode 
                ? this.dataRequest.updateRequest.find(update => update.chartID === chartID)?.informationRT || [] 
                : [];

            // Create a key for the category configuration including the nodes (and informationRT if in RealTime mode)
            const categoryKey = JSON.stringify({
				chartType,
				elementType,
                categoryType,
                categoryRound,
                categorCustomValue,
                dataReductionEnable,
                dataReductionMaxSize,
                categoryCustomIntervalLength,
                categoryCustomIntervalUnit,
                categoryTimeOffset,
                specialParameters,
                chartNodes,  // Include nodes in the category key
                ...(isRealTimeMode && { informationRT })  // Conditionally include informationRT in the category key
            });

            if (categoriesMap.has(categoryKey)) {
                categoriesMap.get(categoryKey).chartIDs.push(chartID);
            } else {
                categoriesMap.set(categoryKey, {
                    categoryConfig: {
						chartType,
						elementType,
                        categoryType,
                        categoryRound,
                        categorCustomValue,
                        dataReductionEnable,
						dataReductionMaxSize,
                        categoryCustomIntervalLength,
                        categoryCustomIntervalUnit,
                        categoryTimeOffset,
                        specialParameters,
                        chartNodes,  // Include nodes in the category configuration
                        ...(isRealTimeMode && { informationRT })  // Conditionally include informationRT in the category configuration
                    },
                    chartIDs: [chartID]
                });
            }
        });

        // Convert the map to an array of category configurations
        return Array.from(categoriesMap.values());
    }
	
	//Create All Unique Categories
	uniqueCategoriesCreator() {
	
		this.DCNotfier.dgConsole("----------Creating Categories--------")
		return this.uniqueCategoriesConfig.map(config => {
			
			//Update Current Category Config
			this.uniqueCategoriesConfigI=config;			
			
			//Create Specific Interval
			this.intervalLengthI= this.intevalLengthcreator();
			
			this.DCNotfier.dgConsole("-----------This Interval Length----------");
			this.DCNotfier.dgConsole(this.intervalLengthI);
			
			let chartCategory;
			var intervalInfo;
			
			switch (config.categoryConfig.categoryType) {
				case "AllData-DateTime":  // DateTime
					if(config.categoryConfig.elementType=="Chart"){
						chartCategory=this.allDataCategoryCreator();
						intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime, newInterval:this.newIntervalI};
					}
					else if(config.categoryConfig.elementType=="Table"){
						chartCategory=this.allDataTableCategoryCreator();
						intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime, newInterval:this.newIntervalI};
					}					
					break;
				case "Interval-Dynamic": //Dynamic					
					chartCategory = this.intervalCategoryCreator();
					var intervalInfoI=chartCategory.intervals[chartCategory.intervals.length-1];
					intervalInfo={start:intervalInfoI.start,end:intervalInfoI.end, newInterval:this.newIntervalI};
					break;
				case "Interval-CustomInterval": //Custom Interval
					chartCategory = this.intervalCategoryCreator();
					var intervalInfoI=chartCategory.intervals[chartCategory.intervals.length-1];
					intervalInfo={start:intervalInfoI.start,end:intervalInfoI.end, newInterval:this.newIntervalI};				
					break;
				case "Interval-CustomText": //Custom 
					chartCategory = {categories:config.categoryConfig.categorCustomValue};
					intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime,newInterval:this.newIntervalI};
					break;
				case "Interval-Histogram":  // Histogram
				    chartCategory = this.histogramCategoryCreator();
				    intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime,newInterval:this.newIntervalI};
				    break;
				case "Single-Simple":  // Simple
					if(config.categoryConfig.elementType=="Chart"){
						if(config.categoryConfig.chartType=="Column"){
							
							chartCategory= { categories: [this.getCategory(this.timeRange,new Date(this.dataRequest.updateRequest[0].initialTime))+" - "+ this.getCategory(this.timeRange,new Date(this.dataRequest.updateRequest[0].finalTime))] };
							intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime,newInterval:this.newIntervalI};
						}
						else{
							chartCategory= { categories: [] };
							intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime,newInterval:this.newIntervalI};
						}
				    }
				    else if(config.categoryConfig.elementType=="Table"){
						chartCategory= { categories: [] };
						intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime, newInterval:this.newIntervalI};
					}
					else{
						chartCategory= { categories: [] };
						intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime, newInterval:this.newIntervalI};
					}		    
				    break;
				default:
					// Handle other types or do nothing if not applicable
					chartCategory = { categories: [] };
					intervalInfo={start:this.dataRequest.updateRequest[0].initialTime,end:this.dataRequest.updateRequest[0].finalTime,newInterval:this.newIntervalI};
					break;
			}
			
			//Add Interval Length
			intervalInfo["intervalLength"]=this.intervalLengthI;
			
			if (chartCategory) {
				return {
					chartCategory,
					intervalInfo: intervalInfo,
					chartIDs: config.chartIDs
				};
			}
		}).filter(entry => entry !== undefined); // Filter out any undefined entries due to unsupported category types
	}
	
	//Update Category If reduction
    updateChartCategory() {
		if (this.reductionExcecutedI) {
			// Iterate over the categories to find the matching chartNode
			this.chartCategoriesI.chartCategory.categories.forEach(category => {
				if (this.chartConfigI.elementType === "Chart") {
					if (category.chartNode === this.nodeI) {
						category.categories = this.partialDashboardDataI.timestamps;
						this.DCNotfier.dgConsole(`Chart categories for node ${this.nodeI} updated successfully`);
					}
				}
				else if(this.chartConfigI.elementType === "Table") {
					
				}
			}); 
		}
		else {
			this.DCNotfier.dgConsole("Reduction not executed. Chart categories not updated.");
		}
		
	}
		
	//Method to create interval length
	intevalLengthcreator(){			
		
		
		//Dynamic Interval Length	
		if(this.uniqueCategoriesConfigI.categoryConfig.categoryType=="Interval-Dynamic")	{	
			if (this.timeRange <= ONE_MINUTE) {
				return 5 * 1000; // 5 seconds
			} else if (this.timeRange <= HALF_HOUR) {
				return ONE_MINUTE;
			} else if (this.timeRange <= ONE_HOUR) {
				return 5 * ONE_MINUTE;
			} else if (this.timeRange <= ONE_DAY) {
				return ONE_HOUR;
			} else if (this.timeRange <= 31 * ONE_DAY) { // Assuming an average month length
				return ONE_DAY;
			} else if (this.timeRange <= 365 * ONE_DAY) { // Assuming an average year length
				return 'month'; // Dynamic handling for months
			} else {
				return 'year'; // Dynamic handling for years
			}
		}
		
		// Custom Interval Length
		else if(this.uniqueCategoriesConfigI.categoryConfig.categoryType=="Interval-CustomInterval")	{
			const { categoryCustomIntervalLength, categoryCustomIntervalUnit } = this.uniqueCategoriesConfigI.categoryConfig;
			switch (categoryCustomIntervalUnit) {
				case 's':   // seconds
					return categoryCustomIntervalLength * 1000;
					break;
				case 'min': // minutes
					return categoryCustomIntervalLength * 60 * 1000;
					break;
				case 'h':   // hours
					return categoryCustomIntervalLength * 3600 * 1000;
					break;
				case 'day':   // day
					return categoryCustomIntervalLength * 24 * 3600 * 1000;
					break;
				case 'month':   // month
					return categoryCustomIntervalLength * 30 * 24 * 3600 * 1000;
				break;
				default:
					throw new Error('Unsupported interval unit');
			}
		}
		
		//DateTime Interval Length	
		else if(this.uniqueCategoriesConfigI.categoryConfig.categoryType=="AllData-DateTime")	{	
			return this.timeRange; 
		}	
		
		else{	
			return this.timeRange; 
		}	
	}	
	
	//Creates Time Offset
	categoryTimeOffsetCreator() {
		// Read the current unit and offset from the config
		const intervalUnit = this.uniqueCategoriesConfigI.categoryConfig.categoryCustomIntervalUnit;
		const timeOffset = parseInt(this.uniqueCategoriesConfigI.categoryConfig.categoryTimeOffset);
		this.DCNotfier.dgConsole("intervalUnit: "+intervalUnit)
		// Determine the offset unit based on the interval unit
		let offsetUnitMilliseconds;
		switch (intervalUnit) {
			case 's':   // Seconds
				offsetUnitMilliseconds = 1000; // 1 second = 1000 milliseconds
				break;
			case 'min': // Minutes
				offsetUnitMilliseconds = 1000; // 1 minute = 60,000 milliseconds
				break;
			case 'h':   // Hours
				offsetUnitMilliseconds = 1000 * 60; // 1 minute = 60,000 milliseconds
				break;
			case 'day':   // Days
				offsetUnitMilliseconds = 1000 * 60 * 60; // 1 hour = 3,600,000 milliseconds
				break;
			case 'month':   // Months
				offsetUnitMilliseconds = 1000 * 60 * 60 * 24; // 1 day = 86,400,000 milliseconds
			break;
			default:
				throw new Error('Unsupported interval unit');
		}
	
		// Calculate the time offset in milliseconds
		return timeOffset * offsetUnitMilliseconds;
	}
	
	//IntervalLength in Millis
	getIntervalLengthInMillis(timestamp) {
		if (typeof this.intervalLengthI === 'number') {
			return this.intervalLengthI;
		} else if (this.intervalLengthI === 'month') {
			let date = new Date(timestamp);
			let monthLater = new Date(date.getFullYear(), date.getMonth() + 1, date.getDate());
			return monthLater - timestamp;
		} else if (this.intervalLengthI === 'year') {
			let date = new Date(timestamp);
			let yearLater = new Date(date.getFullYear() + 1, date.getMonth(), date.getDate());
			return yearLater - timestamp;
		}
		return 0; // Default fallback if intervalLength is not properly set
	}
	
	//Get Category String
	getCategory(timeRange, num) {
		if (timeRange <= ONE_DAY) {
			return (new Date(num)).toTimeString().split(' ')[0];
		} else if (timeRange <= 31 * ONE_DAY) {
			return (new Date(num)).toDateString().split(' ').slice(1).join(' ');
		} else if (timeRange <= 365 * ONE_DAY) {
			let parts = (new Date(num)).toDateString().split(' ');
			return `${parts[1]} ${parts[3]}`;
		} else {
			return (new Date(num)).getFullYear().toString();
		}
	}	
	
	//All Data Category
	allDataCategoryCreator() {
		const { categoryConfig } = this.uniqueCategoriesConfigI;
		const { chartNodes } = categoryConfig;
		const categoriesData = [];
	
		chartNodes.forEach(node => {
			const rawDataNode = this.rawData.find(data => data.Nodeaddress === node);
	
			if (rawDataNode) {
				categoriesData.push({
					chartNode: node,
					categories: rawDataNode.timestamps
				});
			}
		});
	
		return {categories:categoriesData};
	}
	
	//All Data for Tables
		
	allDataTableCategoryCreator() {
		const { categoryConfig } = this.uniqueCategoriesConfigI;
		const allNodes = this.rawData.map(data => data.Nodeaddress); // Extract all Nodeaddresses
		let categoriesData = [];
	
		// Use a Set to efficiently store unique timestamps
		const uniqueTimestamps = new Set();
	
		// Determine the CategorySource
		if (categoryConfig.specialParameters.TableConfig.CategorySource === 'Input-AllInputs') {
			this.DCNotfier.dgConsole("------Input-AllInputs----");
			// Collect timestamps and add them directly to the Set for uniqueness
			this.rawData.forEach(data => {
				data.timestamps.forEach(timestamp => uniqueTimestamps.add(timestamp));
			});
	
			// Convert the Set to an array and sort it only once
			const allTimestampsClean = [...uniqueTimestamps].sort((a, b) => a - b);
	
			// Create the final object with allNodes and clean timestamps
			categoriesData.push({
				chartNode: allNodes,
				categories: allTimestampsClean
			});
	
		} else if (categoryConfig.specialParameters.TableConfig.CategorySource === 'Input-LeadingInput') {
			this.DCNotfier.dgConsole("------Input-LeadingInput----");
			// Get the CategoryLeadingInput
			const leadingInputNode = categoryConfig.specialParameters.TableConfig.CategoryLeadingInput;
	
			// Find the rawData object that corresponds to the leadingInputNode
			const leadingData = this.rawData.find(data => data.Nodeaddress === leadingInputNode);
	
			// If we find the data, use its timestamps
			if (leadingData) {
				leadingData.timestamps.forEach(timestamp => uniqueTimestamps.add(timestamp));
	
				// Convert the Set to an array and sort it once
				const leadingTimestampsClean = [...uniqueTimestamps].sort((a, b) => a - b);
	
				// Create the final object with allNodes and clean timestamps
				categoriesData.push({
					chartNode: allNodes,
					categories: leadingTimestampsClean
				});
			} else {
				console.error(`No data found for leading input node: ${leadingInputNode}`);
			}
		}
		this.DCNotfier.dgConsole("Partial Categories Before Reduction");
		this.DCNotfier.dgConsole("Length: "+categoriesData[0].categories.length);
		this.DCNotfier.dgConsole(categoriesData);
		return { categories: [this.tableCategoryProcessor(categoriesData)]};
	}
	
	//Category Creator	
	intervalCategoryCreator() {

		var Initial_Time=(new Date(this.dataRequest.updateRequest[0].initialTime)).getTime();
		var Final_Time=(new Date(this.dataRequest.updateRequest[0].finalTime)).getTime();
		
		const intervals = [];
		const categories = [];
	
		// Apply rounding if category rounding is enabled
		if (this.uniqueCategoriesConfigI.categoryConfig.categoryRound=== "true") {
			Initial_Time = this.roundDate(Initial_Time,"down").getTime();
		}
		this.DCNotfier.dgConsole("Raw Offset")
		this.DCNotfier.dgConsole(this.uniqueCategoriesConfigI.categoryConfig.categoryTimeOffset);
		//Apply Offset
		if (this.uniqueCategoriesConfigI.categoryConfig.categoryTimeOffset>0 && this.uniqueCategoriesConfigI.categoryConfig.categoryType=="Interval-CustomInterval") {
			this.categoryTimeOffsetI=this.categoryTimeOffsetCreator();
			this.DCNotfier.dgConsole("------------Category Time Offset------------");
			this.DCNotfier.dgConsole(this.categoryTimeOffsetI);
			
			Initial_Time = Initial_Time+this.categoryTimeOffsetI;
		}
		
		let currentTime = new Date(Initial_Time);
		
		while (currentTime.getTime() < Final_Time) {
			let currentEndTime = new Date(currentTime);
	
			if (typeof this.intervalLengthI === 'number') {
				currentEndTime = new Date(currentTime.getTime() + this.intervalLengthI);
			} else if (this.intervalLengthI=== 'month') {
				currentEndTime.setMonth(currentEndTime.getMonth() + 1);
			} else if (this.intervalLengthI === 'year') {
				currentEndTime.setFullYear(currentEndTime.getFullYear() + 1);
			}
	
			// Make sure we don't exceed Final_Time in our last interval
			if (currentEndTime.getTime() > Final_Time) {
				currentEndTime = new Date(Final_Time);
			}
	
			intervals.push({ start: currentTime.getTime(), end: currentEndTime.getTime() });
			categories.push(this.getCategory(this.timeRange, currentTime.getTime()));
	
			// Prepare for the next iteration
			currentTime = currentEndTime;
		}
	
		// Correct the last category if necessary to ensure it represents the end time accurately
		if (categories.length > 0) {
			categories[categories.length - 1] = this.getCategory(this.timeRange, Final_Time);
		}
		return { intervals, categories };
	}      
		
	//Ceates Histogram Category
	histogramCategoryCreator() {
		const { categoryConfig } = this.uniqueCategoriesConfigI;
		const firstNode = categoryConfig.chartNodes[0];
	
		// Find the raw data for the first node
		const rawData = this.rawData.find(data => data.Nodeaddress === firstNode);
	
		if (!rawData) {
			throw new Error(`No raw data found for node ${firstNode}`);
		}
	
		const n = rawData.Values.length;
		const sortedData = rawData.Values.slice().sort((a, b) => a - b); // Copy and sort data
		const q1 = sortedData[Math.floor(n / 4)];
		const q3 = sortedData[Math.floor(3 * n / 4)];
		const iqr = q3 - q1; // Interquartile range
		let binSize;
		let numBins=categoryConfig.specialParameters.HistogramNumberBins; /*this.chartConfigI.specialParameters.HistogramNumberBins;*/ // Get the number of bins from the config if provided
	
		if (numBins === undefined||numBins === null||numBins.length<=0) { // Only if it is not specified
			// Use Freedman-Diaconis Rule to determine bin size if possible
			if (iqr > 0) { // Avoid division by zero in IQR calculations
				binSize = 2 * (iqr / Math.cbrt(n));
				numBins = Math.ceil((sortedData[n - 1] - sortedData[0]) / binSize);
			} else {
				// Fallback to Sturges' formula if IQR is 0
				numBins = Math.ceil(Math.log2(n) + 1);
				binSize = (sortedData[n - 1] - sortedData[0]) / numBins;
			}
		} else {
			// Calculate binSize based on the specified number of bins
			const minData = sortedData[0];
			const maxData = sortedData[sortedData.length - 1];
			binSize = (maxData - minData) / numBins;
		}
	
		const minData = sortedData[0];
		const categories = [];
	
		for (let i = 0; i < numBins; i++) {
			const binMin = minData + i * binSize;
			const binMax = minData + (i + 1) * binSize;
			// Create a string representation for each category/bin
			categories.push(`${binMin.toFixed(2)}-${binMax.toFixed(2)}`);
		}
		
		//Safe for further analisis
		this.HistInfoRTI["categories"]= categories.map(str => str.replace(/ /g, ''));
		this.HistInfoRTI["BinSize"]=binSize;
		
		return { categories: categories };
	}
	
	
	//-------------------Tooltip Functions--------------//
	//--------------------------------------------------//
	
	tooltipInfoCreator(){
	
		let tooltipInfo;
		var intervalInfo=this.chartCategoriesI.intervalInfo;

		
		if(this.chartConfigI.elementType=="Chart"){
			
			//Simple Processing type
			if(this.chartConfigI.dataProcessingType.includes("Simple")) {
				tooltipInfo="";			
			}
			//SinglePoint Processing type
			else if(this.chartConfigI.dataProcessingType.includes("SinglePoint")) {
				tooltipInfo=this.formatTimestampToDateTime(this.relevantTimestampII);		
			}
			//Interval Processing type
			else if(this.chartConfigI.dataProcessingType.includes("Interval")) {
				if (this.updateRequestI.OperationMode === "Hist") {
					if (this.chartConfigI.dataProcessingType!="Interval-Histogram"){
						tooltipInfo = this.chartCategoriesI.chartCategory.intervals.map(interval => ({
						  start: this.formatTimestampToDateTime(interval.start),
						  end: this.formatTimestampToDateTime(interval.end)
						}));
					}		
					else{
						tooltipInfo="";
					}
				}
				else if (this.updateRequestI.OperationMode === "RealTime") {
					if (this.chartConfigI.dataProcessingType!="Interval-Histogram"){
						var interval=this.chartCategoriesI.chartCategory.intervals[0];
						tooltipInfo={
									start:this.formatTimestampToDateTime(interval.start),
									end:this.formatTimestampToDateTime(interval.end)
									};
						}
					else{
						tooltipInfo="";
					}
				}
			}
			//FullRange Processing type
			else if(this.chartConfigI.dataProcessingType.includes("FullRange")) {
				if (this.updateRequestI.OperationMode === "Hist") {
					tooltipInfo={start:this.formatTimestampToDateTime(new Date(intervalInfo.start)),
							 end:this.formatTimestampToDateTime(new Date(intervalInfo.end))};
							 
					this.relevantTimestampII=new Date(intervalInfo.start).getTime();
				}
				else if (this.updateRequestI.OperationMode === "RealTime") {
					tooltipInfo={start:this.formatTimestampToDateTime(this.informationRTI.LastRelevantTimestamp),
							 end:this.formatTimestampToDateTime(new Date(intervalInfo.end))};
					this.relevantTimestampII=new Date(this.informationRTI.LastRelevantTimestamp).getTime();
				}
							
			}
			//Any other
			else {
				tooltipInfo="";			
			}
		
		return {tooltipInfo:tooltipInfo, name:this.nodeI}
		}
	
	}
	
	
	
	//---------------RT Processing Functions----------------//
	//--------------------------------------------------//
	
		
	
	//Create Categories for RT
	uniqueCategoriesCreatorRT() {
        this.DCNotfier.dgConsole("----------Creating Categories for RT--------");

        return this.uniqueCategoriesConfigRT.map(config => {
        
            // Update Current Category Config
            this.uniqueCategoriesConfigI = config;

            let chartCategory;
            let intervalInfo = config.categoryConfig.informationRT[0].IntervalInfo;
            
            // Create Specific Interval
            this.intervalLengthI =intervalInfo.intervalLength;
            this.DCNotfier.dgConsole("-----------This Interval Length----------");
            this.DCNotfier.dgConsole(this.intervalLengthI);
            
            switch (config.categoryConfig.categoryType) {
                case "AllData-DateTime":  // DateTime
                    chartCategory = this.allDataCategoryCreatorRT();
                    intervalInfo = this.allDataIntervalInfoRT();
                    break;
                case "Interval-Dynamic": // Dynamic
                    chartCategory = this.intervalCategoryCreatorRT();
                    var intervalInfoI=chartCategory.intervals[0];
                    intervalInfo={start:intervalInfoI.start,end:intervalInfoI.end, newInterval:this.newIntervalI};
                    break;
                case "Interval-CustomInterval": // Custom Interval
                    chartCategory = this.intervalCategoryCreatorRT();
                    var intervalInfoI=chartCategory.intervals[0];
                    intervalInfo={start:intervalInfoI.start,end:intervalInfoI.end, newInterval:this.newIntervalI};
                    break;
                case "Interval-CustomText": // Custom
                    chartCategory = { categories: config.categoryConfig.categorCustomValue.split(',') };
                    intervalInfo = { start: intervalInfo.start, end: intervalInfo.end };
                    break;
                case "Interval-Histogram":  // Histogram
                    chartCategory = this.histogramCategoryCreatorRT();
                    intervalInfo = this.allDataIntervalInfoRT();
                    break;
                case "Single-Simple":  // Simple
					if(config.categoryConfig.elementType=="Chart"){
						if(config.categoryConfig.chartType=="Column"){
							const { informationRT } = this.uniqueCategoriesConfigI.categoryConfig;
							let highestTimestamp = 0;
							let correspondingIntervalInfo = null;
					
							// Find the highest timestamp and corresponding interval info
							informationRT.forEach(info => {
								info.LastDataPointRT.forEach(point => {
									if (point.timestamps > highestTimestamp) {
										highestTimestamp = point.timestamps;
										correspondingIntervalInfo = info.IntervalInfo;
									}
								});
							});
							
							chartCategory= { categories: [this.getCategory(this.timeRange,new Date(this.dataRequest.updateRequest[0].initialTime))+" - "+ this.getCategory(this.timeRange,new Date(highestTimestamp))] };
							intervalInfo=this.allDataIntervalInfoRT();
						}
						else{
							chartCategory = { categories: [] };
							intervalInfo = this.allDataIntervalInfoRT();
						}
				    }
                    
                    break;
                default:
                    // Handle other types or do nothing if not applicable
                    chartCategory = { categories: [] };
                    intervalInfo = this.allDataIntervalInfoRT();
                    break;
            }

            // Add Interval Length
            intervalInfo["intervalLength"] = this.intervalLengthI;

            return {
                chartCategory,
                intervalInfo: intervalInfo,
                chartIDs: config.chartIDs
            };
        }).filter(entry => entry !== undefined); // Filter out any undefined entries due to unsupported category types
    }
    
    //Creates Categories for allDataTypes
    allDataCategoryCreatorRT() {
        const { chartNodes, informationRT } = this.uniqueCategoriesConfigI.categoryConfig;
        const categoriesData = [];

        chartNodes.forEach(node => {
            const infoRTNode = informationRT.find(info => info.Node === node);

            if (infoRTNode) {
                categoriesData.push({
                    chartNode: node,
                    categories: infoRTNode.LastDataPointRT.map(point => point.timestamps)
                });
            }
        });

        return { categories: categoriesData };
    }
        
    //Calculate Interval Info 
    allDataIntervalInfoRT() {
        const { informationRT } = this.uniqueCategoriesConfigI.categoryConfig;
        let highestTimestamp = 0;

        informationRT.forEach(info => {
            info.LastDataPointRT.forEach(point => {
                if (point.timestamps > highestTimestamp) {
                    highestTimestamp = point.timestamps;
                }
            });
        });

        const intervalInfo = {
            start: highestTimestamp - this.intervalLengthI,
            end: highestTimestamp,
            newInterval:this.newIntervalI
        };

        return intervalInfo;
    }
    
    //Create Interval Category RT
    intervalCategoryCreatorRT() {
        const { informationRT } = this.uniqueCategoriesConfigI.categoryConfig;
        let highestTimestamp = 0;
        let correspondingIntervalInfo = null;

        // Find the highest timestamp and corresponding interval info
        informationRT.forEach(info => {
            info.LastDataPointRT.forEach(point => {
                if (point.timestamps > highestTimestamp) {
                    highestTimestamp = point.timestamps;
                    correspondingIntervalInfo = info.IntervalInfo;
                }
            });
        });

        if (!correspondingIntervalInfo) {
            throw new Error('No valid IntervalInfo found in informationRT');
        }

        let newIntervalI = false;
        const { start, intervalLength } = correspondingIntervalInfo;
        const calculatedStart = highestTimestamp - intervalLength;

        if (start +1000 < calculatedStart) {
            newIntervalI = true;
            this.newIntervalI=newIntervalI;
        }

        const intervals = newIntervalI
            ? [{ start: new Date(start).getTime() + intervalLength, end: highestTimestamp }]
            : [{ start: new Date(start).getTime(), end: highestTimestamp }];

        const categories = [this.getCategory(this.timeRange, highestTimestamp)];

        return { intervals, categories };
    }
    
    //Create Interval Category RT
    histogramCategoryCreatorRT() {
		this.DCNotfier.dgConsole("Creating Histogram Category RT");
		const { informationRT } = this.uniqueCategoriesConfigI.categoryConfig;
		const histInfo = informationRT[0].HistInfo;
		const { BinSize, categories } = histInfo;
	
		let newCategories = [...categories]; // Start with existing categories
		let initialTailAdded = false;
		let finalTailAdded = false;
	
		informationRT[0].LastDataPointRT.forEach(dataPoint => {
			let pointInBin = false;
	
			// Recalculate bins after each iteration
			let bins = newCategories.map(category => {
				const parts = category.split('-');
				return {
					min: parseFloat(parts[0]),
					max: parseFloat(parts[1])
				};
			});
	
			bins.forEach(bin => {
				if (dataPoint.Value >= bin.min && dataPoint.Value < bin.max) {
					pointInBin = true;
				}
			});
	
			if (!pointInBin) {
				// Add bins at the beginning until the data point fits into a bin
				while (dataPoint.Value < bins[0].min) {
					const initialTail = `${(bins[0].min - BinSize).toFixed(2)}-${bins[0].min.toFixed(2)}`;
					if (!newCategories.includes(initialTail)) {
						newCategories.unshift(initialTail);
						initialTailAdded = true;
					}
					// Recalculate bins to include the new initial tail
					bins = newCategories.map(category => {
						const parts = category.split('-');
						return {
							min: parseFloat(parts[0]),
							max: parseFloat(parts[1])
						};
					});
				}
	
				// Add bins at the end until the data point fits into a bin
				while (dataPoint.Value >= bins[bins.length - 1].max) {
					const finalTail = `${bins[bins.length - 1].max.toFixed(2)}-${(bins[bins.length - 1].max + BinSize).toFixed(2)}`;
					if (!newCategories.includes(finalTail)) {
						newCategories.push(finalTail);
						finalTailAdded = true;
					}
					// Recalculate bins to include the new final tail
					bins = newCategories.map(category => {
						const parts = category.split('-');
						return {
							min: parseFloat(parts[0]),
							max: parseFloat(parts[1])
						};
					});
					
				}
			}
		});
		
		this.HistInfoRTI["categories"]= newCategories.map(str => str.replace(/ /g, ''));
		this.HistInfoRTI["BinSize"]=BinSize;			
		
		if (initialTailAdded || finalTailAdded) {
			this.newIntervalI = true;
			return { categories: newCategories };
		}
	
		return { categories: categories.map(str => str.replace(/ /g, '')) };
	}
    	
	//Function to Create Data for RT
	dataInfoRTCreator() {
		try {
			// Handle All data Required
			let allDataRequired = false;
			
			if (this.chartConfigI.dataProcessingType === "SinglePoint-FirstValue") {
				allDataRequired = true;
			}		
			
			//Defined LastDataPointRaw based on Operation Mode
			var LastDataPointRaw;
			
			//Hist Mode
			if (this.updateRequestI.OperationMode==="Hist"){
				LastDataPointRaw={
					Value: this.rawDataI.Values[this.rawDataI.DataSize - 1],
					status: this.rawDataI.status[this.rawDataI.DataSize - 1],
					timestamps: this.rawDataI.timestamps[this.rawDataI.DataSize - 1]
				}
			
			}	
			//Real Time Mode
			else if (this.updateRequestI.OperationMode==="RealTime"){
				LastDataPointRaw=this.informationRTI.LastDataPointRT[this.informationRTI.LastDataPointRT.length - 1];
			}
			
			return {
				Node: this.nodeI,
				LastDataPointRT: 0,
				LastDataPointProcessed: this.processedDataII.ProcessedData[this.processedDataII.ProcessedData.length - 1],
				LastDataPointRaw:LastDataPointRaw,
				AllDataRequired: allDataRequired,
				IntervalInfo: this.chartCategoriesI.intervalInfo,
				ReduceInfo: {
					reductionStepSize: this.reductionStepSizeI,
					reductioniterationsBeforeNextStepRT: this.reductionreductioniterationsBeforeNextStepRTI
				},
				OEEInfo:this.OEEinfoRTI,
				HistInfo:this.HistInfoRTI,
				LastRelevantTimestamp:this.relevantTimestampII
			};
		} catch (error) {
			console.error("Error in dataInfoRTCreator: ", error.message);
			console.error(error.message);
			return null; // or handle the error appropriately
		}
	}
	
	//Function to find all RTInfo
	dataInfoRTFinder() {
        const node = this.nodeI;
        const updateRequest = this.updateRequestI;

        // Find the informationRT object that corresponds to this.nodeI
        const dataInfoRT = updateRequest.informationRT.find(info => info.Node === node);

        if (dataInfoRT) {
            this.DCNotfier.dgConsole(`DataInfoRT found for node ${node}:`);
            this.DCNotfier.dgConsole(dataInfoRT);
            return dataInfoRT;
        } else {
            this.DCNotfier.dgConsole(`No DataInfoRT found for node ${node}`);
            return null;
        }
    }
	
	//---------------Chart Processing Functions----------------//
	//--------------------------------------------------//
	//--------------------------------------------------//
	
	//---------------Single Point Functions----------------//
	
	//Calculates Last Value
	SinglePoint_lastValue(rawData) {
		let lastValidValue = null;
		if (this.updateRequestI.OperationMode==="Hist"){
			// Iterate from end to start
			for (let i = rawData.Values.length - 1; i >= 0; i--) {
				if (rawData.status[i] === 0) {
					lastValidValue = rawData.Values[i];
					break;
				}
			}
			this.relevantTimestampII=rawData.timestamps[rawData.Values.length-1];
		}
		
		if (this.updateRequestI.OperationMode==="RealTime"){
		
			var LastDataPointRTI=this.informationRTI.LastDataPointRT;
			// Iterate from end to start
			for (let i = LastDataPointRTI.length - 1; i >= 0; i--) {
				if (LastDataPointRTI[i].status === 0) {
					lastValidValue = LastDataPointRTI[i].Value;
					this.DCNotfier.dgConsole("lastValidValue: ");
					this.DCNotfier.dgConsole(LastDataPointRTI[i]);
					this.relevantTimestampII=LastDataPointRTI[i].timestamps;
					
					break;
				}
			}
		}
		// Return the last valid value
		return { ProcessedData: [lastValidValue ?? 0] };  // Default to 0 if no valid values found
	}
	
	//Bring First Value
	SinglePoint_firstValue(rawData) {
		let firstValidValue = null;
	
		// Iterate from start to end
		for (let i = 0; i < rawData.Values.length; i++) {
			if (rawData.status[i] === 0) {
				firstValidValue = rawData.Values[i];
				break;
			}
		}
	
		// Return the first valid value
		return { ProcessedData: [firstValidValue ?? 0] };  // Default to 0 if no valid values found
	}	
	
	//Bring Max Value
	SinglePoint_Max(rawData) {
		let maxValidValue = null;
		let maxTimestamp = null;  // Variable to store the timestamp corresponding to max value

		if (this.updateRequestI.OperationMode === "Hist") {
			// Loop through the values and statuses to find the max value where status is 0
			for (let i = 0; i < rawData.Values.length; i++) {
				if (rawData.status[i] === 0) {
					if (maxValidValue === null || rawData.Values[i] > maxValidValue) {
						maxValidValue = rawData.Values[i];
						maxTimestamp = rawData.timestamps[i];  // Store the corresponding timestamp
					}
				}
			}
			
			//Update category
			this.relevantTimestampII=maxTimestamp;

		}
				
		else if (this.updateRequestI.OperationMode === "RealTime") {
			var LastDataPointRTI=this.informationRTI.LastDataPointRT;
			maxValidValue=this.informationRTI.LastDataPointProcessed;
			maxTimestamp=this.informationRTI.LastRelevantTimestamp;
			
			// Iterate from end to start
			for (let i = LastDataPointRTI.length - 1; i >= 0; i--) {				
				if (LastDataPointRTI[i].status === 0) {
					if (maxValidValue === null || LastDataPointRTI[i].Value > maxValidValue) {
						maxValidValue = LastDataPointRTI[i].Value;
						maxTimestamp = LastDataPointRTI[i].timestamps;  // Store the corresponding timestamp
						
						//Update category
						this.chartCategoriesI.chartCategory.categories.push(maxTimestamp);				
						this.DCNotfier.dgConsole("New Max value: "+maxValidValue);
					}
				}				
			}
			
			//Update Relevant Timestamp
			this.relevantTimestampII=maxTimestamp;
			
		}
		
		// If no valid values were found, set default to 0
		if (maxValidValue === null) {
			maxValidValue = 0;
		}
	
		return { ProcessedData: [maxValidValue] };  // Return the max value
	}
	
	//Bring Min Value
	SinglePoint_Min(rawData) {
		let minValidValue = null;
		let minTimestamp = null;  // Variable to store the timestamp corresponding to min value
	
		if (this.updateRequestI.OperationMode === "Hist") {
			// Loop through the values and statuses to find the min value where status is 0
			for (let i = 0; i < rawData.Values.length; i++) {
				if (rawData.status[i] === 0) { // Valid status check
					if (minValidValue === null || rawData.Values[i] < minValidValue) {
						minValidValue = rawData.Values[i];
						minTimestamp = rawData.timestamps[i];  // Store the corresponding timestamp
					}
				}
			}
			
			//Update Relevant Timestamp
			this.relevantTimestampII=minTimestamp;
	
		} 
		else if (this.updateRequestI.OperationMode === "RealTime") {
			var LastDataPointRTI = this.informationRTI.LastDataPointRT;
			minValidValue = this.informationRTI.LastDataPointProcessed;
			minTimestamp=this.informationRTI.LastRelevantTimestamp;
			
			// Iterate from end to start for real-time data
			for (let i = LastDataPointRTI.length - 1; i >= 0; i--) {
				if (LastDataPointRTI[i].status === 0) {
					if (minValidValue === null || LastDataPointRTI[i].Value < minValidValue) {
						minValidValue = LastDataPointRTI[i].Value;
						minTimestamp = LastDataPointRTI[i].timestamps;  // Store the corresponding timestamp
						this.DCNotfier.dgConsole("New Min value: " + minValidValue);
					}
				}
			}
			
			//Update Relevant Timestamp
			this.relevantTimestampII=minTimestamp;
		}
	
		// If no valid values were found, set default to 0
		if (minValidValue === null) {
			minValidValue = 0;
		}
	
		return { ProcessedData: [minValidValue], minTimestamp: minTimestamp };  // Return the min value and its timestamp
	}
	
	//---------------Full Range Functions----------------//
	
	// Sums all data from rawData
	FullRange_Addition(rawData) {
		if (this.OperationMode === "Hist") {
			let sum = 0;
			// Iterate through the rawData.Values and sum values where rawData.status is 0
			rawData.Values.forEach((value, index) => {
				if (rawData.status[index] === 0) {
					sum += value;
				}
			});
		
			return { ProcessedData: [sum] };
		} else if (this.OperationMode === "RealTime") {
			let sum = this.informationRTI.LastDataPointProcessed;
	
			this.informationRTI.LastDataPointRT.forEach(dataPoint => {
				if (dataPoint.status === 0) {
					sum += dataPoint.Value;
				}
			});
	
			return { ProcessedData: [sum] };
		}
	}
	
	FullRange_Average(rawData) {
		let sum = 0;
		let count = 0;
	
		if (this.OperationMode === "Hist") {
			// Iterate through rawData in a single pass
			for (let i = 0; i < rawData.Values.length; i++) {
				if (rawData.status[i] === 0) {  // Only consider valid data points
					sum += rawData.Values[i];
					count++;
				}
			}
	
			// Calculate the average, avoiding division by zero
			const average = count > 0 ? sum / count : null;
	
			return { ProcessedData: [average] };
		} else if (this.OperationMode === "RealTime") {
			// For real-time mode, handle incremental updates
			sum = this.informationRTI.LastDataPointProcessed || 0;
			count = this.informationRTI.LastDataPointRT.length || 0;
	
			// Reset if a new interval starts
			if (this.chartCategoriesI.intervalInfo.newInterval) {
				this.informationRTI.LastDataPointProcessed = 0;
				sum = 0;
				count = 0;
			}
	
			// Process real-time data points
			this.informationRTI.LastDataPointRT.forEach(dataPoint => {
				if (dataPoint.status === 0) {
					sum += dataPoint.Value;
					count++;
				}
			});
	
			// Update the processed data for future use
			this.informationRTI.LastDataPointProcessed = sum;
	
			// Calculate the average, avoiding division by zero
			const average = count > 0 ? sum / count : null;
	
			return { ProcessedData: [average] };
		}
	}
	
	//Full Range Diference
	FullRange_Difference(rawData) {
		if (this.OperationMode === "Hist") {
			if (rawData == undefined) {
				this.DCNotfier.dgConsole("No raw data available");
				return { ProcessedData: [] }; // Return an empty array if not enough data
			}
		
			if (rawData.Values.length < 2) {
				this.DCNotfier.dgConsole("Not enough data points to calculate the difference.");
				return { ProcessedData: [] }; // Return an empty array if not enough data
			}
		
			let accumulatedDifference = 0;
			let previousValue = rawData.Values[0];
		
			for (let i = 1; i < rawData.Values.length; i++) {
				let currentValue = rawData.Values[i];
				let difference = currentValue - previousValue;
		
				if (difference < -100) {
					this.DCNotfier.dgConsole("Potential rollover detected between values:", previousValue, " and ", currentValue);
					// Double check if this is a genuine rollover
					if (this.isRollover(rawData.Values)) {
						const maxValue = this.getMaxValue(rawData.Values);
						const powerOfTwo = this.closestPowerOfTwo(maxValue);
						accumulatedDifference += (powerOfTwo - previousValue) + currentValue;
					} else {
						accumulatedDifference += difference; // if not a rollover, treat as normal negative difference
					}
				} else {
					accumulatedDifference += difference;
				}
				previousValue = currentValue;
			}
		
			return { ProcessedData: [accumulatedDifference] };
		} else if (this.OperationMode === "RealTime") {
			let accumulatedDifference = this.informationRTI.LastDataPointProcessed;
			let previousValue = this.informationRTI.LastDataPointRaw.Value;
			let currentValue = this.informationRTI.LastDataPointRT[this.informationRTI.LastDataPointRT.length - 1].Value;
			let difference = currentValue - previousValue;
	
			if (difference < -100) {
				this.DCNotfier.dgConsole("Potential rollover detected between values:", previousValue, " and ", currentValue);
				// Double check if this is a genuine rollover
				if (this.isRollover([previousValue, currentValue])) {
					const maxValue = this.getMaxValue([previousValue, currentValue]);
					const powerOfTwo = this.closestPowerOfTwo(maxValue);
					accumulatedDifference += (powerOfTwo - previousValue) + currentValue;
				} else {
					accumulatedDifference += difference; // if not a rollover, treat as normal negative difference
				}
			} else {
				accumulatedDifference += difference;
			}
	
			return { ProcessedData: [accumulatedDifference] };
		}
	}
	
	//Productivity Calculator
	FullRange_OEEProductivity(rawData) {
		if (this.OperationMode === "Hist") {
			let initialTime = new Date(this.dataRequest.updateRequest[0].initialTime).getTime();
			let finalTime = new Date(this.dataRequest.updateRequest[0].finalTime).getTime();
			let changesPerInterval = {};
			let totalChanges = 0;
			let OEEProductionSpeed = this.chartConfigI.specialParameters.OEEProductionSpeed;
			let OEECompleteRangeAnalisis = this.chartConfigI.specialParameters.OEECompleteRangeAnalisis;
			
			
			//Find Interval with changes
			rawData.timestamps.forEach((timestamp, index) => {
				if (timestamp >= initialTime && timestamp <= finalTime) {
					let intervalLengthMillis = typeof this.intervalLength === 'number' ? this.intervalLength : this.getIntervalLengthInMillis(timestamp);
					//Update IntervalLengthI for OEE Productivity
					const intervalIndex = Math.floor((timestamp - initialTime) / intervalLengthMillis);
	
					// Initialize the count for each interval if not already done
					if (!changesPerInterval[intervalIndex]) {
						changesPerInterval[intervalIndex] = 0;
					}
	
					if (index > 0 && rawData.Values[index] !== rawData.Values[index - 1]) {
						changesPerInterval[intervalIndex]++;
					}
				}
			});
			
			//Calculated number of changes
			totalChanges=this.FullRange_Difference(rawData).ProcessedData;
	
			// Determine the number of intervals based on OEECompleteRangeAnalisis setting
			let intervalsWithChanges;
			let hoursEquivalent;
			
			//Check what strategy we want to use
			if (OEECompleteRangeAnalisis === "true") {
				const totalIntervals = Math.ceil((finalTime - initialTime) / this.getIntervalLengthInMillis(initialTime));
				intervalsWithChanges = totalIntervals+1;
				hoursEquivalent = totalIntervals * (this.getIntervalLengthInMillis(initialTime) / (3600 * 1000));
				
			} else {
				intervalsWithChanges = Object.keys(changesPerInterval).length+1;
				hoursEquivalent = intervalsWithChanges * (this.getIntervalLengthInMillis(initialTime) / (3600 * 1000));
			}
			
			
			//Calculate expected Productivity
			let expectedProductivity = hoursEquivalent * OEEProductionSpeed;
			
			this.OEEinfoRTI["OEEPrevioustotalChanges"]=totalChanges;
			this.OEEinfoRTI["OEEIntervalHours"]=(this.getIntervalLengthInMillis(initialTime) / (3600 * 1000));
						
			// Check to prevent division by zero
			if (expectedProductivity === 0) {
				return { ProcessedData: ["No change or zero productivity expected"] };
			}
			
			//Calculate Productivity
			let OEEProductivityValue = (totalChanges / expectedProductivity) * 100;
	
			return { ProcessedData: [OEEProductivityValue] };
	
		} else if (this.OperationMode === "RealTime") {
			
			let totalChanges = this.informationRTI.OEEInfo.OEEPrevioustotalChanges;
			let previousValue = this.informationRTI.LastDataPointRaw.Value;
			let OEEProductionSpeed = this.chartConfigI.specialParameters.OEEProductionSpeed;
			let OEECompleteRangeAnalisis = this.chartConfigI.specialParameters.OEECompleteRangeAnalisis;
			let initialTime = new Date(this.informationRTI.IntervalInfo.start);
			let finalTime = new Date(this.informationRTI.IntervalInfo.end);
				
			
			this.informationRTI.LastDataPointRT.forEach((dataPoint, index) => {
				if (dataPoint.status === 0) {
					totalChanges++;
				}
			});
						
			//Update OEE RT Info
			this.OEEinfoRTI["OEEPrevioustotalChanges"]=totalChanges;
			this.OEEinfoRTI["OEEIntervalHours"]=this.informationRTI.OEEInfo.OEEIntervalHours;
			
			const totalInterval = Math.ceil((finalTime - initialTime)/1000); //Interval in second
			let hoursEquivalent = (totalInterval / (3600))+this.informationRTI.OEEInfo.OEEIntervalHours;			
						
			//Calculate Expected productivity
			let expectedProductivity = hoursEquivalent * OEEProductionSpeed;
			
			// Check to prevent division by zero
			if (expectedProductivity === 0) {
				return { ProcessedData: ["No change or zero productivity expected"] };
			}
	
			let OEEProductivityValue = (totalChanges / expectedProductivity) * 100;
			
			return { ProcessedData: [OEEProductivityValue] };
		}
	}
	
	//Avalilability Calculator
	FullRange_OEEAvailability(rawData, intervals) {
        const { ProcessedData: timeOnArray } = this.Interval_CountTimeOn(rawData, intervals);
        const totalTimeOn = timeOnArray.reduce((acc, curr) => acc + curr, 0);
        const expectedTimeOn = intervals.length * this.getIntervalLengthInMillis(new Date(this.dataRequest.updateRequest[0].initialTime).getTime());
        const OEEAvailabilityValue = (totalTimeOn / expectedTimeOn) * 100;

        return { ProcessedData: [OEEAvailabilityValue] };
    }	
    
    //---------------Interval Functions----------------//
    
	//Create Histogram Data
	Interval_Histogram(rawData, chartCategories) {
		// Initialize histogram count array with zeros for each category
		let histogramCountArray = new Array(chartCategories.length).fill(0);
		// Parse chartCategories to get min and max for each bin
		const bins = chartCategories.map(category => {
			const parts = category.split('-');
			return {
				min: parseFloat(parts[0]),
				max: parseFloat(parts[1])
			};
		});
	
		if (this.OperationMode === "Hist") {
			// Iterate over each value in the raw data
			rawData.Values.forEach(value => {
				// Find which bin this value belongs to
				for (let i = 0; i < bins.length; i++) {
					if (value >= bins[i].min && value < bins[i].max) {
						histogramCountArray[i]++;
						break; // Stop checking once the correct bin is found
					}
				}
			});
		} 
		else if (this.OperationMode === "RealTime") {
			const originalCategories = this.informationRTI.HistInfo.categories;
			const originalProcessedData = this.informationRTI.HistInfo.ProcessedData;
			
			this.DCNotfier.dgConsole("originalCategories");
			this.DCNotfier.dgConsole(originalCategories);
			this.DCNotfier.dgConsole("originalProcessedData");
			this.DCNotfier.dgConsole(originalProcessedData);
			
			this.DCNotfier.dgConsole("Updated Chart Categories");
			this.DCNotfier.dgConsole(chartCategories);
			
			let newProcessedData = [...originalProcessedData];
	
			// Find new bins added at the beginning
			let addedBinsAtBeginning = 0;
			while (!originalCategories.includes(chartCategories[addedBinsAtBeginning])) {
				newProcessedData.unshift(0);
				addedBinsAtBeginning++;
			}
	
			// Find new bins added at the end
			let addedBinsAtEnd = 0;
			while (!originalCategories.includes(chartCategories[chartCategories.length - 1 - addedBinsAtEnd])) {
				newProcessedData.push(0);
				addedBinsAtEnd++;
			}
	
			// Iterate over each value in the LastDataPointRT
			this.informationRTI.LastDataPointRT.forEach(dataPoint => {
				// Find which bin this value belongs to
				for (let i = 0; i < bins.length; i++) {
					if (dataPoint.Value >= bins[i].min && dataPoint.Value < bins[i].max) {
						newProcessedData[i]++;
						break; // Stop checking once the correct bin is found
					}
				}
			});
			
			this.DCNotfier.dgConsole("newProcessedData");
			this.DCNotfier.dgConsole(newProcessedData);
	
			histogramCountArray = newProcessedData;
		}
	
		// Update this.HistInfoRTI["ProcessedData"]
		this.HistInfoRTI["ProcessedData"] = histogramCountArray;
	
		return { ProcessedData: histogramCountArray };
	}
	
	// Method to count changes in data
	Interval_ChangesCounter(rawData, intervals) {
		if (this.OperationMode === "Hist") {
			let changesCountArray = intervals.map(interval => {
				let previousValue = null;
				let changesCount = 0;
	
				for (let i = 0; i < rawData.timestamps.length; i++) {
					const timestamp = rawData.timestamps[i];
					if (timestamp >= interval.start && timestamp <= interval.end) {
						const currentValue = rawData.Values[i];
						const currentStatus = rawData.status[i];
	
						// Increment changesCount only if the status is 0 and the value changed
						if (previousValue !== null && currentValue !== previousValue && currentStatus === 0) {
							changesCount++;
						}
						previousValue = currentValue;
					}
				}
	
				return changesCount;
			});
	
			return { ProcessedData: changesCountArray };
		} else if (this.OperationMode === "RealTime") {
			//Reset if new Interval
			if(this.chartCategoriesI.intervalInfo.newInterval==true){
				 this.informationRTI.LastDataPointProcessed=0;
			}
				
			let changesCount = this.informationRTI.LastDataPointProcessed;
	
			this.informationRTI.LastDataPointRT.forEach(dataPoint => {
				if (dataPoint.status === 0) {
					changesCount++;
				}
			});
	
			return { ProcessedData: [changesCount] };
		}
	}
	
	//Count time On
	Interval_CountTimeOn(rawData, intervals) {
		let timeOnArray = new Array(intervals.length).fill(0);
	
		// Loop through each interval to determine the ON time
		intervals.forEach((interval, idx) => {
			let intervalStart = interval.start;
			let intervalEnd = interval.end;
			let timeOn = 0;
			let lastKnownOn = false;
			let lastTimestamp = intervalStart;
	
			// Iterate through timestamps to calculate ON time within the interval
			rawData.timestamps.forEach((timestamp, i) => {
				if (timestamp >= intervalStart && timestamp <= intervalEnd) {
					// Check if we're inside the interval and there is a state change
					if (lastKnownOn) {
						// Accumulate ON time from the last timestamp or the start of the interval
						timeOn += Math.min(timestamp, intervalEnd) - lastTimestamp;
					}
					// Update the last known state and the last timestamp
					lastKnownOn = rawData.Values[i];
					lastTimestamp = timestamp;
				}
			});
	
			// After processing all timestamps, if the last state was ON and the last timestamp is within the interval,
			// extend the ON time to the end of the interval
			if (lastKnownOn && lastTimestamp < intervalEnd) {
				timeOn += intervalEnd - lastTimestamp;
			}
	
			// Check if any timestamps fall into the interval
			const timestampsInInterval = rawData.timestamps.filter(t => t >= intervalStart && t <= intervalEnd);
			if (timestampsInInterval.length === 0) {
				// No timestamps in the interval, use the last known value from the previous intervals
				if (idx > 0 && rawData.Values[rawData.timestamps.length - 1]) {
					timeOn = intervalEnd - intervalStart; // If the machine was ON in the last known check, assume it stayed ON
				}
			}
	
			timeOnArray[idx] = timeOn;
		});
	
		return { ProcessedData: timeOnArray };
	}
	
	// Method to integrate data within Intervals
	Interval_Integration(rawData, intervals) {
		let integratedDataArray = [];
	
		if (this.OperationMode === "Hist") {
			intervals.forEach(interval => {
				// Variables to store the previous value for trapezoidal calculation
				let previousValue = null;
				let previousTime = null;
				let area = 0;
	
				rawData.timestamps.forEach((timestamp, index) => {
					if (timestamp >= interval.start && timestamp <= interval.end && rawData.status[index] === 0) {
						// Convert timestamp from milliseconds to seconds for the x-axis
						let currentTime = timestamp / 1000;
						let currentValue = rawData.Values[index];
	
						// Calculate the area using the trapezoidal rule if it's not the first data point
						if (previousValue !== null) {
							let base = currentTime - previousTime; // The difference in time (in seconds)
							area += (currentValue + previousValue) / 2 * base; // Trapezoidal area calculation
						}
	
						// Update the previous values for the next iteration
						previousValue = currentValue;
						previousTime = currentTime;
					}
				});
	
				// Add the calculated area for the current interval to the array
				integratedDataArray.push(area);
			});
	
			return { ProcessedData: integratedDataArray };
		} else if (this.OperationMode === "RealTime") {
		
			//Reset if new Interval
			if(this.chartCategoriesI.intervalInfo.newInterval==true){
				 this.informationRTI.LastDataPointProcessed=0;
			}
			
			let area = this.informationRTI.LastDataPointProcessed;
			let previousValue = null;
			let previousTime = this.informationRTI.LastDataPointRaw.timestamps / 1000;
	
			// Concatenate LastDataPointRaw at the beginning of LastDataPointRT
			let allDataPoints = [this.informationRTI.LastDataPointRaw].concat(this.informationRTI.LastDataPointRT);
	
			allDataPoints.forEach((dataPoint, index) => {
				if (dataPoint.status === 0) {
					// Convert timestamp from milliseconds to seconds for the x-axis
					let currentTime = dataPoint.timestamps / 1000;
					let currentValue = dataPoint.Value;
	
					// Calculate the area using the trapezoidal rule if it's not the first data point
					if (previousValue !== null) {
						let base = currentTime - previousTime; // The difference in time (in seconds)
						area += (currentValue + previousValue) / 2 * base; // Trapezoidal area calculation
					}
	
					// Update the previous values for the next iteration
					previousValue = currentValue;
					previousTime = currentTime;
				}
			});
	
			return { ProcessedData: [area] };
		}
	}
		
	// Interval Difference
    Interval_Difference(rawData, intervals) {
        let differenceArray = [];
        this.DCNotfier.dgConsole("rawData");
        this.DCNotfier.dgConsole(rawData);
        this.DCNotfier.dgConsole("intervals");
        this.DCNotfier.dgConsole(intervals);

		if (this.OperationMode === "Hist") {
			try {
			
				let endIndexPrevious;
				
				differenceArray = intervals.map((interval, intervalIndex) => {
				
					
					// Find startIndex: First index where timestamp >= interval.start and < interval.end
					let startIndex = rawData.timestamps.findIndex(time => time >= interval.start && time < interval.end);
					
					// Find endIndex: First index where timestamp > interval.end
					let endIndex = rawData.timestamps.findIndex(time => time > interval.end);
					
					// For all iterations
					if (intervalIndex > 0 && endIndexPrevious!=-1) {
						// Use the previous endIndex as the startIndex for the current interval
						startIndex = endIndexPrevious;
					}
					
					// Calculate the endIndex for the current interval
					if (endIndex !== -1) {
						endIndex -= 1; // Move back one index to get the closest value less than or equal to interval.end
					} else {
						endIndex = rawData.Values.length - 1; // If no index found, set to last element
					}
					
					// Store the current endIndex for the next iteration
					endIndexPrevious = endIndex;

			
					// Check validity of startIndex and endIndex
					if (startIndex === -1 || startIndex > endIndex || endIndex < 0) {
						return null; // No valid data in this interval
					}
			
					let firstValue = rawData.Values[startIndex];
					let lastValue = rawData.Values[endIndex];
					
					let firstTimestamp=new Date(rawData.timestamps[startIndex]);
					let lastTimestamp=new Date(rawData.timestamps[endIndex])
					
	
					
					
					let difference = lastValue - firstValue;
			

					// Handling potential rollovers
					
					if (difference < 0){//Negative number
						
						let endIndexPositive=endIndex;
						
						//Potential Roll Over
						if (difference < -10000) {
							this.DCNotfier.dgConsole("Potential rollover detected between values:", firstValue, " and ", lastValue);
							//Roll Over
							if (this.isRollover(rawData.Values)) {
								const maxValue = this.getMaxValue(rawData.Values);
								const powerOfTwo = this.closestPowerOfTwo(maxValue);
								difference = (powerOfTwo - firstValue) + lastValue;
							}
							
							//No Roll Over
							else{
								while(difference < 0 || endIndexPositive>startIndex){
								
									//Go Backwards to find when this happened
									endIndexPositive=endIndexPositive-1;
									let lastValuePositive = rawData.Values[endIndexPositive];
									
									//Recalculate Difference
									difference=firstValue-lastValue;
									
									
								}
								
								let lastValueafterPositive = rawData.Values[endIndexPositive+1];
								
								//Adds the rest
								difference=difference+(lastValue-lastValueafterPositive);
							}
						}
						
						//Defenitelly No Roll Over
						else{
							while(difference < 0 || endIndexPositive>startIndex){
								
									//Go Backwards to find when this happened
									endIndexPositive=endIndexPositive-1;
									let lastValuePositive = rawData.Values[endIndexPositive];
									
									//Recalculate Difference
									difference=firstValue-lastValue;
									
									
								}
								
								let lastValueafterPositive = rawData.Values[endIndexPositive+1];
								
								//Adds the rest
								difference=difference+(lastValue-lastValueafterPositive);
						}
					}
			
					return difference;
				});
			} catch (error) {
				console.error("An error occurred in Interval_Difference:", error);
				throw new Error("Failed to calculate interval differences: " + error.message);
			}
			
			return { ProcessedData: differenceArray };
		}

        else if (this.OperationMode === "RealTime") {
            try {
				//Reset if new Interval
				if(this.chartCategoriesI.intervalInfo.newInterval==true){
					 this.informationRTI.LastDataPointProcessed=0;
				}
				
                let latestValueRT = this.informationRTI.LastDataPointRT[this.informationRTI.LastDataPointRT.length - 1].Value;
                let lastValueRaw = this.informationRTI.LastDataPointRaw.Value;
                let difference = latestValueRT - lastValueRaw;
				this.DCNotfier.dgConsole("Difference: "+difference);
				this.DCNotfier.dgConsole("this.informationRTI.LastDataPointProcessed: "+this.informationRTI.LastDataPointProcessed);
                if (difference < -100) {
                    this.DCNotfier.dgConsole("Potential rollover detected between values:", lastValueRaw, " and ", latestValueRT);
                    if (this.isRollover([lastValueRaw, latestValueRT])) { // Assuming this.isRollover can handle a small array
                        const maxValue = this.getMaxValue([lastValueRaw, latestValueRT]);
                        const powerOfTwo = this.closestPowerOfTwo(maxValue);
                        difference = (powerOfTwo - lastValueRaw) + latestValueRT;
                    }
                }

                let result = this.informationRTI.LastDataPointProcessed + difference;
                
                this.DCNotfier.dgConsole("result: "+result);
                return { ProcessedData: [result] };
            } catch (error) {
                console.error("An error occurred in Interval_Difference (RealTime):", error);
                throw new Error("Failed to calculate interval differences (RealTime): " + error.message);
            }
        }
    }
 	
	//Interval addition
	Interval_Addition(rawData, intervals) {
		if (this.OperationMode === "Hist") {
			let sumsArray = intervals.map(interval => {
				let sum = 0;
				
				for (let i = 0; i < rawData.timestamps.length; i++) {
					const timestamp = rawData.timestamps[i];
					if (timestamp >= interval.start && timestamp <= interval.end && rawData.status[i] === 0) {
						sum += rawData.Values[i];
					}
				}
				
				return sum;
			});
			
			return { ProcessedData: sumsArray };
		} else if (this.OperationMode === "RealTime") {
			let sum = this.informationRTI.LastDataPointProcessed;
			//Reset if new Interval
			if(this.chartCategoriesI.intervalInfo.newInterval==true){
				 this.informationRTI.LastDataPointProcessed=0;
			}
			
			this.informationRTI.LastDataPointRT.forEach(dataPoint => {
				if (dataPoint.status === 0) {
					sum += dataPoint.Value;
				}
			});
			
			return { ProcessedData: [sum] };
		}
	}
	
	// Interval_Average Method
	Interval_Average(rawData, intervals) {
		let averageArray = [];
		
		// Use binary search to quickly find ranges for each interval
		if (this.OperationMode === "Hist") {
			averageArray = intervals.map(interval => {
				// Use binary search to find the start and end indices for the current interval
				let startIndex = this.binarySearchTimestamps(rawData.timestamps, interval.start, 0, rawData.timestamps.length - 1, true);
				let endIndex = this.binarySearchTimestamps(rawData.timestamps, interval.end, startIndex, rawData.timestamps.length - 1, false);
				
				let sum = 0;
				let count = 0;
	
				// Iterate through only the relevant range of rawData for the current interval
				for (let i = startIndex; i <= endIndex; i++) {
					if (rawData.status[i] === 0) {
						sum += rawData.Values[i]; // Sum valid values
						count++; // Count valid entries
					}
				}
	
				// Calculate the average for the interval, avoiding division by zero
				const average = count > 0 ? sum / count : null;
	
				return average;
			});
	
			return { ProcessedData: averageArray };
		} else if (this.OperationMode === "RealTime") {
			let sum = this.informationRTI.LastDataPointProcessed || 0;
			let count = this.informationRTI.LastDataPointRT.length || 0;
	
			// Reset if it's a new interval
			if (this.chartCategoriesI.intervalInfo.newInterval) {
				this.informationRTI.LastDataPointProcessed = 0;
				sum = 0;
				count = 0;
			}
	
			this.informationRTI.LastDataPointRT.forEach(dataPoint => {
				if (dataPoint.status === 0) {
					sum += dataPoint.Value;
					count++;
				}
			});
	
			const average = count > 0 ? sum / count : null;
	
			return { ProcessedData: [average] };
		}
	}
	
	
	//---------------Table Processing Functions----------------//
	//--------------------------------------------------//
	//--------------------------------------------------//
	
	//---------------Single Point Functions----------------//
	
	//SimpleData
	SimpleNoneTableProcessing() {
	
		const processedDataI = [];
		const timestampsCategories = this.chartCategoriesI.chartCategory.categories[0].categories;
		const rawDataTimestamps = this.partialDashboardDataI.timestamps;
		const rawDataValues = this.partialDashboardDataI.Values;
		const replacementText = this.chartConfigI.specialParameters.TableConfig.ReplacementText; // Variable for replacement text
		const fillingMethod=this.chartConfigI.specialParameters.TableConfig.FillingMethod;
	
		// Find the index of this.nodeI in this.chartNodesI to match the DataColumnTypes
		const dataColumnType = this.chartConfigI.specialParameters.TableConfig.DataColumnTypes[this.indexNodeI];
		this.DCNotfier.dgConsole("------------dataColumnType: "+dataColumnType);
	
		// Helper functions to find closest values based on timestamp comparison
		const findClosestBelow = (targetTimestamp) => {
			let closestIndex = -1;
			for (let i = 0; i < rawDataTimestamps.length; i++) {
				if (rawDataTimestamps[i] <= targetTimestamp) {
					closestIndex = i;
				} else {
					break;
				}
			}
			return closestIndex;
		};
	
		const findClosestAbove = (targetTimestamp) => {
			for (let i = 0; i < rawDataTimestamps.length; i++) {
				if (rawDataTimestamps[i] >= targetTimestamp) {
					return i;
				}
			}
			return -1;
		};
	
		const findAverageBetweenTwo = (targetTimestamp) => {
			let belowIndex = findClosestBelow(targetTimestamp);
			let aboveIndex = findClosestAbove(targetTimestamp);
	
			if (belowIndex === -1 && aboveIndex === -1) {
				return replacementText; // No values available
			}
			if (belowIndex === -1) {
				return rawDataValues[aboveIndex]; // Only one available, return above
			}
			if (aboveIndex === -1) {
				return rawDataValues[belowIndex]; // Only one available, return below
			}
			// Average of two closest values
			return (rawDataValues[belowIndex] + rawDataValues[aboveIndex]) / 2;
		};
	
		// Main logic based on fillingMethod and DataColumnTypes
		for (let timestamp of timestampsCategories) {
			let processedValue;
			
			/*
			if (fillingMethod === "Fill-NoValue") {
				// Check for an exact match in timestamps
				const index = rawDataTimestamps.indexOf(timestamp);
				if (index !== -1) {
					processedValue = dataColumnType === "Value" ? rawDataValues[index] : rawDataTimestamps[index];
				} else {
					processedValue = replacementText;
				}
			}*/
			
			if (fillingMethod === "Fill-NoValue") {
				// Check for an exact match in timestamps
				const index = rawDataTimestamps.indexOf(timestamp);
				const threshold=100;
				
				if (index !== -1) {
					// Exact match found
					processedValue = dataColumnType === "Value" ? rawDataValues[index] : rawDataTimestamps[index];
				} else {
					// Find the closest value below the timestamp
					const closestBelowIndex = findClosestBelow(timestamp);
					const closestBelowDiff = closestBelowIndex !== -1 ? Math.abs(timestamp - rawDataTimestamps[closestBelowIndex]) : Infinity;
			
					// Check if it's within the threshold
					if (closestBelowDiff <= threshold) {
						processedValue = dataColumnType === "Value" ? rawDataValues[closestBelowIndex] : rawDataTimestamps[closestBelowIndex];
					} else {
						// Find the closest value above the timestamp
						const closestAboveIndex = findClosestAbove(timestamp);
						const closestAboveDiff = closestAboveIndex !== -1 ? Math.abs(rawDataTimestamps[closestAboveIndex] - timestamp) : Infinity;
			
						// Check if it's within the threshold
						if (closestAboveDiff <= threshold) {
							processedValue = dataColumnType === "Value" ? rawDataValues[closestAboveIndex] : rawDataTimestamps[closestAboveIndex];
						} else {
							// No suitable match, use replacementText
							processedValue = replacementText;
						}
					}
				}
			}			
			else if (fillingMethod === "Fill-ClosestValueBelow") {
				// Find the closest timestamp below
				const closestIndex = findClosestBelow(timestamp);
				if (closestIndex !== -1) {
					processedValue = dataColumnType === "Value" ? rawDataValues[closestIndex] : rawDataTimestamps[closestIndex];
				} else if (rawDataTimestamps.length > 0) {
					processedValue = dataColumnType === "Value" ? rawDataValues[0] : rawDataTimestamps[0];
				} else {
					processedValue = replacementText;
				}
			} else if (fillingMethod === "Fill-ClosestValueAbove") {
				// Find the closest timestamp above
				const closestIndex = findClosestAbove(timestamp);
				if (closestIndex !== -1) {
					processedValue = dataColumnType === "Value" ? rawDataValues[closestIndex] : rawDataTimestamps[closestIndex];
				} else if (rawDataTimestamps.length > 0) {
					processedValue = dataColumnType === "Value" ? rawDataValues[rawDataValues.length - 1] : rawDataTimestamps[rawDataTimestamps.length - 1];
				} else {
					processedValue = replacementText;
				}
			} else if (fillingMethod === "Fill-Average") {
				// Find the average of the two closest timestamps
				if (dataColumnType === "Value") {
					processedValue = findAverageBetweenTwo(timestamp);
				} else {
					const belowIndex = findClosestBelow(timestamp);
					const aboveIndex = findClosestAbove(timestamp);
					if (belowIndex !== -1 && aboveIndex !== -1) {
						processedValue = (rawDataTimestamps[belowIndex] + rawDataTimestamps[aboveIndex]) / 2;
					} else if (belowIndex !== -1) {
						processedValue = rawDataTimestamps[belowIndex];
					} else if (aboveIndex !== -1) {
						processedValue = rawDataTimestamps[aboveIndex];
					} else {
						processedValue = replacementText;
					}
				}
			}
	
			// Push the processed value or timestamp depending on the DataColumnTypes
			processedDataI.push(processedValue);
		}
	
		return { ProcessedData: processedDataI };
	}
	
	//---------------Data Analisis Helper Methods--------------//
	//--------------------------------------------------------//
	
	// Auxiliary function
	getMaxValue(values) {
		return values.reduce((max, v) => v > max ? v : max, values[0]);
	}
	
	//Auxiliary function
	closestPowerOfTwo(maxValue) {
		if (maxValue < 65536) {
			return 65536; // 2^16
		} else if (maxValue < 4294967296) {
			return 4294967296; // 2^32
		} else {
			return 18446744073709551616; // 2^64
		}
	}
	
	//Calculate stats
	calculateStats(values) {
		const n = values.length;
		let mean = values.reduce((acc, val) => acc + val, 0) / n;
		let variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / n;
		let stdDev = Math.sqrt(variance);
		return { mean, stdDev };
	}
	
	//Check for Rollovers
	isRollover(values) {
		const { mean, stdDev } = this.calculateStats(values);
		return values.some((val, i, arr) => i > 0 && (val - arr[i-1] < -stdDev * 2));
	}
	
	// Function to round date
	roundDate(date, orientation) {
		var date = new Date(date); // Clone to avoid mutating the original date
		if (typeof this.intervalLengthI === 'number') {
			if (this.intervalLengthI <= ONE_MINUTE) {
				date.setSeconds(0, 0);
				if (orientation === 'up' && date.getSeconds() > 0) {
					date.setMinutes(date.getMinutes() + 1);
				}
			} else if (this.intervalLengthI <= ONE_HOUR) {
				date.setSeconds(0, 0);
				if (orientation === 'up' && date.getMinutes() > 0) {
					date.setHours(date.getHours() + 1);
					date.setMinutes(0);
				} else {
					date.setMinutes(0);
				}
			} else if (this.intervalLengthI <= ONE_DAY) {
				date.setMinutes(0, 0, 0);
				if (orientation === 'up' && date.getHours() > 0) {
					date.setDate(date.getDate() + 1);
					date.setHours(0);
				} else {
					date.setHours(0);
				}
			}
		} else if (this.intervalLengthI === 'month') {
			date.setHours(0, 0, 0, 0);
			date.setDate(1);
			if (orientation === 'up' && date.getMonth() > 0) {
				date.setMonth(date.getMonth() + 1);
			}
		} else if (this.intervalLengthI === 'year') {
			date.setMonth(0, 1);
			date.setHours(0, 0, 0, 0);
			date.setDate(1);
			if (orientation === 'up' && date.getFullYear() > 0) {
				date.setFullYear(date.getFullYear() + 1);
			}
		}
		return date;
	}
	
	// Faster Search
	binarySearchTimestamps(timestamps, target, start = 0, end = timestamps.length - 1, findStart = true) {
		while (start <= end) {
			let mid = Math.floor((start + end) / 2);
			if (timestamps[mid] === target) {
				return mid;
			} else if (timestamps[mid] < target) {
				start = mid + 1;
			} else {
				end = mid - 1;
			}
		}
		// If findStart is true, return the first index where the timestamp >= target
		return findStart ? start : end;
	}
	
	//Format Time
	formatTimestampToDateTime(unixTimestamp) {
		const date = new Date(unixTimestamp); // Convert Unix timestamp to Date object
	
		// Extract date components
		const day = String(date.getDate()).padStart(2, '0'); // Pad single-digit days with 0
		const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are 0-based, pad single-digit months
		const year = date.getFullYear();
	
		// Extract time components
		const hours = String(date.getHours()).padStart(2, '0'); // Pad single-digit hours
		const minutes = String(date.getMinutes()).padStart(2, '0'); // Pad single-digit minutes
		const seconds = String(date.getSeconds()).padStart(2, '0'); // Pad single-digit seconds
	
		// Return formatted string in the desired format
		return `${day}/${month}/${year} ${hours}:${minutes}:${seconds}`;
	}
}

//---------------Dashboard Cache Manager Class----------------//
//-----------------------------------------------------//

class DashboardCacheManager {

    // Attributes
    cacheDataRequest;
    cacheData;
    cacheRawData;
    cacheProcessedData;
    initialTime;
    finalTime;

    // Constructor
    constructor(dashboardCreatorNotifier) {    
		this.cacheConfig;
		this.cacheKey="cacheData";
        this.initialTime;
        this.finalTime;
        this.cacheDataRequest = {};
        this.cachedData = [];
        this.cacheRawData;
        this.cacheProcessedData = [];
        this.intervalLength=ONE_HOUR;
        this.DCNotfier=dashboardCreatorNotifier;
    }
	
    // Initialize cache data based on initial setup
    initialize(initialTime, finalTime, rawData, nodes) {
			
    	
    	//Initialize Variables
    	this.initialTime = initialTime;
        this.finalTime = finalTime;

        this.cacheRawData = rawData;
        
		//Store Data
		this.storeCacheData();
		
		this.DCNotfier.dgConsole("--------------Initial Cache Store-----------");
    }
    
    setCacheConfig(cacheConfig){
		//Initialize Cache Config
		this.cacheConfig=cacheConfig    
    }

    // Store data in the cache
    storeCacheData() {
    
		//Store in global Variable
		globals.set(this.cacheKey, this.cacheRawData);
		
    }

	// Update existing cache data
	async updateCacheData(data) {
		try {
		  this.DCNotfier.dgConsole("---------------Updating Cache data-------------");
		  // Get current cached data
		  const cachedData = globals.get(this.cacheKey);
		  
		  // Fix initial time and final time
		  const fixedcachedData = this.fixCacheToTimestamps(cachedData);
		  this.DCNotfier.dgConsole("Initial CacheData: ", fixedcachedData);
		  this.DCNotfier.dgConsole("New Data: ", data);
		  
		  // Sort data
		  let combinedData = [fixedcachedData];
		  combinedData.push(data[0]);
		  
		  // Merge with other data
		  this.cacheRawData = await this.rawDataMerger(combinedData);
		  
		  this.DCNotfier.dgConsole("Merged Data: ", this.cacheRawData);
		  
		  // Store new data
		  this.storeCacheData();
		} catch (error) {
		  console.error("Error updating cache data: ", error);
		}
	}
		
	//Query Cache data
	queryCacheData(query) {
			this.DCNotfier.dgConsole("----------Querying Cache-----------");
			const cachedData = globals.get(this.cacheKey);
			this.DCNotfier.dgConsole("Complete cacheData: ")
			//this.DCNotfier.dgConsole(cachedData);
			if (!cachedData) {
				this.DCNotfier.dgConsole("No cache data available.");
				return [];
			}
		
			const dataMap = new Map();
			cachedData.forEach(data => {
				if (!dataMap.has(data.Nodeaddress)) {
					dataMap.set(data.Nodeaddress, []);
				}
				dataMap.get(data.Nodeaddress).push(data);
			});
		
			let results = [];
			query.forEach(q => {
				const initialTime = new Date(q.initialTime).getTime();
				const finalTime = new Date(q.finalTime).getTime();
		
				q.nodes.forEach(node => {
					if (dataMap.has(node)) {
						const nodeData = dataMap.get(node);
						nodeData.forEach(data => {
							const filteredValues = [];
							const filteredStatus = [];
							const filteredTimestamps = [];
		
							let startIdx = this.binarySearch(data.timestamps, initialTime, true);
							let endIdx = this.binarySearch(data.timestamps, finalTime, false);
		
							for (let i = startIdx; i <= endIdx; i++) {
								filteredValues.push(data.Values[i]);
								filteredStatus.push(data.status[i]);
								filteredTimestamps.push(data.timestamps[i]);
							}
		
							if (filteredValues.length > 0) {
								results.push({
									Nodeaddress: node,
									InitialTimeevaluated: q.initialTime,
									FinalTimeevaluated: q.finalTime,
									Values: filteredValues,
									status: filteredStatus,
									timestamps: filteredTimestamps,
									DataSize: filteredValues.length
								});
							}
						});
					}
				});
			});
		
		return results;
	}
	
	//QueryCacheData
	queryCacheData2(query) {
		this.DCNotfier.dgConsole("----------Querying Cache-----------");
		const cachedData = globals.get(this.cacheKey);
		this.DCNotfier.dgConsole("Complete cacheData: ");
		//this.DCNotfier.dgConsole(cachedData);
		if (!cachedData) {
			this.DCNotfier.dgConsole("No cache data available.");
			return [];
		}
		
		// Extract initial and final times from the query
		const initialTime = new Date(query.initialTime).getTime();
		const finalTime = new Date(query.finalTime).getTime();
		
		// Filter data for the specified node
		const nodeData = cachedData.filter(data => data.Nodeaddress === query.nodes[0]);
		this.DCNotfier.dgConsole("nodeData");
		this.DCNotfier.dgConsole(nodeData);
		if (nodeData.length === 0) {
			this.DCNotfier.dgConsole("No data found for the specified node.");
			return [];
		}
	
		// Find intervals that intersect with the query time range
		const relevantIntervals = nodeData[0].Data.filter(interval => {
			return !(interval.FinalTime < initialTime || interval.InitialTime > finalTime);
		});
	
		if (relevantIntervals.length === 0) {
			this.DCNotfier.dgConsole("No intervals found within the specified time range.");
			return [];
		}
	
		// Reconstruct data from the relevant intervals
		const reconstructedData = this.cacheDataReconstructor([{
			CacheDataType: 'RawDataInIntervals',
			Data: relevantIntervals,
			FinalTimeevaluated: nodeData[0].FinalTimeevaluated,
			InitialTimeevaluated: nodeData[0].InitialTimeevaluated,
			IntervalLength: nodeData[0].IntervalLength,
			Nodeaddress: nodeData[0].Nodeaddress
		}]);
	
		this.DCNotfier.dgConsole("reconstructedData");
		this.DCNotfier.dgConsole(reconstructedData);
		// Filter data to match the query time range
		const filteredResults = reconstructedData.map(data => {
			const startIdx = this.binarySearch(data.timestamps, initialTime, true);
			const endIdx = this.binarySearch(data.timestamps, finalTime, false);
	
			this.DCNotfier.dgConsole("startIdx: ", startIdx);
			this.DCNotfier.dgConsole("endIdx: ", endIdx);
			this.DCNotfier.dgConsole("timestamps: ", data.timestamps);
			this.DCNotfier.dgConsole("initialTime: ", initialTime);
			this.DCNotfier.dgConsole("finalTime: ", finalTime);
	
			return {
				Nodeaddress: data.Nodeaddress,
				InitialTimeevaluated: query.initialTime,
				FinalTimeevaluated: query.finalTime,
				Values: data.Values.slice(startIdx, endIdx + 1),
				status: data.status.slice(startIdx, endIdx + 1),
				timestamps: data.timestamps.slice(startIdx, endIdx + 1),
				DataSize: endIdx - startIdx + 1
			};
		});
	
		return filteredResults;
	}
    
    //Check data available
    checkCacheData() {
		
        this.cachedData = globals.get(this.cacheKey); // Retrieve data from global cache
        
        if (!this.cachedData) {
            this.DCNotfier.dgConsole("No cache data available.");
            return [];
        }		
        // Create an array of structures 
        const formattedData = this.cachedData.map(dataEntry => ({
            Nodeaddress: dataEntry.Nodeaddress,
            initialTimeevaluated: new Date(dataEntry.InitialTimeevaluated).getTime(),
            finalTimeevaluated: new Date(dataEntry.FinalTimeevaluated).getTime()
        }));

        return formattedData;
    }
   
   //Merge data to later store it
    rawDataMerger(dataArrays) {
		try {
			// Exclude empty arrays
			const nonEmptyDataArrays = dataArrays.filter(array => Array.isArray(array) && array.length > 0);
			
			// Validate and organize data
			nonEmptyDataArrays.forEach((array, index) => {
				if (!array[0].hasOwnProperty('InitialTimeevaluated')) {
					console.error(`Invalid data structure at index ${index}:`, array);
					throw new Error(`Invalid data structure at index ${index}`);
					}
			});
			
			// First Organize Data
			nonEmptyDataArrays.sort((a, b) => a[0].InitialTimeevaluated - b[0].InitialTimeevaluated); // Sort by initial time			
			this.DCNotfier.dgConsole("---------CombinedData Updating Cache-------------");
			this.DCNotfier.dgConsole(nonEmptyDataArrays);

			const mergedData = {};
			
			// Flatten the array of arrays structure and process each data entry
			nonEmptyDataArrays.flat(2).forEach((data, index) => {
				if (!data || typeof data !== 'object') {
					console.error(`Invalid data entry at index ${index}:`, data);
					throw new Error(`Invalid data entry at index ${index}`);
				}
				
				const { Nodeaddress, Values, status, timestamps, InitialTimeevaluated, FinalTimeevaluated, DataSize } = data;
				if (!Nodeaddress || !Values || !status || !timestamps || InitialTimeevaluated === undefined || FinalTimeevaluated === undefined || DataSize === undefined) {
					console.error(`Incomplete data entry at index ${index}:`, data);
					throw new Error(`Incomplete data entry at index ${index}`);
				}
				
				const node = Nodeaddress;
				
				if (!mergedData[node]) {
					// Initialize with the first data entry for the node
					mergedData[node] = { ...data };
				} 
				else {
				// Merge subsequent data entries
					mergedData[node].Values = mergedData[node].Values.concat(Values);
					mergedData[node].status = mergedData[node].status.concat(status);
					mergedData[node].timestamps = mergedData[node].timestamps.concat(timestamps);
					mergedData[node].DataSize += DataSize;
					mergedData[node].FinalTimeevaluated = Math.max(
					new Date(mergedData[node].FinalTimeevaluated).getTime(),
					FinalTimeevaluated
					);
					mergedData[node].InitialTimeevaluated = Math.min(
					new Date(mergedData[node].InitialTimeevaluated).getTime(),
					InitialTimeevaluated
					);
				}
			});
			
			// Convert the merged data object back into an array
			return Object.values(mergedData);
		} catch (error) {
			console.error("Error merging raw data: ", error);
			console.error(error.message);
		return []; // Return an empty array or handle the error as needed
		}
	}

	//Clear Cache
	clearCacheData(){
	
		//Store in global Variable
		globals.set(this.cacheKey, []);
		
	}
	
	//Prepare Cache data with Intervals
	cacheDataPreparator(rawData, cacheDataType) {
        if (cacheDataType !== "RawDataInIntervals") {
            console.error(`Unsupported cache data type: ${cacheDataType}`);
            return [];
        }

        const intervalLength = this.intervalLength || ONE_HOUR; // Default to one hour if not set

        return rawData.map(dataEntry => {
            const { Nodeaddress, Values, status, timestamps, InitialTimeevaluated, FinalTimeevaluated, DataSize } = dataEntry;

            const startTime = this.roundDate(new Date(InitialTimeevaluated), 'down').getTime();
            const endTimerounded=this.roundDate(new Date(FinalTimeevaluated), 'up').getTime();
            const endTime = endTimerounded+intervalLength;

            const intervals = [];
            let currentStartTime = startTime;
            
			this.DCNotfier.dgConsole("currentStartTime");
			this.DCNotfier.dgConsole(new Date (currentStartTime).toString());
			this.DCNotfier.dgConsole("endTime");
			this.DCNotfier.dgConsole(new Date (endTime).toString());
			
            while (currentStartTime < endTime) {
                const currentEndTime = Math.min(currentStartTime + intervalLength, endTime);
                const intervalData = {
                    InitialTime: currentStartTime,
                    FinalTime: currentEndTime,
                    Values: [],
                    status: [],
                    timestamps: []
                };

                for (let i = 0; i < timestamps.length; i++) {
                    const timestamp = new Date(timestamps[i]).getTime();
                    if (timestamp >= currentStartTime && timestamp < currentEndTime) {
                        intervalData.Values.push(Values[i]);
                        intervalData.status.push(status[i]);
                        intervalData.timestamps.push(timestamp);
                    }
                }

                intervals.push(intervalData);
                currentStartTime = currentEndTime;
            }

            return {
                Nodeaddress,
                InitialTimeevaluated,
                FinalTimeevaluated,
                IntervalLength: intervalLength,
                CacheDataType: cacheDataType,
                Data: intervals
            };
        });
    }
    
    //Reconstruct Cache data
    cacheDataReconstructor(cacheData) {
        return cacheData.map(entry => {
            try {
                switch (entry.CacheDataType) {
                    case 'RawDataInIntervals':
                        const allValues = [];
                        const allStatus = [];
                        const allTimestamps = [];

                        entry.Data.forEach(interval => {
                            allValues.push(...interval.Values);
                            allStatus.push(...interval.status);
                            allTimestamps.push(...interval.timestamps);
                        });

                        return {
                            DataSize: allValues.length,
                            FinalTimeevaluated: entry.FinalTimeevaluated,
                            InitialTimeevaluated: entry.InitialTimeevaluated,
                            Nodeaddress: entry.Nodeaddress,
                            Values: allValues,
                            status: allStatus,
                            timestamps: allTimestamps
                        };

                    // Add more cases for different CacheDataType as needed
                    default:
                        throw new Error(`Unsupported cache data type: ${entry.CacheDataType}`);
                }
            } catch (error) {
                console.error(`Error reconstructing data entry for Nodeaddress ${entry.Nodeaddress}:`, error);
                return {
                    DataSize: 0,
                    FinalTimeevaluated: entry.FinalTimeevaluated,
                    InitialTimeevaluated: entry.InitialTimeevaluated,
                    Nodeaddress: entry.Nodeaddress,
                    Values: [],
                    status: [],
                    timestamps: [],
                    Error: error.message
                };
            }
        });
    }

	
	//----------Auxiliary Functions---------------------//
	//--------------------------------------------------//
	roundDate(date, orientation) {
        const roundedDate = new Date(date);
        roundedDate.setMinutes(0, 0, 0);

        if (orientation === 'down') {
            return roundedDate;
        }

        if (orientation === 'up' && roundedDate.getMinutes() > 0) {
            roundedDate.setHours(roundedDate.getHours() + 1);
        }

        return roundedDate;
    }	
	
	//Fix Cache Timestamps
	fixCacheToTimestamps(dataArray) {
		return dataArray.map(item => ({
			...item,
			InitialTimeevaluated: new Date(item.InitialTimeevaluated).getTime(),
			FinalTimeevaluated: new Date(item.FinalTimeevaluated).getTime()
		}));
	}
	
	//Find intersection of Time intervals
	findTimeIntersection(interval1, interval2) {
		// Extract start and end times from both intervals
		let [start1, end1] = interval1;
		let [start2, end2] = interval2;
	
		// Initialize arrays to store the common and uncommon intervals
		let commonIntervals = [];
		let uncommonIntervals = [];
	
		// Calculate the intersection (common interval)
		let commonStart = Math.max(start1, start2);
		let commonEnd = Math.min(end1, end2);
	
		// There is overlap if the common end is after the common start
		if (commonEnd >= commonStart) {
			commonIntervals.push([commonStart, commonEnd]);
		}
	
		// Calculate the non-overlapping interval for the first interval only
		if (start1 < commonStart) {
			uncommonIntervals.push([start1, commonStart]);
		}
		if (end1 > commonEnd) {
			uncommonIntervals.push([commonEnd, end1]);
		}
	
		// If there's no common interval, the entire first interval is uncommon
		if (commonIntervals.length === 0) {
			uncommonIntervals = [[start1, end1]];
		}
	
		return { commonIntervals, uncommonIntervals };
	}
	
	//Auxiliary Function to increase Cache Performance
	binarySearch(arr, target, findStart) {
		let low = 0;
		let high = arr.length - 1;
		let result = -1;
	
		while (low <= high) {
			const mid = Math.floor((low + high) / 2);
			if (arr[mid] === target) {
				result = mid;
				if (findStart) {
					high = mid - 1;
				} else {
					low = mid + 1;
				}
			} else if (arr[mid] < target) {
				low = mid + 1;
			} else {
				high = mid - 1;
			}
		}
	
		return findStart ? (result === -1 ? low : result) : (result === -1 ? high : result);
	}
}

//---------------Dashboard Creator Class----------------//
//-----------------------------------------------------//

class DashboardDataCreator {
	// Attributes
	dataRequest; // Holds the specifics of the data request
	dashboardData; // Holds processed data ready for the dashboard/Highcharts
	processRequest; // May contain request processing logic or status
	processedData; // Flag or data that indicates the data has been processed
	rawData; // The raw data retrieved based on rawDataRequest
	nodes;

	// Constructor: Initialize Attributes
	constructor(dataRequest) {
		//this.dataRequest = this.decompressData(dataRequest,keyMapping);
		this.dataRequest = dataRequest;
		this.initialTime = this.dataRequest.updateRequest[0].initialTime;
		this.finalTime =this.dataRequest.updateRequest[0].finalTime;
		this.initialTimeI = this.initialTime;
		this.finalTimeI = this.finalTime;
		this.intervalQuery=2*86400*1000;
		this.dashboardData = null;
		this.processRequest = null;
		this.processedData = false;
		this.nodes=this.rawDataRequestProcessor(this.dataRequest,"nodesRequest"); //Find all Unique Nodes
		this.rawDataRequestRTInfo;
		this.rawData = null;
		this.DCN;
	}
	
	// Methods
	// Handles rawDataRequest and orchestrate everything related to rawData
	async initialize(dashboardDataProcessor,dashboardCacheManager,dashboardCreatorNotifier) {
		try {
			this.DCNotfier=dashboardCreatorNotifier;
			this.DCNotfier.dgConsole();		
			this.DCNotfier.dgConsole("------------Operation Mode---------");
			this.DCNotfier.dgConsole(this.dataRequest.updateRequest[0].OperationMode);
			
			//Gets Raw Data History Mode
			if (this.dataRequest.updateRequest[0].OperationMode==="Hist"){
				
				this.rawData = await this.rawDataCreator(dashboardCacheManager);
				this.DCNotfier.dgConsole("-----------Raw Data-----------");
				this.DCNotfier.dgConsole(this.rawData);
				
				// Process Data			
				dashboardDataProcessor.initialize(this.dataRequest,this.rawData);
				const processedData = dashboardDataProcessor.processRequestHandler(this.dataRequest, this.rawData);
				this.DCNotfier.dgConsole("-----------ProcessedData-----------");
				this.DCNotfier.dgConsole(processedData);
		
				//Gives format to data
				this.dashboardData=this.dashboardDataFormater(processedData);
				this.DCNotfier.dgConsole("-----------Final Format Data-----------");
				this.DCNotfier.dgConsole(this.dashboardData);
				
				
				//Sends response to webclient			
				this.dashboardDataWriter();				
			} 
			
			//Gets Raw Data Real Time Mode
			else if (this.dataRequest.updateRequest[0].OperationMode==="RealTime"){			
				
				//Prepare data required
				this.rawDataRequestRTInfo=this.rawDataRequestProcessor(dataRequest,"rawDataRequestRTInfo"); //Find all Unique RT Nodes
				this.DCNotfier.dgConsole("this.rawDataRequestRTInfo");
				this.DCNotfier.dgConsole(this.rawDataRequestRTInfo);
				
				this.rawData = await this.rawDataCreatorRT(dashboardCacheManager);
				this.DCNotfier.dgConsole("-----------Raw Data-----------");
				//this.DCNotfier.dgConsole(this.rawData);	
				
				// Process Data			
				dashboardDataProcessor.initialize(this.dataRequest,this.rawData,this.DCNotfier);
				const processedData = dashboardDataProcessor.processRequestHandler(this.dataRequest, this.rawData);
				this.DCNotfier.dgConsole("-----------ProcessedData-----------");
				this.DCNotfier.dgConsole(processedData);				
				
				//Gives format to data
				this.dashboardData=this.dashboardDataFormater(processedData);
				this.DCNotfier.dgConsole("-----------Final Format Data-----------");
				this.DCNotfier.dgConsole(this.dashboardData);
				
				//Sends response to webclient			
				this.dashboardDataWriter();	
			}			
			
		} catch (error) {
			console.error("An error occurred while processing dashboard data:");
			console.error(error.message);
		}
	}
	
	async rawDataCreator(dashboardCacheManager) {
		
		if(this.dataRequest.updateRequest[0].cacheConfig.CacheEnabled==="false"){ //Dont use Cache Data
			
			this.DCNotfier.dgConsole("----------------Cache Disabled-------------");
			//Clear existing cache
			dashboardCacheManager.clearCacheData();
			
			//Bring Data
			this.rawData = await this.rawDataRequestExecutor(this.nodes);
			
			return this.rawData;
		} 
		
		
		else{//Use Cache	
			
			//Initialize Cache
			dashboardCacheManager.setCacheConfig(this.dataRequest.updateRequest.cacheConfig);	
			
			// Check Cached Data
			var checkedCacheData = await dashboardCacheManager.checkCacheData();
		
			this.DCNotfier.dgConsole("----------------Cache Enabled-------------");					
			//No data already in Cache
			if (checkedCacheData.length === 0) {
				this.rawData = await this.rawDataRequestExecutor(this.nodes);
				this.DCNotfier.dgConsole("Fetched all data due to empty cache.");
				dashboardCacheManager.initialize(this.initialTimeI, this.finalTimeI, this.rawData);
				return this.rawData;
			} 	
				
			//Data in Cache
			else {
				// Time Available in Cache
				const cacheInitialTime = new Date(checkedCacheData[0].initialTimeevaluated).getTime();
				const cacheFinalTime = new Date(checkedCacheData[0].finalTimeevaluated).getTime();
				
				// Calculate intervals
				var intervals_intersection = dashboardCacheManager.findTimeIntersection(
					[(new Date(this.initialTime)).getTime(), (new Date(this.finalTime)).getTime()],
					[cacheInitialTime, cacheFinalTime]
				);
				
				this.DCNotfier.dgConsole("Initial time required");
				this.DCNotfier.dgConsole((new Date(this.initialTime)).toString());
				this.DCNotfier.dgConsole("Final time required");
				this.DCNotfier.dgConsole((new Date(this.finalTime)).toString());
				this.DCNotfier.dgConsole("Cached Initial time");
				this.DCNotfier.dgConsole(new Date(cacheInitialTime).toString());
				this.DCNotfier.dgConsole("Cached Final time");
				this.DCNotfier.dgConsole(new Date(cacheFinalTime).toString());
				this.DCNotfier.dgConsole("--------------intervals_intersecction-------------");
				this.DCNotfier.dgConsole("Common Intervals");
				this.DCNotfier.dgConsole(intervals_intersection);			
				
	
				let rawDataFetched = [];
				let cachedDataResults = [];
		
				//------------------Fetch data from the cache-------------------//
				//-------------------Common Intervals--------------------------//
				
				if (intervals_intersection.commonIntervals.length > 0) {
				
					intervals_intersection.commonIntervals.forEach(async interval => {
						let query = {
							nodes: this.nodes,
							initialTime: interval[0],
							finalTime: interval[1]
						};
						
						let commonData = dashboardCacheManager.queryCacheData([query]);
						//let commonData = dashboardCacheManager.queryCacheData2([query]);

						cachedDataResults.push(commonData);
					});
					this.DCNotfier.dgConsole("-------------cachedDataResults-----------");
					//this.DCNotfier.dgConsole(cachedDataResults[0]);
				
					if(intervals_intersection.uncommonIntervals.length <= 0){ //No Uncommondata
						return cachedDataResults[0];
					}
				}
				
				//Add first cachedDataResults
				let combinedData = [cachedDataResults[0]];	
				let updateTimeRanges=[];
				let timethreshold=28800000;
				
				//------------------Fetch data from the Raw Data-------------------//
				//--------------------Uncommon Intervals--------------------------//
				
				if (intervals_intersection.uncommonIntervals.length > 0) {
					
					for (let i = 0; i < intervals_intersection.uncommonIntervals.length; i++) {
						this.initialTimeI = new Date(intervals_intersection.uncommonIntervals[i][0]).getTime();
						this.finalTimeI = new Date(intervals_intersection.uncommonIntervals[i][1]).getTime();
						let fetchedData = await this.rawDataRequestExecutor(this.nodes);
						rawDataFetched.push(fetchedData);
						
						//Add Upated time Ranges
						updateTimeRanges.push(this.finalTimeI-this.initialTimeI);			
						
						//Add to combined data
						combinedData.push(fetchedData);
						
						
					}
					
					this.DCNotfier.dgConsole("-------------rawDataFetched-----------");
					//this.DCNotfier.dgConsole(rawDataFetched);
					
					//---------Update Cache if it has commonIntervals--------------//
					//-------------------------------------------------------------//
					
					if(intervals_intersection.commonIntervals.length > 0 && updateTimeRanges.some(value => value > timethreshold)){ //It has common data
						
						//Update Cache data with Data Requested
						dashboardCacheManager.updateCacheData(rawDataFetched);
					}		
					
					//------------------Only Uncommon Intervals---------------------//
					//-------------------------------------------------------------//
					
					else if(intervals_intersection.commonIntervals.length <= 0){ //No Common data
					
						const uncommonIntervalStart = intervals_intersection.uncommonIntervals[0][0];
						
						//Check order
						if (uncommonIntervalStart < cacheInitialTime) {
							// Before tail
							this.initialTimeI = new Date(intervals_intersection.uncommonIntervals[0][1]).getTime();
							this.finalTimeI = cacheInitialTime;
							
							updateTimeRanges.push(this.finalTimeI-this.initialTimeI);
							
						} else {
							// After tail
							this.initialTimeI = cacheFinalTime;
							this.finalTimeI = new Date(intervals_intersection.uncommonIntervals[0][0]).getTime();
							
							updateTimeRanges.push(this.finalTimeI-this.initialTimeI);
						}
						
						//Fit missing data in cache
						 const fetchedDataI = await this.rawDataRequestExecutor(this.nodes);	
						 
						 //Update only if is relevant
						if (updateTimeRanges.some(value => value > timethreshold)) { 					 	 
							dashboardCacheManager.updateCacheData([fetchedDataI]);
						}
						
						//Only return rawDataFetched
						return rawDataFetched[0];
					}
				}
				
				//---------------Merge Common and Uncommon data-----------------//
				//-------------------------------------------------------------//
				
				let mergedData=dashboardCacheManager.rawDataMerger(combinedData);
				return mergedData;
			}
		}
	}
	
	async rawDataCreatorRT(dashboardCacheManager) {
        try {			
        
			if (this.rawDataRequestRTInfo.length>0){
			 return [];
			}
			
			else{
				var rawDataI=new Array();
				
				// Iterate over each element in rawDataRequestRTInfo
				for (let rtInfo of this.rawDataRequestRTInfo) {
					// Update initialTime, finalTime, and nodes
					this.initialTime = rtInfo.initialTime;
					this.finalTime = rtInfo.finalTime;
					this.nodes = [rtInfo.Nodeaddress];
					
					let rawDataII= await this.rawDataCreator(dashboardCacheManager);
				 
					// Fetch raw data using rawDataCreator
					rawDataI.push(rawDataII[0]);
				}            
				return rawDataI; // Optionally return the last fetched raw data
            }
        } catch (error) {
            console.error("Error executing rawDataCreatorRT:", error);
        }
    }
	
	//Extract specific info from the rawDataRequest 
	rawDataRequestProcessor(dataRequest,infoRequired) {

		switch (infoRequired) {
		  case "nodesRequest":
			var dataRequestI=dataRequest.chartsNodes;
			// Use a Set to store unique nodes
			const uniqueNodes = new Set();
		
			// Iterate over each chart object in the array
			dataRequestI.forEach(chart => {
				// Add each node to the Set (duplicates will be ignored)
				chart.chartNodes.forEach(node => uniqueNodes.add(node));
			});
		
			// Convert the Set back to an array and return it
			return Array.from(uniqueNodes);
			
		case "rawDataRequestRTInfo":
            // Collect information for RT update
            const rtInfo = [];
            
            // Iterate over updateRequest array
            dataRequest.updateRequest.forEach(request => {
                // Check the informationRT array within the request
                request.informationRT.forEach(info => {
                    if (info.AllDataRequired) {
                        rtInfo.push({
                            Nodeaddress: info.Node,
                            finalTime: info.IntervalInfo.end,
                            initialTime: info.IntervalInfo.start
                        });
                    }
                });
            });
            
            return rtInfo;
		
		  default:
			statements
		}
	
	}	
	
	// Executes the rawDataRequest 
	rawDataRequestExecutor(nodes) {
		this.DCNotfier.dgConsole("Initiating queries...");
		const startTime = new Date().getTime();
		
		const queries = nodes.map(node => this.asyncHistQuery(node));
	
		return Promise.allSettled(queries).then(results => {
			const endTime = new Date().getTime();
			this.DCNotfier.dgConsole(`Total execution time for queries: ${endTime - startTime} milliseconds.`);
			
			// Map each result to include the desired structure along with DataSize
			const structuredResults = results.map((result, index) => {
				if (result.status === 'fulfilled' && result.value.result) {
					const values = result.value.result.map(item => item.value);					
					const timestamps = result.value.result.map(item => item.timestamp);
					const statuses = result.value.result.map(item => item.status);
					return {
						Nodeaddress: nodes[index], // Assuming the node address can be directly taken from the nodes array
						InitialTimeevaluated: new Date(this.initialTimeI),  // Include initial time
						FinalTimeevaluated: new Date(this.finalTimeI),  // Include final time
						Values: values,
						timestamps: timestamps,
						status: statuses,
						DataSize: values.length // Add the DataSize key here
					};
				} else {
					console.error(`Error querying data for node ${nodes[index]}:`, result.reason);
					return {
						Nodeaddress: nodes[index],
						InitialTimeevaluated: new Date(this.initialTimeI),  // Include initial time
						FinalTimeevaluated: new Date(this.finalTimeI),  // Include final time
						Values: [],
						timestamps: [],
						status: [],
						DataSize: 0 // DataSize is 0 in case of error
					};
				}
			});
			
			return structuredResults;
		});
	}	
	
	async asyncHistQuery(node) {
		const initialTime = new Date(this.initialTimeI);
		const finalTime = new Date(this.finalTimeI);
		const intervalQuery = this.intervalQuery || 3600 * 1000; // Default to 1 hour if not set
	
		// Break the time range into smaller intervals
		let currentStartTime = initialTime.getTime();
		let allValues = [];
	
		while (currentStartTime < finalTime.getTime()) {
			let currentEndTime = Math.min(currentStartTime + intervalQuery, finalTime.getTime());
	
			const filter = {
				type: ["v:1"], // Example type, adjust based on actual requirements
				timestamp: [`n:>=${currentStartTime}<${currentEndTime}`],
				address: [`g:${node}`]
			};
	
			this.DCNotfier.dgConsole("-----------Query filter-------------");
			this.DCNotfier.dgConsole(filter);
			this.DCNotfier.dgConsole("Initial time query");
			this.DCNotfier.dgConsole(new Date(currentStartTime).toString());
			this.DCNotfier.dgConsole("Final time query");
			this.DCNotfier.dgConsole(new Date(currentEndTime).toString());
	
			try {
				let continuationPoint = null;
				let hasMoreData = true;
	
				while (hasMoreData) {
					const options = {
						continuationpoint: continuationPoint,
						timeout: 3600 // Set a timeout of 1 hour
					};
	
					// Wrap the history.query in a promise to use with await
					const result = await new Promise((resolve, reject) => {
						try {
							const queryResult = history.query(filter, options);
							this.DCNotfier.dgConsole("result size: ");
							this.DCNotfier.dgConsole(queryResult.result.length);
							resolve(queryResult);
						} catch (error) {
							reject(error);
						}
					});
	
					if (result.error) {
						throw new Error(result.error.message);
					}
	
					// Concatenate the result array
					allValues = allValues.concat(result.result);
	
					if (result.continuationpoint) {
						continuationPoint = result.continuationpoint;
					} else {
						hasMoreData = false;
					}
				}
			} catch (error) {
				console.error(`Error querying data for node ${node}:`, error);
				return [{
					status: "rejected",
					reason: error.message
				}];
			}
	
			currentStartTime = currentEndTime;
		}
	
		// After collecting all results, format them correctly
		return {
			
				More: false,
				continuationpoint: 0,
				result: allValues
			
		};
	}
	
	dashboardDataFormater(processedData) {
		let chartsData = [];
		let errors = [];
	
		try {
			processedData.forEach(chart => {
			
				//Pack InformationRT
				let informationRT=chart.processedDataStruct.map((dataStruct) => {
					return dataStruct.informationRT;
				});
				
				//Pack Tooltip Info
				let tooltipInfo=chart.processedDataStruct.map((dataStruct) => {
					return dataStruct.tooltipInfo;
				});
				
			
				let chartData = {
					chartID: chart.chartID,
					informationRT: informationRT,
					tooltipInfo:tooltipInfo,
					chartSeries: [],
					LimitDashboardData: [],
					chartCategories: chart.processedDataStruct[0]?.chartCategories || []
				};
				
				if(chart.elementType=="Chart")	{
					//For Chart elements
					switch (chart.chartType) {
						case "Line":
						case "Spline":
						case "Area":
						case "Column":
						case "Bar":
							// For these types, each processedDataStruct item becomes a series
							chart.processedDataStruct.forEach((dataStruct, k) => {
								const seriesName = dataStruct.processedNode; // Using processedNode for series name
								
								//For ValueType Series
								let series = {
									name: seriesName,
									data: dataStruct.processedDataI.map((dataPoint, i) => {
										if (chart.categoryType === "AllData-DateTime") {
											const category = chartData.chartCategories.find(c => c.chartNode === dataStruct.processedNode);
											return category ? [category.categories[i], dataPoint] : dataPoint;
										} else {
											return dataPoint;
										}
									})
								};
								
								
								//For LimitType Series
								let seriesLimint;			
								
								//If there is LimitDashboardData add it
								let limitAnalysisEnabledI=dataStruct.LimitDashboardData==undefined?false:dataStruct.LimitDashboardData.Enabled;
	
								if (limitAnalysisEnabledI) {
									if (chart.categoryType === "AllData-DateTime") {
										seriesLimint = {
											name: seriesName+"_Limit",
											data: dataStruct.LimitDashboardData.Values.map((dataPoint, i) => {
													const category = dataStruct.LimitDashboardData.timestamps[i];
													return  [category, dataPoint];
											})
										}
									}
									else if (chart.categoryType.includes("Interval")) {
										seriesLimint= {
											name: seriesName+"_Limit",
											data:dataStruct.LimitDashboardData.Values,
										}
									}
								}							
								else	{
									seriesLimint={};
									
								}				
								chartData.chartSeries.push(series);
								chartData.LimitDashboardData.push(seriesLimint);
							});
							break;
						case "Pie":
						case "Pyramid":
							// For Pie/Pyramid, use processedDataI directly as the series data
							let seriesData = chart.processedDataStruct.map(dataStruct => ({
								name: dataStruct.processedNode,
								y: dataStruct.processedDataI[0],
							}));
							chartData.chartSeries.push({name: "Aggregate", data: seriesData});
							break;
						case "Gauge":
						case "Solidgauge":
							// Use the last value of processedDataI
							if (chart.processedDataStruct.length > 0) {
								let lastDataStruct = chart.processedDataStruct[chart.processedDataStruct.length - 1];
								let gaugeData = {
									name: lastDataStruct.processedNode,
									data: [lastDataStruct.processedDataI[lastDataStruct.processedDataI.length - 1]]  // Assuming the last value in the array
								};
								chartData.chartSeries.push(gaugeData);
								
								//For LimitType Series
								let seriesLimint;			
								
								//If there is LimitDashboardData add it
								let limitAnalysisEnabledI=lastDataStruct.LimitDashboardData==undefined?false:lastDataStruct.LimitDashboardData.Enabled;
								if (limitAnalysisEnabledI) {
									if (chart.categoryType.includes("Single")) {
											seriesLimint= {
												name: lastDataStruct.processedNode+"_Limit",
												data:lastDataStruct.LimitDashboardData.Values,
											}
									}		
													
									else	{
										seriesLimint={};									
									}					
									chartData.LimitDashboardData.push(seriesLimint);
								}
							}
						break;
						case "Histogram":
							const seriesName = chart.processedDataStruct[0].processedNode;
							const scatterData = chart.processedDataStruct[0].processedDataI.map(dataPoint => dataPoint);
							chartData.chartSeries.push({
								name: seriesName,
								type: 'scatter',
								data: scatterData,
							});										
						break;
						default:
							errors.push(`Unsupported chartType: ${chart.chartType} for chartID ${chart.chartID}`);
					}				
				}
				//For Table elements
				else if(chart.elementType == "Table") {
					let tableSeriesData = [];
					let seriesNames = [];
				
					// Go through each processedDataStruct and extract processedDataI
					chart.processedDataStruct.forEach((dataStruct) => {
						// Collect the name of the node for series
						seriesNames.push(dataStruct.processedNode);
				
						// Iterate through each value in processedDataI and organize by index
						dataStruct.processedDataI.forEach((dataPoint, index) => {
							if (!tableSeriesData[index]) {
								tableSeriesData[index] = []; // Initialize the array for this index
							}
							tableSeriesData[index].push(dataPoint); // Add the value to the corresponding row
						});
					});
				
					// Create the series for the table
					const tableSeries = {
						name: seriesNames.join(", "), // Join the series names together for the chart series
						data: tableSeriesData // Array of arrays, where each sub-array represents a row (timestamp)
					};
				
					// Push the constructed series into chartSeries
					chartData.chartSeries=(tableSeries);
				}
				//For Number Elements
				else if(chart.elementType == "Number") {
					// Use the last value of processedDataI
							if (chart.processedDataStruct.length > 0) {
								let lastDataStruct = chart.processedDataStruct[chart.processedDataStruct.length - 1];
								let gaugeData = {
									name: lastDataStruct.processedNode,
									data: [lastDataStruct.processedDataI[lastDataStruct.processedDataI.length - 1]]  // Assuming the last value in the array
								};
								chartData.chartSeries.push(gaugeData);
								
								//For LimitType Series
								let seriesLimint;			
								
								//If there is LimitDashboardData add it
								let limitAnalysisEnabledI=lastDataStruct.LimitDashboardData==undefined?false:lastDataStruct.LimitDashboardData.Enabled;
								if (limitAnalysisEnabledI) {
									if (chart.categoryType.includes("Single")) {
											seriesLimint= {
												name: lastDataStruct.processedNode+"_Limit",
												data:lastDataStruct.LimitDashboardData.Values,
											}
									}		
													
									else	{
										seriesLimint={};									
									}					
									chartData.LimitDashboardData.push(seriesLimint);
								}
							}
				}
				
				chartsData.push(chartData);
			});
		} catch (error) {
			errors.push(`Error processing data: ${error.message}`);
		}
	
		return {
			chartsData: chartsData,
			Errors: errors
		};
	}
	
	//Writes to the node
	dashboardDataWriter() {
		// Assuming this function is part of a class that has access to this.dataRequest and this.dashboardData
		if (this.dashboardData) {
			 Parameters.response.setHeader("Content-Type", "application");
			 Parameters.response.write(JSON.stringify(this.dashboardData), "");
			}
		else {
			Parameters.response.setHeader("Content-Type", "application");
			Parameters.response.write("Error creating Dashboard Data", "");
			this.DCNotfier.dgConsole("Single data request is not set to true.");
		}
	}
	
	decompressData(data, keyMapping) {
		const reverseMapping = Object.fromEntries(Object.entries(keyMapping).map(([key, value]) => [value, key]));
		if (Array.isArray(data)) {
			return data.map(item => this.decompressData(item, keyMapping));
		} else if (typeof data === 'object' && data !== null) {
			const decompressed = {};
			for (let key in data) {
				if (data.hasOwnProperty(key)) {
					const decompressedKey = reverseMapping[key] || key;
					decompressed[decompressedKey] = this.decompressData(data[key], keyMapping);
				}
			}
			return decompressed;
		}
		return data;
    }
}

//---------------Dashboard Creator Notifier----------------//
//-----------------------------------------------------//

class DashboardCreatorNotifier {

	constructor(dataRequest) {		
		this.debuggingEnabled=true;		
	}
		
	dgConsole(message){
		if (this.debuggingEnabled){
			console.log(message);
		}
	}
}



//Create Dashboard Notifier used by DashboardDataCreator
const dashboardCreatorNotifier1 = new DashboardCreatorNotifier();

//Create Dashboard Processor used by DashboardDataCreator
const dashboardDataProcessor1 = new dashboardDataProcessor(dashboardCreatorNotifier1);

//Create Dashboard Cache Manager used by DashboardDataCreator
const dashboardCacheManager1 = new DashboardCacheManager(dashboardCreatorNotifier1);

//Create Dashboard Data Creator
const dashboardDataCreator1 = new DashboardDataCreator(dataRequest);

//Create and Send Dashboard data
dashboardDataCreator1.initialize(dashboardDataProcessor1,dashboardCacheManager1,dashboardCreatorNotifier1);]]></code>
</script>
